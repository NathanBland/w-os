{"version":3,"sources":["webpack:///static/js/2.86b1f5685590fdb01722.js","webpack:///./~/core-js/library/modules/_wks.js","webpack:///wApp.vue?2abb*","webpack:///./src/components/wApp.vue?9140**","webpack:///./src/components/wApp.vue?cf76**","webpack:///./src/components/wApp.vue?2155**","webpack:///./src/components/wApp.vue?a07d**","webpack:///./~/interact.js/interact.js?3c23*","webpack:///./src/components/wApp.vue?ad9e**","webpack:///./src/components/wApp.vue?fe08**","webpack:///./~/core-js/library/modules/_iterators.js","webpack:///./~/core-js/library/modules/_set-to-string-tag.js","webpack:///./~/core-js/library/modules/_iter-define.js","webpack:///./~/core-js/library/modules/_library.js","webpack:///./~/core-js/library/modules/_object-create.js","webpack:///./~/core-js/library/modules/_redefine.js","webpack:///./~/core-js/library/modules/_add-to-unscopables.js","webpack:///./~/core-js/library/modules/_html.js","webpack:///./~/core-js/library/modules/_iter-create.js","webpack:///./~/core-js/library/modules/_iter-step.js","webpack:///./~/core-js/library/modules/_object-dps.js","webpack:///./~/core-js/library/modules/_object-gpo.js","webpack:///./~/core-js/library/modules/_string-at.js","webpack:///./~/core-js/library/modules/_wks-define.js","webpack:///./~/core-js/library/modules/_wks-ext.js","webpack:///./~/core-js/library/modules/es6.array.iterator.js","webpack:///./~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/core-js/library/modules/web.dom.iterable.js","webpack:///./~/core-js/library/modules/_object-gopn.js","webpack:///./src/components/apps/terminal/commands.js","webpack:///terminal.vue","webpack:///./~/babel-runtime/core-js/symbol.js","webpack:///./~/babel-runtime/core-js/symbol/iterator.js","webpack:///./~/babel-runtime/helpers/typeof.js","webpack:///./~/core-js/library/fn/symbol/index.js","webpack:///./~/core-js/library/fn/symbol/iterator.js","webpack:///./~/core-js/library/modules/_enum-keys.js","webpack:///./~/core-js/library/modules/_is-array.js","webpack:///./~/core-js/library/modules/_keyof.js","webpack:///./~/core-js/library/modules/_meta.js","webpack:///./~/core-js/library/modules/_object-gopd.js","webpack:///./~/core-js/library/modules/_object-gopn-ext.js","webpack:///./~/core-js/library/modules/es6.symbol.js","webpack:///./~/core-js/library/modules/es7.symbol.async-iterator.js","webpack:///./~/core-js/library/modules/es7.symbol.observable.js","webpack:///./src/components/apps/terminal/terminal.vue?bb82","webpack:///./src/components/apps/terminal/terminal.vue?8bdb","webpack:///./src/components/apps/terminal/terminal.vue?925a","webpack:///./src/components/apps/terminal/terminal.vue"],"names":["webpackJsonp","20","module","exports","__webpack_require__","store","uid","Symbol","USE_SYMBOL","$exports","name","24","dragMoveListener","event","target","parentNode","x","parseFloat","getAttribute","dx","y","dy","style","webkitTransform","transform","setAttribute","Object","defineProperty","value","interact","draggable","inertia","restrict","restriction","endOnly","elementRect","top","left","bottom","right","autoScroll","onmove","onend","data","hasFocus","isMax","isDeleted","methods","bringToFront","e","this","$dispatch","currentTarget","$set","closeApp","maxApp","makeMe","removeChild","classList","remove","events","loseFocus","props","title","type","String","required","loading","Boolean","hasSubNav","default","26","push","id","version","sources","names","mappings","file","sourcesContent","sourceRoot","27","28","content","locals","29","30","realWindow","blank","isElement","o","_window","getWindow","window","test","Element","nodeType","nodeName","isWindow","thing","Window","isDocFrag","DocumentFragment","isArray","isObject","undefined","length","isFunction","splice","isNumber","isBool","isString","trySelector","document","querySelector","extend","dest","source","prop","pointerExtend","deprecated","vendor","prefixedPropREs","indexOf","copyCoords","src","page","client","timeStamp","setEventXY","targetObj","pointers","interaction","pointer","pointerAverage","getPageXY","tmpXY","getClientXY","Date","getTime","setEventDeltas","prev","cur","dt","Math","max","speed","hypot","vx","vy","isNativePointer","Event","supportsTouch","Touch","getXY","xy","isOperaMobile","scrollX","scrollY","getScrollXY","win","documentElement","scrollLeft","scrollTop","getPointerId","pointerId","identifier","getActualElement","element","SVGElementInstance","correspondingUseElement","node","rootNode","ownerDocument","defaultView","parentWindow","getElementClientRect","clientRect","SVGElement","getBoundingClientRect","getClientRects","width","height","getElementRect","isIOS7","scroll","getTouchPair","touches","changedTouches","average","pageX","pageY","clientX","clientY","screenX","screenY","i","touchBBox","minX","min","minY","maxX","maxY","touchDistance","deltaSource","defaultOptions","sourceX","sourceY","touchAngle","prevAngle","angle","atan","PI","dr","drClamped","getOriginXY","interactable","origin","options","parentElement","getRect","closest","_getQBezierValue","t","p1","p2","p3","iT","getQuadraticCurvePoint","startX","startY","cpX","cpY","endX","endY","position","easeOutQuad","b","c","d","nodeContains","parent","child","selector","matchesSelector","host","inContext","_context","testIgnore","interactableElement","ignoreFrom","matchesUpTo","testAllow","allowFrom","checkAxis","axis","thisAxis","drag","checkSnap","action","snap","enabled","checkRestrict","checkAutoScroll","withinInteractionLimit","maxActions","maxPerElement","activeInteractions","targetCount","targetElementCount","len","interactions","otherAction","prepared","active","interacting","maxInteractions","indexOfDeepestElement","elements","dropzone","n","deepestZone","index","deepestZoneParents","dropzoneParents","unshift","HTMLElement","SVGSVGElement","ownerSVGElement","parents","lastChild","previousSibling","Interaction","dropTarget","dropElement","prevDropTarget","prevDropElement","edges","matches","matchElements","inertiaStatus","smoothEnd","ending","startEvent","upCoords","xe","ye","sx","sy","t0","vx0","vys","duration","resumeDx","resumeDy","lambda_v0","one_ve_v0","Function","prototype","bind","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","that","activeDrops","dropzones","rects","pointerIds","downTargets","downTimes","holdTimers","prevCoords","curCoords","startCoords","pointerDelta","downEvent","downPointer","_eventTarget","_curEventTarget","prevEvent","tapTime","prevTap","startOffset","restrictOffset","snapOffsets","gesture","start","startDistance","prevDistance","distance","scale","startAngle","snapStatus","realX","realY","snappedX","snappedY","targets","locked","changed","restrictStatus","restrictedX","restrictedY","restricted","pointerIsDown","pointerWasMoved","gesturing","dragging","resizing","resizeAxes","mouse","getInteractionFromPointer","eventType","eventTarget","mouseEvent","pointerType","allowResume","supportsPointerEvent","contains","doOnInteractions","method","path","curEventTarget","prevTouchTime","_updateEventTargets","InteractEvent","phase","related","starting","coords","relativePoints","range","x0","y0","clientX0","clientY0","ctrlKey","altKey","shiftKey","metaKey","button","buttons","detail","relatedTarget","zeroResumeDelta","resize","square","axes","box","ds","da","prevScale","velocityX","velocityY","atan2","overlap","up","down","swipe","velocity","preventOriginalDefault","originalEvent","preventDefault","getActionCursor","cursor","actionCursors","cursorKey","edgeNames","checkResizeEdge","rect","margin","defaultActionChecker","resizeEdges","shouldResize","actionIsEnabled","resizeOptions","edge","validateAction","actionName","delegateListener","useCapture","fakeEvent","delegated","delegatedEvents","selectors","context","contexts","listeners","j","delegateUseCapture","call","interactables","get","Interactable","_element","_iEvents","Node","PointerEvent","add","pEventTypes","pointerDown","move","pointerHover","_doc","documents","listenToDocument","set","warnOnce","message","warned","console","warn","apply","arguments","endAllInteractions","pointerEnd","doc","MSPointerEvent","over","out","cancel","selectorDown","pointerMove","pointerOver","pointerOut","pointerUp","pointerCancel","autoScrollMove","frameElement","parentDoc","error","windowParentError","checkAndPreventDefault","useAttachEvent","currentAction","array","nodeList","ie8MatchesSelector","replace","prefixedMatchesSelector","limit","el","createTextNode","wrap","sqrt","dynamicDrop","base","accept","actionChecker","styleCursor","dropChecker","manualStart","Infinity","drop","preserveAspectRatio","NaN","invert","perAction","offsets","container","resistance","minSpeed","endSpeed","smoothEndDuration","_holdDuration","now","dtx","prevTimeX","dty","prevTimeY","scrollBy","isScrolling","cancelFrame","reqFrame","stop","DocumentTouch","pointerMoveTolerance","all","atob","resizex","resizey","resizexy","resizetop","resizeleft","resizebottom","resizeright","resizetopleft","resizebottomright","resizetopright","resizebottomleft","wheelEvent","eventTypes","globalEvents","navigator","appName","userAgent","match","platform","appVersion","requestAnimationFrame","cancelAnimationFrame","listener","elementIndex","typeCount","attachedListeners","supplied","wrapped","useCount","ret","listenerIndex","immediatePropagationStopped","srcElement","preventDef","stopPropagation","stopProp","stopImmediatePropagation","stopImmProp","addEvent","on","removeEvent","hasOwnProperty","returnValue","cancelBubble","_elements","_targets","_attachedListeners","webkit","ptr","pushCurMatches","curMatches","curMatchElements","prevTargetElement","addPointer","elementInteractable","elementAction","getAction","forEachSelector","validateSelector","pushMatches","querySelectorAll","eventCopy","pointerIndex","setTimeout","pointerHold","collectEventTargets","forceAction","newAction","setModifications","preEnd","shouldMove","shouldSnap","shouldRestrict","setSnapping","setRestriction","setStartOffsets","snapOffset","offset","pageUp","clientUp","inertiaPosition","recordPointer","duplicateMove","clearTimeout","absX","abs","absY","targetAxis","thisInteraction","getDraggable","selectorInteractable","dragStart","dragEvent","fire","setActiveDrops","dropEvents","getDropEvents","activate","fireActiveDrops","dragMove","draggableElement","getDrop","leave","enter","resizeStart","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","current","previous","delta","deltaRect","resizeMove","invertible","originalEdges","swap","gestureStart","gestureEvent","gestureMove","isNaN","removePointer","ie8Dblclick","endEvent","inertiaOptions","pointerSpeed","inertiaPossible","endSnap","endRestrict","snapRestrict","vy0","v0","calcInertia","statusObject","useStatusXY","modifiedXe","modifiedYe","deactivate","collectDrops","drops","dropElements","currentElement","prevElement","dragElement","possibleDrops","validDrops","dropCheck","dropIndex","pointerEvent","dragLeave","prevDropzone","dragEnter","dragmove","clearTargets","lambda","te","progress","exp","quadPoint","collectSelectors","els","isSet","firePointers","interval","createNewDoubleTap","originalPointer","propagationStopped","doubleTap","matchElement","pageCoords","status","relIndex","relative","inRange","snapChanged","prevent","inertiaDur","log","innerWidth","innerHeight","interactionListeners","indexOfElement","callback","setOnEvents","phases","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","onstart","oninertiastart","setPerAction","option","checker","dropped","dropOverlap","horizontal","vertical","dragRect","cx","cy","overlapArea","overlapRatio","newValue","resizable","squareResize","gesturable","actions","setOptions","thisOption","mode","createSnapGrid","gridOffset","grid","anchors","paths","elementOrigin","allActions","rectChecker","iEvent","onEvent","funcName","search","trim","split","off","eventList","matchFound","fn","useCap","perActions","settings","setting","unset","enableDragging","enableResizing","enableGesturing","debug","downTime","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","newvalue","offsetX","offsetY","gridx","round","gridy","newX","newY","elems","lastTime","vendors","currTime","timeToCall","33","34","__vue_script__","__vue_template__","__esModule","template","42","58","def","f","has","TAG","it","tag","stat","configurable","70","LIBRARY","$export","redefine","hide","Iterators","$iterCreate","setToStringTag","getPrototypeOf","ITERATOR","BUGGY","keys","FF_ITERATOR","KEYS","VALUES","returnThis","Base","NAME","Constructor","next","DEFAULT","IS_SET","FORCED","key","IteratorPrototype","getMethod","kind","proto","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","entries","values","P","F","71","87","anObject","dPs","enumBugKeys","IE_PROTO","Empty","PROTOTYPE","createDict","iframeDocument","iframe","lt","gt","display","appendChild","contentWindow","open","write","close","create","O","Properties","result","89","105","108","109","descriptor","110","done","111","dP","getKeys","defineProperties","113","toObject","ObjectProto","constructor","114","toInteger","defined","TO_STRING","pos","a","s","l","charCodeAt","charAt","slice","116","global","core","wksExt","$Symbol","117","118","addToUnscopables","step","toIObject","Array","iterated","_t","_i","_k","Arguments","119","$at","point","120","TO_STRING_TAG","collections","Collection","144","$keys","hiddenKeys","concat","getOwnPropertyNames","318","_interopRequireWildcard","obj","newObj","_interopRequireDefault","_typeof2","_typeof3","_Applications","apps","localforage","comps","cmd","vue","command","myCmd","_ret","v","dataType","setItem","then","results","getItem","iterate","iterationNumber","324","_extends2","_extends3","_wApp","_wApp2","_commands","_commands2","commandPosition","components","wApp","watch","scrollIntoView","block","behavior","openNew","app","giveFocus","shell","focus","monitorKeys","$get","runCommand","334","335","336","_iterator","_iterator2","_symbol","_symbol2","_typeof","341","342","347","gOPS","pIE","getSymbols","symbols","isEnum","348","cof","arg","349","object","350","META","setDesc","isExtensible","FREEZE","preventExtensions","setMeta","w","fastKey","getWeak","onFreeze","meta","NEED","KEY","352","createDesc","toPrimitive","IE8_DOM_DEFINE","gOPD","getOwnPropertyDescriptor","353","gOPN","toString","windowNames","getWindowNames","361","362","DESCRIPTORS","$fails","shared","wks","wksDefine","keyOf","enumKeys","_create","gOPNExt","$GOPD","$DP","$JSON","JSON","_stringify","stringify","HIDDEN","TO_PRIMITIVE","propertyIsEnumerable","SymbolRegistry","AllSymbols","OPSymbols","USE_NATIVE","QObject","setter","findChild","setSymbolDesc","D","protoDesc","sym","isSymbol","iterator","$defineProperty","enumerable","$defineProperties","$create","$propertyIsEnumerable","E","$getOwnPropertyDescriptor","$getOwnPropertyNames","$getOwnPropertySymbols","IS_OP","TypeError","G","W","S","for","keyFor","useSetter","useSimple","getOwnPropertySymbols","replacer","$replacer","args","valueOf","363","364","367","378","751","764"],"mappings":"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","file":"static/js/2.86b1f5685590fdb01722.js","sourcesContent":["webpackJsonp([2,6],{\n\n/***/ 20:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(90)('wks')\n\t  , uid        = __webpack_require__(74)\n\t  , Symbol     = __webpack_require__(25).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n\n/***/ 24:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar interact = __webpack_require__(30);\n\tinteract('.w-app header').draggable({\n\t  inertia: true,\n\t  restrict: {\n\t    restriction: '.bound',\n\t    endOnly: true,\n\t    elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n\t  },\n\t  autoScroll: true,\n\t  onmove: dragMoveListener,\n\t\n\t  onend: function onend(event) {}\n\t});\n\t\n\tfunction dragMoveListener(event) {\n\t  var target = event.target.parentNode;\n\t\n\t  var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;\n\t  var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;\n\t\n\t  target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';\n\t\n\t  target.setAttribute('data-x', x);\n\t  target.setAttribute('data-y', y);\n\t}\n\texports.default = {\n\t  data: function data() {\n\t    return {\n\t      hasFocus: false,\n\t      isMax: false,\n\t      isDeleted: false\n\t    };\n\t  },\n\t\n\t  methods: {\n\t    bringToFront: function bringToFront(e) {\n\t      this.$dispatch('bringToFront', e.currentTarget);\n\t      this.$dispatch('loseFocus');\n\t      this.$set('hasFocus', true);\n\t    },\n\t    closeApp: function closeApp(e) {\n\t      this.$set('isDeleted', true);\n\t      this.$dispatch('closeApp', e);\n\t    },\n\t    maxApp: function maxApp(e) {\n\t      this.$set('isMax', !this.isMax);\n\t    },\n\t    makeMe: function makeMe(e) {\n\t      var target = e.currentTarget;\n\t      if (this.isDeleted) {\n\t        target.parentNode.removeChild(target);\n\t      } else {\n\t        target.classList.remove('animated');\n\t        target.classList.remove('fadeInDown');\n\t        this.$dispatch('addMe', target);\n\t        this.$dispatch('loseFocus');\n\t        this.$set('hasFocus', true);\n\t      }\n\t    }\n\t  },\n\t  events: {\n\t    loseFocus: function loseFocus() {\n\t      this.$set('hasFocus', false);\n\t    }\n\t  },\n\t  props: {\n\t    title: {\n\t      type: String,\n\t      required: true\n\t    },\n\t    loading: {\n\t      type: Boolean\n\t    },\n\t    hasSubNav: {\n\t      type: Boolean,\n\t      default: false,\n\t      required: true\n\t    }\n\t  }\n\t};\n\n/***/ },\n\n/***/ 26:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".card-header--subnav .panel-tabs a{color:#42afe3}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/wApp.vue\"],\"names\":[],\"mappings\":\"AA0LA,mCACE,aAAe,CAChB\",\"file\":\"wApp.vue\",\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n.card-header--subnav .panel-tabs a {\\n  color: #42afe3;\\n}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 27:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".w-app[_v-ca6846e8]{position:absolute;color:#fff;top:100px;left:100px;box-shadow:0 0 5px #000;z-index:0;.card-header{cursor:move}-webkit-transition:background 1s ease-in-out;transition:background 1s ease-in-out}.card-header .card-header-icon[_v-ca6846e8]{width:24px;color:#42afe3}.card-content[_v-ca6846e8]{width:unset}.is-fullwidth[_v-ca6846e8]{-webkit-transform:translate(-100px,-44px)!important;transform:translate(-100px,-44px)!important;height:93%;.card-content{height:100%;overflow-y:auto}}.isLoading[_v-ca6846e8]{background-color:#c3c3c3}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/wApp.vue\"],\"names\":[],\"mappings\":\"AAyJE,oBACE,kBAAmB,AACpB,WAAY,AACX,UAAW,AACX,WAAY,AACZ,wBAA8B,AAC9B,UAAW,AACX,aACE,WAAa,CACd,AACD,6CAA8C,AAC9C,oCAAsC,CACvC,AACD,4CACE,WAAY,AACZ,aAAe,CAChB,AACD,2BACE,WAAa,CACd,AACD,2BACE,oDAAuD,AAC/C,4CAA+C,AACvD,WAAY,AACZ,cACE,YAAa,AACb,eAAiB,CAClB,CACF,AACD,wBACE,wBAA0B,CAC3B\",\"file\":\"wApp.vue\",\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  .w-app[_v-ca6846e8] {\\n    position: absolute;\\n\\t  color: #FFF;\\n    top: 100px;\\n    left: 100px;\\n    box-shadow: 0px 0px 5px black;\\n    z-index: 0;\\n    .card-header {\\n      cursor: move;\\n    }\\n    -webkit-transition: 1s background ease-in-out;\\n    transition: 1s background ease-in-out;\\n  }\\n  .card-header .card-header-icon[_v-ca6846e8] {\\n    width: 24px;\\n    color: #42afe3;\\n  }\\n  .card-content[_v-ca6846e8] {\\n    width: unset;\\n  }\\n  .is-fullwidth[_v-ca6846e8] {\\n    -webkit-transform: translate(-100px, -44px) !important;\\n            transform: translate(-100px, -44px) !important;\\n    height: 93%;\\n    .card-content {\\n      height: 100%;\\n      overflow-y: auto;\\n    }\\n  }\\n  .isLoading[_v-ca6846e8] {\\n    background-color: #c3c3c3;\\n  }\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 28:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(26);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(14)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 29:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(27);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(14)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 30:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * interact.js v1.2.6\n\t *\n\t * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n\t * Open source under the MIT License.\n\t * https://raw.github.com/taye/interact.js/master/LICENSE\n\t */\n\t(function (realWindow) {\n\t    'use strict';\n\t\n\t    // return early if there's no window to work with (eg. Node.js)\n\t    if (!realWindow) { return; }\n\t\n\t    var // get wrapped window if using Shadow DOM polyfill\n\t        window = (function () {\n\t            // create a TextNode\n\t            var el = realWindow.document.createTextNode('');\n\t\n\t            // check if it's wrapped by a polyfill\n\t            if (el.ownerDocument !== realWindow.document\n\t                && typeof realWindow.wrap === 'function'\n\t                && realWindow.wrap(el) === el) {\n\t                // return wrapped window\n\t                return realWindow.wrap(realWindow);\n\t            }\n\t\n\t            // no Shadow DOM polyfil or native implementation\n\t            return realWindow;\n\t        }()),\n\t\n\t        document           = window.document,\n\t        DocumentFragment   = window.DocumentFragment   || blank,\n\t        SVGElement         = window.SVGElement         || blank,\n\t        SVGSVGElement      = window.SVGSVGElement      || blank,\n\t        SVGElementInstance = window.SVGElementInstance || blank,\n\t        HTMLElement        = window.HTMLElement        || window.Element,\n\t\n\t        PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n\t        pEventTypes,\n\t\n\t        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\t\n\t        tmpXY = {},     // reduce object creation in getXY()\n\t\n\t        documents       = [],   // all documents being listened to\n\t\n\t        interactables   = [],   // all set interactables\n\t        interactions    = [],   // all interactions\n\t\n\t        dynamicDrop     = false,\n\t\n\t        // {\n\t        //      type: {\n\t        //          selectors: ['selector', ...],\n\t        //          contexts : [document, ...],\n\t        //          listeners: [[listener, useCapture], ...]\n\t        //      }\n\t        //  }\n\t        delegatedEvents = {},\n\t\n\t        defaultOptions = {\n\t            base: {\n\t                accept        : null,\n\t                actionChecker : null,\n\t                styleCursor   : true,\n\t                preventDefault: 'auto',\n\t                origin        : { x: 0, y: 0 },\n\t                deltaSource   : 'page',\n\t                allowFrom     : null,\n\t                ignoreFrom    : null,\n\t                _context      : document,\n\t                dropChecker   : null\n\t            },\n\t\n\t            drag: {\n\t                enabled: false,\n\t                manualStart: true,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: null,\n\t                restrict: null,\n\t                inertia: null,\n\t                autoScroll: null,\n\t\n\t                axis: 'xy'\n\t            },\n\t\n\t            drop: {\n\t                enabled: false,\n\t                accept: null,\n\t                overlap: 'pointer'\n\t            },\n\t\n\t            resize: {\n\t                enabled: false,\n\t                manualStart: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: null,\n\t                restrict: null,\n\t                inertia: null,\n\t                autoScroll: null,\n\t\n\t                square: false,\n\t                preserveAspectRatio: false,\n\t                axis: 'xy',\n\t\n\t                // use default margin\n\t                margin: NaN,\n\t\n\t                // object with props left, right, top, bottom which are\n\t                // true/false values to resize when the pointer is over that edge,\n\t                // CSS selectors to match the handles for each direction\n\t                // or the Elements for each handle\n\t                edges: null,\n\t\n\t                // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t                // 'negate' will alow the rect to have negative width/height\n\t                // 'reposition' will keep the width/height positive by swapping\n\t                // the top and bottom edges and/or swapping the left and right edges\n\t                invert: 'none'\n\t            },\n\t\n\t            gesture: {\n\t                manualStart: false,\n\t                enabled: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                restrict: null\n\t            },\n\t\n\t            perAction: {\n\t                manualStart: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: {\n\t                    enabled     : false,\n\t                    endOnly     : false,\n\t                    range       : Infinity,\n\t                    targets     : null,\n\t                    offsets     : null,\n\t\n\t                    relativePoints: null\n\t                },\n\t\n\t                restrict: {\n\t                    enabled: false,\n\t                    endOnly: false\n\t                },\n\t\n\t                autoScroll: {\n\t                    enabled     : false,\n\t                    container   : null,     // the item that is scrolled (Window or HTMLElement)\n\t                    margin      : 60,\n\t                    speed       : 300       // the scroll speed in pixels per second\n\t                },\n\t\n\t                inertia: {\n\t                    enabled          : false,\n\t                    resistance       : 10,    // the lambda in exponential decay\n\t                    minSpeed         : 100,   // target speed must be above this for inertia to start\n\t                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n\t                    allowResume      : true,  // allow resuming an action in inertia phase\n\t                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n\t                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n\t                }\n\t            },\n\t\n\t            _holdDuration: 600\n\t        },\n\t\n\t        // Things related to autoScroll\n\t        autoScroll = {\n\t            interaction: null,\n\t            i: null,    // the handle returned by window.setInterval\n\t            x: 0, y: 0, // Direction each pulse is to scroll in\n\t\n\t            // scroll the window by the values in scroll.x/y\n\t            scroll: function () {\n\t                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n\t                    container = options.container || getWindow(autoScroll.interaction.element),\n\t                    now = new Date().getTime(),\n\t                    // change in time in seconds\n\t                    dtx = (now - autoScroll.prevTimeX) / 1000,\n\t                    dty = (now - autoScroll.prevTimeY) / 1000,\n\t                    vx, vy, sx, sy;\n\t\n\t                // displacement\n\t                if (options.velocity) {\n\t                  vx = options.velocity.x;\n\t                  vy = options.velocity.y;\n\t                }\n\t                else {\n\t                  vx = vy = options.speed\n\t                }\n\t \n\t                sx = vx * dtx;\n\t                sy = vy * dty;\n\t\n\t                if (sx >= 1 || sy >= 1) {\n\t                    if (isWindow(container)) {\n\t                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n\t                    }\n\t                    else if (container) {\n\t                        container.scrollLeft += autoScroll.x * sx;\n\t                        container.scrollTop  += autoScroll.y * sy;\n\t                    }\n\t\n\t                    if (sx >=1) autoScroll.prevTimeX = now;\n\t                    if (sy >= 1) autoScroll.prevTimeY = now;\n\t                }\n\t\n\t                if (autoScroll.isScrolling) {\n\t                    cancelFrame(autoScroll.i);\n\t                    autoScroll.i = reqFrame(autoScroll.scroll);\n\t                }\n\t            },\n\t\n\t            isScrolling: false,\n\t            prevTimeX: 0,\n\t            prevTimeY: 0,\n\t\n\t            start: function (interaction) {\n\t                autoScroll.isScrolling = true;\n\t                cancelFrame(autoScroll.i);\n\t\n\t                autoScroll.interaction = interaction;\n\t                autoScroll.prevTimeX = new Date().getTime();\n\t                autoScroll.prevTimeY = new Date().getTime();\n\t                autoScroll.i = reqFrame(autoScroll.scroll);\n\t            },\n\t\n\t            stop: function () {\n\t                autoScroll.isScrolling = false;\n\t                cancelFrame(autoScroll.i);\n\t            }\n\t        },\n\t\n\t        // Does the browser support touch input?\n\t        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\t\n\t        // Does the browser support PointerEvents\n\t        supportsPointerEvent = !!PointerEvent,\n\t\n\t        // Less Precision with touch input\n\t        margin = supportsTouch || supportsPointerEvent? 20: 10,\n\t\n\t        pointerMoveTolerance = 1,\n\t\n\t        // for ignoring browser's simulated mouse events\n\t        prevTouchTime = 0,\n\t\n\t        // Allow this many interactions to happen simultaneously\n\t        maxInteractions = Infinity,\n\t\n\t        // Check if is IE9 or older\n\t        actionCursors = (document.all && !window.atob) ? {\n\t            drag    : 'move',\n\t            resizex : 'e-resize',\n\t            resizey : 's-resize',\n\t            resizexy: 'se-resize',\n\t\n\t            resizetop        : 'n-resize',\n\t            resizeleft       : 'w-resize',\n\t            resizebottom     : 's-resize',\n\t            resizeright      : 'e-resize',\n\t            resizetopleft    : 'se-resize',\n\t            resizebottomright: 'se-resize',\n\t            resizetopright   : 'ne-resize',\n\t            resizebottomleft : 'ne-resize',\n\t\n\t            gesture : ''\n\t        } : {\n\t            drag    : 'move',\n\t            resizex : 'ew-resize',\n\t            resizey : 'ns-resize',\n\t            resizexy: 'nwse-resize',\n\t\n\t            resizetop        : 'ns-resize',\n\t            resizeleft       : 'ew-resize',\n\t            resizebottom     : 'ns-resize',\n\t            resizeright      : 'ew-resize',\n\t            resizetopleft    : 'nwse-resize',\n\t            resizebottomright: 'nwse-resize',\n\t            resizetopright   : 'nesw-resize',\n\t            resizebottomleft : 'nesw-resize',\n\t\n\t            gesture : ''\n\t        },\n\t\n\t        actionIsEnabled = {\n\t            drag   : true,\n\t            resize : true,\n\t            gesture: true\n\t        },\n\t\n\t        // because Webkit and Opera still use 'mousewheel' event type\n\t        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\t\n\t        eventTypes = [\n\t            'dragstart',\n\t            'dragmove',\n\t            'draginertiastart',\n\t            'dragend',\n\t            'dragenter',\n\t            'dragleave',\n\t            'dropactivate',\n\t            'dropdeactivate',\n\t            'dropmove',\n\t            'drop',\n\t            'resizestart',\n\t            'resizemove',\n\t            'resizeinertiastart',\n\t            'resizeend',\n\t            'gesturestart',\n\t            'gesturemove',\n\t            'gestureinertiastart',\n\t            'gestureend',\n\t\n\t            'down',\n\t            'move',\n\t            'up',\n\t            'cancel',\n\t            'tap',\n\t            'doubletap',\n\t            'hold'\n\t        ],\n\t\n\t        globalEvents = {},\n\t\n\t        // Opera Mobile must be handled differently\n\t        isOperaMobile = navigator.appName == 'Opera' &&\n\t            supportsTouch &&\n\t            navigator.userAgent.match('Presto'),\n\t\n\t        // scrolling doesn't change the result of getClientRects on iOS 7\n\t        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n\t                         && /OS 7[^\\d]/.test(navigator.appVersion)),\n\t\n\t        // prefix matchesSelector\n\t        prefixedMatchesSelector = 'matches' in Element.prototype?\n\t                'matches': 'webkitMatchesSelector' in Element.prototype?\n\t                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n\t                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n\t                            'oMatchesSelector': 'msMatchesSelector',\n\t\n\t        // will be polyfill function if browser is IE8\n\t        ie8MatchesSelector,\n\t\n\t        // native requestAnimationFrame or polyfill\n\t        reqFrame = realWindow.requestAnimationFrame,\n\t        cancelFrame = realWindow.cancelAnimationFrame,\n\t\n\t        // Events wrapper\n\t        events = (function () {\n\t            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n\t                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n\t                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n\t                on             = useAttachEvent? 'on': '',\n\t\n\t                elements          = [],\n\t                targets           = [],\n\t                attachedListeners = [];\n\t\n\t            function add (element, type, listener, useCapture) {\n\t                var elementIndex = indexOf(elements, element),\n\t                    target = targets[elementIndex];\n\t\n\t                if (!target) {\n\t                    target = {\n\t                        events: {},\n\t                        typeCount: 0\n\t                    };\n\t\n\t                    elementIndex = elements.push(element) - 1;\n\t                    targets.push(target);\n\t\n\t                    attachedListeners.push((useAttachEvent ? {\n\t                            supplied: [],\n\t                            wrapped : [],\n\t                            useCount: []\n\t                        } : null));\n\t                }\n\t\n\t                if (!target.events[type]) {\n\t                    target.events[type] = [];\n\t                    target.typeCount++;\n\t                }\n\t\n\t                if (!contains(target.events[type], listener)) {\n\t                    var ret;\n\t\n\t                    if (useAttachEvent) {\n\t                        var listeners = attachedListeners[elementIndex],\n\t                            listenerIndex = indexOf(listeners.supplied, listener);\n\t\n\t                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n\t                            if (!event.immediatePropagationStopped) {\n\t                                event.target = event.srcElement;\n\t                                event.currentTarget = element;\n\t\n\t                                event.preventDefault = event.preventDefault || preventDef;\n\t                                event.stopPropagation = event.stopPropagation || stopProp;\n\t                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\t\n\t                                if (/mouse|click/.test(event.type)) {\n\t                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n\t                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n\t                                }\n\t\n\t                                listener(event);\n\t                            }\n\t                        };\n\t\n\t                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\t\n\t                        if (listenerIndex === -1) {\n\t                            listeners.supplied.push(listener);\n\t                            listeners.wrapped.push(wrapped);\n\t                            listeners.useCount.push(1);\n\t                        }\n\t                        else {\n\t                            listeners.useCount[listenerIndex]++;\n\t                        }\n\t                    }\n\t                    else {\n\t                        ret = element[addEvent](type, listener, useCapture || false);\n\t                    }\n\t                    target.events[type].push(listener);\n\t\n\t                    return ret;\n\t                }\n\t            }\n\t\n\t            function remove (element, type, listener, useCapture) {\n\t                var i,\n\t                    elementIndex = indexOf(elements, element),\n\t                    target = targets[elementIndex],\n\t                    listeners,\n\t                    listenerIndex,\n\t                    wrapped = listener;\n\t\n\t                if (!target || !target.events) {\n\t                    return;\n\t                }\n\t\n\t                if (useAttachEvent) {\n\t                    listeners = attachedListeners[elementIndex];\n\t                    listenerIndex = indexOf(listeners.supplied, listener);\n\t                    wrapped = listeners.wrapped[listenerIndex];\n\t                }\n\t\n\t                if (type === 'all') {\n\t                    for (type in target.events) {\n\t                        if (target.events.hasOwnProperty(type)) {\n\t                            remove(element, type, 'all');\n\t                        }\n\t                    }\n\t                    return;\n\t                }\n\t\n\t                if (target.events[type]) {\n\t                    var len = target.events[type].length;\n\t\n\t                    if (listener === 'all') {\n\t                        for (i = 0; i < len; i++) {\n\t                            remove(element, type, target.events[type][i], Boolean(useCapture));\n\t                        }\n\t                        return;\n\t                    } else {\n\t                        for (i = 0; i < len; i++) {\n\t                            if (target.events[type][i] === listener) {\n\t                                element[removeEvent](on + type, wrapped, useCapture || false);\n\t                                target.events[type].splice(i, 1);\n\t\n\t                                if (useAttachEvent && listeners) {\n\t                                    listeners.useCount[listenerIndex]--;\n\t                                    if (listeners.useCount[listenerIndex] === 0) {\n\t                                        listeners.supplied.splice(listenerIndex, 1);\n\t                                        listeners.wrapped.splice(listenerIndex, 1);\n\t                                        listeners.useCount.splice(listenerIndex, 1);\n\t                                    }\n\t                                }\n\t\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    if (target.events[type] && target.events[type].length === 0) {\n\t                        target.events[type] = null;\n\t                        target.typeCount--;\n\t                    }\n\t                }\n\t\n\t                if (!target.typeCount) {\n\t                    targets.splice(elementIndex, 1);\n\t                    elements.splice(elementIndex, 1);\n\t                    attachedListeners.splice(elementIndex, 1);\n\t                }\n\t            }\n\t\n\t            function preventDef () {\n\t                this.returnValue = false;\n\t            }\n\t\n\t            function stopProp () {\n\t                this.cancelBubble = true;\n\t            }\n\t\n\t            function stopImmProp () {\n\t                this.cancelBubble = true;\n\t                this.immediatePropagationStopped = true;\n\t            }\n\t\n\t            return {\n\t                add: add,\n\t                remove: remove,\n\t                useAttachEvent: useAttachEvent,\n\t\n\t                _elements: elements,\n\t                _targets: targets,\n\t                _attachedListeners: attachedListeners\n\t            };\n\t        }());\n\t\n\t    function blank () {}\n\t\n\t    function isElement (o) {\n\t        if (!o || (typeof o !== 'object')) { return false; }\n\t\n\t        var _window = getWindow(o) || window;\n\t\n\t        return (/object|function/.test(typeof _window.Element)\n\t            ? o instanceof _window.Element //DOM2\n\t            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n\t    }\n\t    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n\t    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n\t    function isArray (thing) {\n\t        return isObject(thing)\n\t                && (typeof thing.length !== undefined)\n\t                && isFunction(thing.splice);\n\t    }\n\t    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n\t    function isFunction (thing) { return typeof thing === 'function'; }\n\t    function isNumber   (thing) { return typeof thing === 'number'  ; }\n\t    function isBool     (thing) { return typeof thing === 'boolean' ; }\n\t    function isString   (thing) { return typeof thing === 'string'  ; }\n\t\n\t    function trySelector (value) {\n\t        if (!isString(value)) { return false; }\n\t\n\t        // an exception will be raised if it is invalid\n\t        document.querySelector(value);\n\t        return true;\n\t    }\n\t\n\t    function extend (dest, source) {\n\t        for (var prop in source) {\n\t            dest[prop] = source[prop];\n\t        }\n\t        return dest;\n\t    }\n\t\n\t    var prefixedPropREs = {\n\t      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n\t    };\n\t\n\t    function pointerExtend (dest, source) {\n\t        for (var prop in source) {\n\t          var deprecated = false;\n\t\n\t          // skip deprecated prefixed properties\n\t          for (var vendor in prefixedPropREs) {\n\t            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n\t              deprecated = true;\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (!deprecated) {\n\t            dest[prop] = source[prop];\n\t          }\n\t        }\n\t        return dest;\n\t    }\n\t\n\t    function copyCoords (dest, src) {\n\t        dest.page = dest.page || {};\n\t        dest.page.x = src.page.x;\n\t        dest.page.y = src.page.y;\n\t\n\t        dest.client = dest.client || {};\n\t        dest.client.x = src.client.x;\n\t        dest.client.y = src.client.y;\n\t\n\t        dest.timeStamp = src.timeStamp;\n\t    }\n\t\n\t    function setEventXY (targetObj, pointers, interaction) {\n\t        var pointer = (pointers.length > 1\n\t                       ? pointerAverage(pointers)\n\t                       : pointers[0]);\n\t\n\t        getPageXY(pointer, tmpXY, interaction);\n\t        targetObj.page.x = tmpXY.x;\n\t        targetObj.page.y = tmpXY.y;\n\t\n\t        getClientXY(pointer, tmpXY, interaction);\n\t        targetObj.client.x = tmpXY.x;\n\t        targetObj.client.y = tmpXY.y;\n\t\n\t        targetObj.timeStamp = new Date().getTime();\n\t    }\n\t\n\t    function setEventDeltas (targetObj, prev, cur) {\n\t        targetObj.page.x     = cur.page.x      - prev.page.x;\n\t        targetObj.page.y     = cur.page.y      - prev.page.y;\n\t        targetObj.client.x   = cur.client.x    - prev.client.x;\n\t        targetObj.client.y   = cur.client.y    - prev.client.y;\n\t        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\t\n\t        // set pointer velocity\n\t        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\t        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n\t        targetObj.page.vx      = targetObj.page.x / dt;\n\t        targetObj.page.vy      = targetObj.page.y / dt;\n\t\n\t        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n\t        targetObj.client.vx    = targetObj.client.x / dt;\n\t        targetObj.client.vy    = targetObj.client.y / dt;\n\t    }\n\t\n\t    function isNativePointer (pointer) {\n\t        return (pointer instanceof window.Event\n\t            || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n\t    }\n\t\n\t    // Get specified X/Y coords for mouse or event.touches[0]\n\t    function getXY (type, pointer, xy) {\n\t        xy = xy || {};\n\t        type = type || 'page';\n\t\n\t        xy.x = pointer[type + 'X'];\n\t        xy.y = pointer[type + 'Y'];\n\t\n\t        return xy;\n\t    }\n\t\n\t    function getPageXY (pointer, page) {\n\t        page = page || {};\n\t\n\t        // Opera Mobile handles the viewport and scrolling oddly\n\t        if (isOperaMobile && isNativePointer(pointer)) {\n\t            getXY('screen', pointer, page);\n\t\n\t            page.x += window.scrollX;\n\t            page.y += window.scrollY;\n\t        }\n\t        else {\n\t            getXY('page', pointer, page);\n\t        }\n\t\n\t        return page;\n\t    }\n\t\n\t    function getClientXY (pointer, client) {\n\t        client = client || {};\n\t\n\t        if (isOperaMobile && isNativePointer(pointer)) {\n\t            // Opera Mobile handles the viewport and scrolling oddly\n\t            getXY('screen', pointer, client);\n\t        }\n\t        else {\n\t          getXY('client', pointer, client);\n\t        }\n\t\n\t        return client;\n\t    }\n\t\n\t    function getScrollXY (win) {\n\t        win = win || window;\n\t        return {\n\t            x: win.scrollX || win.document.documentElement.scrollLeft,\n\t            y: win.scrollY || win.document.documentElement.scrollTop\n\t        };\n\t    }\n\t\n\t    function getPointerId (pointer) {\n\t        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n\t    }\n\t\n\t    function getActualElement (element) {\n\t        return (element instanceof SVGElementInstance\n\t            ? element.correspondingUseElement\n\t            : element);\n\t    }\n\t\n\t    function getWindow (node) {\n\t        if (isWindow(node)) {\n\t            return node;\n\t        }\n\t\n\t        var rootNode = (node.ownerDocument || node);\n\t\n\t        return rootNode.defaultView || rootNode.parentWindow || window;\n\t    }\n\t\n\t    function getElementClientRect (element) {\n\t        var clientRect = (element instanceof SVGElement\n\t                            ? element.getBoundingClientRect()\n\t                            : element.getClientRects()[0]);\n\t\n\t        return clientRect && {\n\t            left  : clientRect.left,\n\t            right : clientRect.right,\n\t            top   : clientRect.top,\n\t            bottom: clientRect.bottom,\n\t            width : clientRect.width || clientRect.right - clientRect.left,\n\t            height: clientRect.height || clientRect.bottom - clientRect.top\n\t        };\n\t    }\n\t\n\t    function getElementRect (element) {\n\t        var clientRect = getElementClientRect(element);\n\t\n\t        if (!isIOS7 && clientRect) {\n\t            var scroll = getScrollXY(getWindow(element));\n\t\n\t            clientRect.left   += scroll.x;\n\t            clientRect.right  += scroll.x;\n\t            clientRect.top    += scroll.y;\n\t            clientRect.bottom += scroll.y;\n\t        }\n\t\n\t        return clientRect;\n\t    }\n\t\n\t    function getTouchPair (event) {\n\t        var touches = [];\n\t\n\t        // array of touches is supplied\n\t        if (isArray(event)) {\n\t            touches[0] = event[0];\n\t            touches[1] = event[1];\n\t        }\n\t        // an event\n\t        else {\n\t            if (event.type === 'touchend') {\n\t                if (event.touches.length === 1) {\n\t                    touches[0] = event.touches[0];\n\t                    touches[1] = event.changedTouches[0];\n\t                }\n\t                else if (event.touches.length === 0) {\n\t                    touches[0] = event.changedTouches[0];\n\t                    touches[1] = event.changedTouches[1];\n\t                }\n\t            }\n\t            else {\n\t                touches[0] = event.touches[0];\n\t                touches[1] = event.touches[1];\n\t            }\n\t        }\n\t\n\t        return touches;\n\t    }\n\t\n\t    function pointerAverage (pointers) {\n\t        var average = {\n\t            pageX  : 0,\n\t            pageY  : 0,\n\t            clientX: 0,\n\t            clientY: 0,\n\t            screenX: 0,\n\t            screenY: 0\n\t        };\n\t        var prop;\n\t\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            for (prop in average) {\n\t                average[prop] += pointers[i][prop];\n\t            }\n\t        }\n\t        for (prop in average) {\n\t            average[prop] /= pointers.length;\n\t        }\n\t\n\t        return average;\n\t    }\n\t\n\t    function touchBBox (event) {\n\t        if (!event.length && !(event.touches && event.touches.length > 1)) {\n\t            return;\n\t        }\n\t\n\t        var touches = getTouchPair(event),\n\t            minX = Math.min(touches[0].pageX, touches[1].pageX),\n\t            minY = Math.min(touches[0].pageY, touches[1].pageY),\n\t            maxX = Math.max(touches[0].pageX, touches[1].pageX),\n\t            maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\t\n\t        return {\n\t            x: minX,\n\t            y: minY,\n\t            left: minX,\n\t            top: minY,\n\t            width: maxX - minX,\n\t            height: maxY - minY\n\t        };\n\t    }\n\t\n\t    function touchDistance (event, deltaSource) {\n\t        deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t        var sourceX = deltaSource + 'X',\n\t            sourceY = deltaSource + 'Y',\n\t            touches = getTouchPair(event);\n\t\n\t\n\t        var dx = touches[0][sourceX] - touches[1][sourceX],\n\t            dy = touches[0][sourceY] - touches[1][sourceY];\n\t\n\t        return hypot(dx, dy);\n\t    }\n\t\n\t    function touchAngle (event, prevAngle, deltaSource) {\n\t        deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t        var sourceX = deltaSource + 'X',\n\t            sourceY = deltaSource + 'Y',\n\t            touches = getTouchPair(event),\n\t            dx = touches[0][sourceX] - touches[1][sourceX],\n\t            dy = touches[0][sourceY] - touches[1][sourceY],\n\t            angle = 180 * Math.atan(dy / dx) / Math.PI;\n\t\n\t        if (isNumber(prevAngle)) {\n\t            var dr = angle - prevAngle,\n\t                drClamped = dr % 360;\n\t\n\t            if (drClamped > 315) {\n\t                angle -= 360 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped > 135) {\n\t                angle -= 180 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped < -315) {\n\t                angle += 360 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped < -135) {\n\t                angle += 180 + (angle / 360)|0 * 360;\n\t            }\n\t        }\n\t\n\t        return  angle;\n\t    }\n\t\n\t    function getOriginXY (interactable, element) {\n\t        var origin = interactable\n\t                ? interactable.options.origin\n\t                : defaultOptions.origin;\n\t\n\t        if (origin === 'parent') {\n\t            origin = parentElement(element);\n\t        }\n\t        else if (origin === 'self') {\n\t            origin = interactable.getRect(element);\n\t        }\n\t        else if (trySelector(origin)) {\n\t            origin = closest(element, origin) || { x: 0, y: 0 };\n\t        }\n\t\n\t        if (isFunction(origin)) {\n\t            origin = origin(interactable && element);\n\t        }\n\t\n\t        if (isElement(origin))  {\n\t            origin = getElementRect(origin);\n\t        }\n\t\n\t        origin.x = ('x' in origin)? origin.x : origin.left;\n\t        origin.y = ('y' in origin)? origin.y : origin.top;\n\t\n\t        return origin;\n\t    }\n\t\n\t    // http://stackoverflow.com/a/5634528/2280888\n\t    function _getQBezierValue(t, p1, p2, p3) {\n\t        var iT = 1 - t;\n\t        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n\t    }\n\t\n\t    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n\t        return {\n\t            x:  _getQBezierValue(position, startX, cpX, endX),\n\t            y:  _getQBezierValue(position, startY, cpY, endY)\n\t        };\n\t    }\n\t\n\t    // http://gizma.com/easing/\n\t    function easeOutQuad (t, b, c, d) {\n\t        t /= d;\n\t        return -c * t*(t-2) + b;\n\t    }\n\t\n\t    function nodeContains (parent, child) {\n\t        while (child) {\n\t            if (child === parent) {\n\t                return true;\n\t            }\n\t\n\t            child = child.parentNode;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function closest (child, selector) {\n\t        var parent = parentElement(child);\n\t\n\t        while (isElement(parent)) {\n\t            if (matchesSelector(parent, selector)) { return parent; }\n\t\n\t            parent = parentElement(parent);\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    function parentElement (node) {\n\t        var parent = node.parentNode;\n\t\n\t        if (isDocFrag(parent)) {\n\t            // skip past #shado-root fragments\n\t            while ((parent = parent.host) && isDocFrag(parent)) {}\n\t\n\t            return parent;\n\t        }\n\t\n\t        return parent;\n\t    }\n\t\n\t    function inContext (interactable, element) {\n\t        return interactable._context === element.ownerDocument\n\t                || nodeContains(interactable._context, element);\n\t    }\n\t\n\t    function testIgnore (interactable, interactableElement, element) {\n\t        var ignoreFrom = interactable.options.ignoreFrom;\n\t\n\t        if (!ignoreFrom || !isElement(element)) { return false; }\n\t\n\t        if (isString(ignoreFrom)) {\n\t            return matchesUpTo(element, ignoreFrom, interactableElement);\n\t        }\n\t        else if (isElement(ignoreFrom)) {\n\t            return nodeContains(ignoreFrom, element);\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function testAllow (interactable, interactableElement, element) {\n\t        var allowFrom = interactable.options.allowFrom;\n\t\n\t        if (!allowFrom) { return true; }\n\t\n\t        if (!isElement(element)) { return false; }\n\t\n\t        if (isString(allowFrom)) {\n\t            return matchesUpTo(element, allowFrom, interactableElement);\n\t        }\n\t        else if (isElement(allowFrom)) {\n\t            return nodeContains(allowFrom, element);\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function checkAxis (axis, interactable) {\n\t        if (!interactable) { return false; }\n\t\n\t        var thisAxis = interactable.options.drag.axis;\n\t\n\t        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n\t    }\n\t\n\t    function checkSnap (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return options[action].snap && options[action].snap.enabled;\n\t    }\n\t\n\t    function checkRestrict (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return  options[action].restrict && options[action].restrict.enabled;\n\t    }\n\t\n\t    function checkAutoScroll (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return  options[action].autoScroll && options[action].autoScroll.enabled;\n\t    }\n\t\n\t    function withinInteractionLimit (interactable, element, action) {\n\t        var options = interactable.options,\n\t            maxActions = options[action.name].max,\n\t            maxPerElement = options[action.name].maxPerElement,\n\t            activeInteractions = 0,\n\t            targetCount = 0,\n\t            targetElementCount = 0;\n\t\n\t        for (var i = 0, len = interactions.length; i < len; i++) {\n\t            var interaction = interactions[i],\n\t                otherAction = interaction.prepared.name,\n\t                active = interaction.interacting();\n\t\n\t            if (!active) { continue; }\n\t\n\t            activeInteractions++;\n\t\n\t            if (activeInteractions >= maxInteractions) {\n\t                return false;\n\t            }\n\t\n\t            if (interaction.target !== interactable) { continue; }\n\t\n\t            targetCount += (otherAction === action.name)|0;\n\t\n\t            if (targetCount >= maxActions) {\n\t                return false;\n\t            }\n\t\n\t            if (interaction.element === element) {\n\t                targetElementCount++;\n\t\n\t                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        return maxInteractions > 0;\n\t    }\n\t\n\t    // Test for the element that's \"above\" all other qualifiers\n\t    function indexOfDeepestElement (elements) {\n\t        var dropzone,\n\t            deepestZone = elements[0],\n\t            index = deepestZone? 0: -1,\n\t            parent,\n\t            deepestZoneParents = [],\n\t            dropzoneParents = [],\n\t            child,\n\t            i,\n\t            n;\n\t\n\t        for (i = 1; i < elements.length; i++) {\n\t            dropzone = elements[i];\n\t\n\t            // an element might belong to multiple selector dropzones\n\t            if (!dropzone || dropzone === deepestZone) {\n\t                continue;\n\t            }\n\t\n\t            if (!deepestZone) {\n\t                deepestZone = dropzone;\n\t                index = i;\n\t                continue;\n\t            }\n\t\n\t            // check if the deepest or current are document.documentElement or document.rootElement\n\t            // - if the current dropzone is, do nothing and continue\n\t            if (dropzone.parentNode === dropzone.ownerDocument) {\n\t                continue;\n\t            }\n\t            // - if deepest is, update with the current dropzone and continue to next\n\t            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n\t                deepestZone = dropzone;\n\t                index = i;\n\t                continue;\n\t            }\n\t\n\t            if (!deepestZoneParents.length) {\n\t                parent = deepestZone;\n\t                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n\t                    deepestZoneParents.unshift(parent);\n\t                    parent = parent.parentNode;\n\t                }\n\t            }\n\t\n\t            // if this element is an svg element and the current deepest is\n\t            // an HTMLElement\n\t            if (deepestZone instanceof HTMLElement\n\t                && dropzone instanceof SVGElement\n\t                && !(dropzone instanceof SVGSVGElement)) {\n\t\n\t                if (dropzone === deepestZone.parentNode) {\n\t                    continue;\n\t                }\n\t\n\t                parent = dropzone.ownerSVGElement;\n\t            }\n\t            else {\n\t                parent = dropzone;\n\t            }\n\t\n\t            dropzoneParents = [];\n\t\n\t            while (parent.parentNode !== parent.ownerDocument) {\n\t                dropzoneParents.unshift(parent);\n\t                parent = parent.parentNode;\n\t            }\n\t\n\t            n = 0;\n\t\n\t            // get (position of last common ancestor) + 1\n\t            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n\t                n++;\n\t            }\n\t\n\t            var parents = [\n\t                dropzoneParents[n - 1],\n\t                dropzoneParents[n],\n\t                deepestZoneParents[n]\n\t            ];\n\t\n\t            child = parents[0].lastChild;\n\t\n\t            while (child) {\n\t                if (child === parents[1]) {\n\t                    deepestZone = dropzone;\n\t                    index = i;\n\t                    deepestZoneParents = [];\n\t\n\t                    break;\n\t                }\n\t                else if (child === parents[2]) {\n\t                    break;\n\t                }\n\t\n\t                child = child.previousSibling;\n\t            }\n\t        }\n\t\n\t        return index;\n\t    }\n\t\n\t    function Interaction () {\n\t        this.target          = null; // current interactable being interacted with\n\t        this.element         = null; // the target element of the interactable\n\t        this.dropTarget      = null; // the dropzone a drag target might be dropped into\n\t        this.dropElement     = null; // the element at the time of checking\n\t        this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n\t        this.prevDropElement = null; // the element at the time of checking\n\t\n\t        this.prepared        = {     // action that's ready to be fired on next move event\n\t            name : null,\n\t            axis : null,\n\t            edges: null\n\t        };\n\t\n\t        this.matches         = [];   // all selectors that are matched by target element\n\t        this.matchElements   = [];   // corresponding elements\n\t\n\t        this.inertiaStatus = {\n\t            active       : false,\n\t            smoothEnd    : false,\n\t            ending       : false,\n\t\n\t            startEvent: null,\n\t            upCoords: {},\n\t\n\t            xe: 0, ye: 0,\n\t            sx: 0, sy: 0,\n\t\n\t            t0: 0,\n\t            vx0: 0, vys: 0,\n\t            duration: 0,\n\t\n\t            resumeDx: 0,\n\t            resumeDy: 0,\n\t\n\t            lambda_v0: 0,\n\t            one_ve_v0: 0,\n\t            i  : null\n\t        };\n\t\n\t        if (isFunction(Function.prototype.bind)) {\n\t            this.boundInertiaFrame = this.inertiaFrame.bind(this);\n\t            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n\t        }\n\t        else {\n\t            var that = this;\n\t\n\t            this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n\t            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n\t        }\n\t\n\t        this.activeDrops = {\n\t            dropzones: [],      // the dropzones that are mentioned below\n\t            elements : [],      // elements of dropzones that accept the target draggable\n\t            rects    : []       // the rects of the elements mentioned above\n\t        };\n\t\n\t        // keep track of added pointers\n\t        this.pointers    = [];\n\t        this.pointerIds  = [];\n\t        this.downTargets = [];\n\t        this.downTimes   = [];\n\t        this.holdTimers  = [];\n\t\n\t        // Previous native pointer move event coordinates\n\t        this.prevCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t        // current native pointer move event coordinates\n\t        this.curCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        // Starting InteractEvent pointer coordinates\n\t        this.startCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        // Change in coordinates and time of the pointer\n\t        this.pointerDelta = {\n\t            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n\t        this.downPointer = {};\n\t\n\t        this._eventTarget    = null;\n\t        this._curEventTarget = null;\n\t\n\t        this.prevEvent = null;      // previous action event\n\t        this.tapTime   = 0;         // time of the most recent tap event\n\t        this.prevTap   = null;\n\t\n\t        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n\t        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n\t        this.snapOffsets    = [];\n\t\n\t        this.gesture = {\n\t            start: { x: 0, y: 0 },\n\t\n\t            startDistance: 0,   // distance between two touches of touchStart\n\t            prevDistance : 0,\n\t            distance     : 0,\n\t\n\t            scale: 1,           // gesture.distance / gesture.startDistance\n\t\n\t            startAngle: 0,      // angle of line joining two touches\n\t            prevAngle : 0       // angle of the previous gesture event\n\t        };\n\t\n\t        this.snapStatus = {\n\t            x       : 0, y       : 0,\n\t            dx      : 0, dy      : 0,\n\t            realX   : 0, realY   : 0,\n\t            snappedX: 0, snappedY: 0,\n\t            targets : [],\n\t            locked  : false,\n\t            changed : false\n\t        };\n\t\n\t        this.restrictStatus = {\n\t            dx         : 0, dy         : 0,\n\t            restrictedX: 0, restrictedY: 0,\n\t            snap       : null,\n\t            restricted : false,\n\t            changed    : false\n\t        };\n\t\n\t        this.restrictStatus.snap = this.snapStatus;\n\t\n\t        this.pointerIsDown   = false;\n\t        this.pointerWasMoved = false;\n\t        this.gesturing       = false;\n\t        this.dragging        = false;\n\t        this.resizing        = false;\n\t        this.resizeAxes      = 'xy';\n\t\n\t        this.mouse = false;\n\t\n\t        interactions.push(this);\n\t    }\n\t\n\t    Interaction.prototype = {\n\t        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n\t        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n\t        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\t\n\t        pointerOver: function (pointer, event, eventTarget) {\n\t            if (this.prepared.name || !this.mouse) { return; }\n\t\n\t            var curMatches = [],\n\t                curMatchElements = [],\n\t                prevTargetElement = this.element;\n\t\n\t            this.addPointer(pointer);\n\t\n\t            if (this.target\n\t                && (testIgnore(this.target, this.element, eventTarget)\n\t                    || !testAllow(this.target, this.element, eventTarget))) {\n\t                // if the eventTarget should be ignored or shouldn't be allowed\n\t                // clear the previous target\n\t                this.target = null;\n\t                this.element = null;\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t            }\n\t\n\t            var elementInteractable = interactables.get(eventTarget),\n\t                elementAction = (elementInteractable\n\t                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)\n\t                                 && testAllow(elementInteractable, eventTarget, eventTarget)\n\t                                 && validateAction(\n\t                                     elementInteractable.getAction(pointer, event, this, eventTarget),\n\t                                     elementInteractable));\n\t\n\t            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n\t                 elementAction = null;\n\t            }\n\t\n\t            function pushCurMatches (interactable, selector) {\n\t                if (interactable\n\t                    && inContext(interactable, eventTarget)\n\t                    && !testIgnore(interactable, eventTarget, eventTarget)\n\t                    && testAllow(interactable, eventTarget, eventTarget)\n\t                    && matchesSelector(eventTarget, selector)) {\n\t\n\t                    curMatches.push(interactable);\n\t                    curMatchElements.push(eventTarget);\n\t                }\n\t            }\n\t\n\t            if (elementAction) {\n\t                this.target = elementInteractable;\n\t                this.element = eventTarget;\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t            }\n\t            else {\n\t                interactables.forEachSelector(pushCurMatches);\n\t\n\t                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n\t                    this.matches = curMatches;\n\t                    this.matchElements = curMatchElements;\n\t\n\t                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t                    events.add(eventTarget,\n\t                                        PointerEvent? pEventTypes.move : 'mousemove',\n\t                                        listeners.pointerHover);\n\t                }\n\t                else if (this.target) {\n\t                    if (nodeContains(prevTargetElement, eventTarget)) {\n\t                        this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t                        events.add(this.element,\n\t                                            PointerEvent? pEventTypes.move : 'mousemove',\n\t                                            listeners.pointerHover);\n\t                    }\n\t                    else {\n\t                        this.target = null;\n\t                        this.element = null;\n\t                        this.matches = [];\n\t                        this.matchElements = [];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        // Check what action would be performed on pointerMove target if a mouse\n\t        // button were pressed and change the cursor accordingly\n\t        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n\t            var target = this.target;\n\t\n\t            if (!this.prepared.name && this.mouse) {\n\t\n\t                var action;\n\t\n\t                // update pointer coords for defaultActionChecker to use\n\t                this.setEventXY(this.curCoords, [pointer]);\n\t\n\t                if (matches) {\n\t                    action = this.validateSelector(pointer, event, matches, matchElements);\n\t                }\n\t                else if (target) {\n\t                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n\t                }\n\t\n\t                if (target && target.options.styleCursor) {\n\t                    if (action) {\n\t                        target._doc.documentElement.style.cursor = getActionCursor(action);\n\t                    }\n\t                    else {\n\t                        target._doc.documentElement.style.cursor = '';\n\t                    }\n\t                }\n\t            }\n\t            else if (this.prepared.name) {\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t        },\n\t\n\t        pointerOut: function (pointer, event, eventTarget) {\n\t            if (this.prepared.name) { return; }\n\t\n\t            // Remove temporary event listeners for selector Interactables\n\t            if (!interactables.get(eventTarget)) {\n\t                events.remove(eventTarget,\n\t                                       PointerEvent? pEventTypes.move : 'mousemove',\n\t                                       listeners.pointerHover);\n\t            }\n\t\n\t            if (this.target && this.target.options.styleCursor && !this.interacting()) {\n\t                this.target._doc.documentElement.style.cursor = '';\n\t            }\n\t        },\n\t\n\t        selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n\t            var that = this,\n\t                // copy event to be used in timeout for IE8\n\t                eventCopy = events.useAttachEvent? extend({}, event) : event,\n\t                element = eventTarget,\n\t                pointerIndex = this.addPointer(pointer),\n\t                action;\n\t\n\t            this.holdTimers[pointerIndex] = setTimeout(function () {\n\t                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n\t            }, defaultOptions._holdDuration);\n\t\n\t            this.pointerIsDown = true;\n\t\n\t            // Check if the down event hits the current inertia target\n\t            if (this.inertiaStatus.active && this.target.selector) {\n\t                // climb up the DOM tree from the event target\n\t                while (isElement(element)) {\n\t\n\t                    // if this element is the current inertia target element\n\t                    if (element === this.element\n\t                        // and the prospective action is the same as the ongoing one\n\t                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\t\n\t                        // stop inertia so that the next move will be a normal one\n\t                        cancelFrame(this.inertiaStatus.i);\n\t                        this.inertiaStatus.active = false;\n\t\n\t                        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t                        return;\n\t                    }\n\t                    element = parentElement(element);\n\t                }\n\t            }\n\t\n\t            // do nothing if interacting\n\t            if (this.interacting()) {\n\t                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t                return;\n\t            }\n\t\n\t            function pushMatches (interactable, selector, context) {\n\t                var elements = ie8MatchesSelector\n\t                    ? context.querySelectorAll(selector)\n\t                    : undefined;\n\t\n\t                if (inContext(interactable, element)\n\t                    && !testIgnore(interactable, element, eventTarget)\n\t                    && testAllow(interactable, element, eventTarget)\n\t                    && matchesSelector(element, selector, elements)) {\n\t\n\t                    that.matches.push(interactable);\n\t                    that.matchElements.push(element);\n\t                }\n\t            }\n\t\n\t            // update pointer coords for defaultActionChecker to use\n\t            this.setEventXY(this.curCoords, [pointer]);\n\t            this.downEvent = event;\n\t\n\t            while (isElement(element) && !action) {\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t\n\t                interactables.forEachSelector(pushMatches);\n\t\n\t                action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n\t                element = parentElement(element);\n\t            }\n\t\n\t            if (action) {\n\t                this.prepared.name  = action.name;\n\t                this.prepared.axis  = action.axis;\n\t                this.prepared.edges = action.edges;\n\t\n\t                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t\n\t                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n\t            }\n\t            else {\n\t                // do these now since pointerDown isn't being called from here\n\t                this.downTimes[pointerIndex] = new Date().getTime();\n\t                this.downTargets[pointerIndex] = eventTarget;\n\t                pointerExtend(this.downPointer, pointer);\n\t\n\t                copyCoords(this.prevCoords, this.curCoords);\n\t                this.pointerWasMoved = false;\n\t            }\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t        },\n\t\n\t        // Determine action to be performed on next pointerMove and add appropriate\n\t        // style and event Listeners\n\t        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n\t            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n\t                this.checkAndPreventDefault(event, this.target, this.element);\n\t\n\t                return;\n\t            }\n\t\n\t            this.pointerIsDown = true;\n\t            this.downEvent = event;\n\t\n\t            var pointerIndex = this.addPointer(pointer),\n\t                action;\n\t\n\t            // If it is the second touch of a multi-touch gesture, keep the\n\t            // target the same and get a new action if a target was set by the\n\t            // first touch\n\t            if (this.pointerIds.length > 1 && this.target._element === this.element) {\n\t                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\t\n\t                if (withinInteractionLimit(this.target, this.element, newAction)) {\n\t                    action = newAction;\n\t                }\n\t\n\t                this.prepared.name = null;\n\t            }\n\t            // Otherwise, set the target if there is no action prepared\n\t            else if (!this.prepared.name) {\n\t                var interactable = interactables.get(curEventTarget);\n\t\n\t                if (interactable\n\t                    && !testIgnore(interactable, curEventTarget, eventTarget)\n\t                    && testAllow(interactable, curEventTarget, eventTarget)\n\t                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n\t                    && withinInteractionLimit(interactable, curEventTarget, action)) {\n\t                    this.target = interactable;\n\t                    this.element = curEventTarget;\n\t                }\n\t            }\n\t\n\t            var target = this.target,\n\t                options = target && target.options;\n\t\n\t            if (target && (forceAction || !this.prepared.name)) {\n\t                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\t\n\t                this.setEventXY(this.startCoords, this.pointers);\n\t\n\t                if (!action) { return; }\n\t\n\t                if (options.styleCursor) {\n\t                    target._doc.documentElement.style.cursor = getActionCursor(action);\n\t                }\n\t\n\t                this.resizeAxes = action.name === 'resize'? action.axis : null;\n\t\n\t                if (action === 'gesture' && this.pointerIds.length < 2) {\n\t                    action = null;\n\t                }\n\t\n\t                this.prepared.name  = action.name;\n\t                this.prepared.axis  = action.axis;\n\t                this.prepared.edges = action.edges;\n\t\n\t                this.snapStatus.snappedX = this.snapStatus.snappedY =\n\t                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\t\n\t                this.downTimes[pointerIndex] = new Date().getTime();\n\t                this.downTargets[pointerIndex] = eventTarget;\n\t                pointerExtend(this.downPointer, pointer);\n\t\n\t                copyCoords(this.prevCoords, this.startCoords);\n\t                this.pointerWasMoved = false;\n\t\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t            // if inertia is active try to resume action\n\t            else if (this.inertiaStatus.active\n\t                && curEventTarget === this.element\n\t                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\t\n\t                cancelFrame(this.inertiaStatus.i);\n\t                this.inertiaStatus.active = false;\n\t\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t        },\n\t\n\t        setModifications: function (coords, preEnd) {\n\t            var target         = this.target,\n\t                shouldMove     = true,\n\t                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n\t                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\t\n\t            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n\t            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\t\n\t            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n\t                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n\t            }\n\t            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n\t                shouldMove = false;\n\t            }\n\t\n\t            return shouldMove;\n\t        },\n\t\n\t        setStartOffsets: function (action, interactable, element) {\n\t            var rect = interactable.getRect(element),\n\t                origin = getOriginXY(interactable, element),\n\t                snap = interactable.options[this.prepared.name].snap,\n\t                restrict = interactable.options[this.prepared.name].restrict,\n\t                width, height;\n\t\n\t            if (rect) {\n\t                this.startOffset.left = this.startCoords.page.x - rect.left;\n\t                this.startOffset.top  = this.startCoords.page.y - rect.top;\n\t\n\t                this.startOffset.right  = rect.right  - this.startCoords.page.x;\n\t                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\t\n\t                if ('width' in rect) { width = rect.width; }\n\t                else { width = rect.right - rect.left; }\n\t                if ('height' in rect) { height = rect.height; }\n\t                else { height = rect.bottom - rect.top; }\n\t            }\n\t            else {\n\t                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n\t            }\n\t\n\t            this.snapOffsets.splice(0);\n\t\n\t            var snapOffset = snap && snap.offset === 'startCoords'\n\t                                ? {\n\t                                    x: this.startCoords.page.x - origin.x,\n\t                                    y: this.startCoords.page.y - origin.y\n\t                                }\n\t                                : snap && snap.offset || { x: 0, y: 0 };\n\t\n\t            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n\t                for (var i = 0; i < snap.relativePoints.length; i++) {\n\t                    this.snapOffsets.push({\n\t                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n\t                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n\t                    });\n\t                }\n\t            }\n\t            else {\n\t                this.snapOffsets.push(snapOffset);\n\t            }\n\t\n\t            if (rect && restrict.elementRect) {\n\t                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n\t                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\t\n\t                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n\t                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n\t            }\n\t            else {\n\t                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n\t            }\n\t        },\n\t\n\t        /*\\\n\t         * Interaction.start\n\t         [ method ]\n\t         *\n\t         * Start an action with the given Interactable and Element as tartgets. The\n\t         * action must be enabled for the target Interactable and an appropriate number\n\t         * of pointers must be held down  1 for drag/resize, 2 for gesture.\n\t         *\n\t         * Use it with `interactable.<action>able({ manualStart: false })` to always\n\t         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n\t         *\n\t         - action       (object)  The action to be performed - drag, resize, etc.\n\t         - interactable (Interactable) The Interactable to target\n\t         - element      (Element) The DOM Element to target\n\t         = (object) interact\n\t         **\n\t         | interact(target)\n\t         |   .draggable({\n\t         |     // disable the default drag start by down->move\n\t         |     manualStart: true\n\t         |   })\n\t         |   // start dragging after the user holds the pointer down\n\t         |   .on('hold', function (event) {\n\t         |     var interaction = event.interaction;\n\t         |\n\t         |     if (!interaction.interacting()) {\n\t         |       interaction.start({ name: 'drag' },\n\t         |                         event.interactable,\n\t         |                         event.currentTarget);\n\t         |     }\n\t         | });\n\t        \\*/\n\t        start: function (action, interactable, element) {\n\t            if (this.interacting()\n\t                || !this.pointerIsDown\n\t                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n\t                return;\n\t            }\n\t\n\t            // if this interaction had been removed after stopping\n\t            // add it back\n\t            if (indexOf(interactions, this) === -1) {\n\t                interactions.push(this);\n\t            }\n\t\n\t            // set the startCoords if there was no prepared action\n\t            if (!this.prepared.name) {\n\t                this.setEventXY(this.startCoords);\n\t            }\n\t\n\t            this.prepared.name  = action.name;\n\t            this.prepared.axis  = action.axis;\n\t            this.prepared.edges = action.edges;\n\t            this.target         = interactable;\n\t            this.element        = element;\n\t\n\t            this.setStartOffsets(action.name, interactable, element);\n\t            this.setModifications(this.startCoords.page);\n\t\n\t            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n\t        },\n\t\n\t        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n\t            if (this.inertiaStatus.active) {\n\t                var pageUp   = this.inertiaStatus.upCoords.page;\n\t                var clientUp = this.inertiaStatus.upCoords.client;\n\t\n\t                var inertiaPosition = {\n\t                    pageX  : pageUp.x   + this.inertiaStatus.sx,\n\t                    pageY  : pageUp.y   + this.inertiaStatus.sy,\n\t                    clientX: clientUp.x + this.inertiaStatus.sx,\n\t                    clientY: clientUp.y + this.inertiaStatus.sy\n\t                };\n\t\n\t                this.setEventXY(this.curCoords, [inertiaPosition]);\n\t            }\n\t            else {\n\t                this.recordPointer(pointer);\n\t                this.setEventXY(this.curCoords, this.pointers);\n\t            }\n\t\n\t            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n\t                                 && this.curCoords.page.y === this.prevCoords.page.y\n\t                                 && this.curCoords.client.x === this.prevCoords.client.x\n\t                                 && this.curCoords.client.y === this.prevCoords.client.y);\n\t\n\t            var dx, dy,\n\t                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            // register movement greater than pointerMoveTolerance\n\t            if (this.pointerIsDown && !this.pointerWasMoved) {\n\t                dx = this.curCoords.client.x - this.startCoords.client.x;\n\t                dy = this.curCoords.client.y - this.startCoords.client.y;\n\t\n\t                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n\t            }\n\t\n\t            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n\t                if (this.pointerIsDown) {\n\t                    clearTimeout(this.holdTimers[pointerIndex]);\n\t                }\n\t\n\t                this.collectEventTargets(pointer, event, eventTarget, 'move');\n\t            }\n\t\n\t            if (!this.pointerIsDown) { return; }\n\t\n\t            if (duplicateMove && this.pointerWasMoved && !preEnd) {\n\t                this.checkAndPreventDefault(event, this.target, this.element);\n\t                return;\n\t            }\n\t\n\t            // set pointer coordinate, time changes and speeds\n\t            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t            if (!this.prepared.name) { return; }\n\t\n\t            if (this.pointerWasMoved\n\t                // ignore movement while inertia is active\n\t                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\t\n\t                // if just starting an action, calculate the pointer speed now\n\t                if (!this.interacting()) {\n\t                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t                    // check if a drag is in the correct axis\n\t                    if (this.prepared.name === 'drag') {\n\t                        var absX = Math.abs(dx),\n\t                            absY = Math.abs(dy),\n\t                            targetAxis = this.target.options.drag.axis,\n\t                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\t\n\t                        // if the movement isn't in the axis of the interactable\n\t                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n\t                            // cancel the prepared action\n\t                            this.prepared.name = null;\n\t\n\t                            // then try to get a drag from another ineractable\n\t\n\t                            var element = eventTarget;\n\t\n\t                            // check element interactables\n\t                            while (isElement(element)) {\n\t                                var elementInteractable = interactables.get(element);\n\t\n\t                                if (elementInteractable\n\t                                    && elementInteractable !== this.target\n\t                                    && !elementInteractable.options.drag.manualStart\n\t                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n\t                                    && checkAxis(axis, elementInteractable)) {\n\t\n\t                                    this.prepared.name = 'drag';\n\t                                    this.target = elementInteractable;\n\t                                    this.element = element;\n\t                                    break;\n\t                                }\n\t\n\t                                element = parentElement(element);\n\t                            }\n\t\n\t                            // if there's no drag from element interactables,\n\t                            // check the selector interactables\n\t                            if (!this.prepared.name) {\n\t                                var thisInteraction = this;\n\t\n\t                                var getDraggable = function (interactable, selector, context) {\n\t                                    var elements = ie8MatchesSelector\n\t                                        ? context.querySelectorAll(selector)\n\t                                        : undefined;\n\t\n\t                                    if (interactable === thisInteraction.target) { return; }\n\t\n\t                                    if (inContext(interactable, eventTarget)\n\t                                        && !interactable.options.drag.manualStart\n\t                                        && !testIgnore(interactable, element, eventTarget)\n\t                                        && testAllow(interactable, element, eventTarget)\n\t                                        && matchesSelector(element, selector, elements)\n\t                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n\t                                        && checkAxis(axis, interactable)\n\t                                        && withinInteractionLimit(interactable, element, 'drag')) {\n\t\n\t                                        return interactable;\n\t                                    }\n\t                                };\n\t\n\t                                element = eventTarget;\n\t\n\t                                while (isElement(element)) {\n\t                                    var selectorInteractable = interactables.forEachSelector(getDraggable);\n\t\n\t                                    if (selectorInteractable) {\n\t                                        this.prepared.name = 'drag';\n\t                                        this.target = selectorInteractable;\n\t                                        this.element = element;\n\t                                        break;\n\t                                    }\n\t\n\t                                    element = parentElement(element);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var starting = !!this.prepared.name && !this.interacting();\n\t\n\t                if (starting\n\t                    && (this.target.options[this.prepared.name].manualStart\n\t                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n\t                    this.stop(event);\n\t                    return;\n\t                }\n\t\n\t                if (this.prepared.name && this.target) {\n\t                    if (starting) {\n\t                        this.start(this.prepared, this.target, this.element);\n\t                    }\n\t\n\t                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\t\n\t                    // move if snapping or restriction doesn't prevent it\n\t                    if (shouldMove || starting) {\n\t                        this.prevEvent = this[this.prepared.name + 'Move'](event);\n\t                    }\n\t\n\t                    this.checkAndPreventDefault(event, this.target, this.element);\n\t                }\n\t            }\n\t\n\t            copyCoords(this.prevCoords, this.curCoords);\n\t\n\t            if (this.dragging || this.resizing) {\n\t                this.autoScrollMove(pointer);\n\t            }\n\t        },\n\t\n\t        dragStart: function (event) {\n\t            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\t\n\t            this.dragging = true;\n\t            this.target.fire(dragEvent);\n\t\n\t            // reset active dropzones\n\t            this.activeDrops.dropzones = [];\n\t            this.activeDrops.elements  = [];\n\t            this.activeDrops.rects     = [];\n\t\n\t            if (!this.dynamicDrop) {\n\t                this.setActiveDrops(this.element);\n\t            }\n\t\n\t            var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t            if (dropEvents.activate) {\n\t                this.fireActiveDrops(dropEvents.activate);\n\t            }\n\t\n\t            return dragEvent;\n\t        },\n\t\n\t        dragMove: function (event) {\n\t            var target = this.target,\n\t                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n\t                draggableElement = this.element,\n\t                drop = this.getDrop(dragEvent, event, draggableElement);\n\t\n\t            this.dropTarget = drop.dropzone;\n\t            this.dropElement = drop.element;\n\t\n\t            var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t            target.fire(dragEvent);\n\t\n\t            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n\t            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n\t            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\t\n\t            this.prevDropTarget  = this.dropTarget;\n\t            this.prevDropElement = this.dropElement;\n\t\n\t            return dragEvent;\n\t        },\n\t\n\t        resizeStart: function (event) {\n\t            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\t\n\t            if (this.prepared.edges) {\n\t                var startRect = this.target.getRect(this.element);\n\t\n\t                /*\n\t                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n\t                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n\t                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n\t                 * on the active edges and the edge being interacted with.\n\t                 */\n\t                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n\t                    var linkedEdges = extend({}, this.prepared.edges);\n\t\n\t                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n\t                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n\t                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n\t                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\t\n\t                    this.prepared._linkedEdges = linkedEdges;\n\t                }\n\t                else {\n\t                    this.prepared._linkedEdges = null;\n\t                }\n\t\n\t                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n\t                if (this.target.options.resize.preserveAspectRatio) {\n\t                    this.resizeStartAspectRatio = startRect.width / startRect.height;\n\t                }\n\t\n\t                this.resizeRects = {\n\t                    start     : startRect,\n\t                    current   : extend({}, startRect),\n\t                    restricted: extend({}, startRect),\n\t                    previous  : extend({}, startRect),\n\t                    delta     : {\n\t                        left: 0, right : 0, width : 0,\n\t                        top : 0, bottom: 0, height: 0\n\t                    }\n\t                };\n\t\n\t                resizeEvent.rect = this.resizeRects.restricted;\n\t                resizeEvent.deltaRect = this.resizeRects.delta;\n\t            }\n\t\n\t            this.target.fire(resizeEvent);\n\t\n\t            this.resizing = true;\n\t\n\t            return resizeEvent;\n\t        },\n\t\n\t        resizeMove: function (event) {\n\t            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\t\n\t            var edges = this.prepared.edges,\n\t                invert = this.target.options.resize.invert,\n\t                invertible = invert === 'reposition' || invert === 'negate';\n\t\n\t            if (edges) {\n\t                var dx = resizeEvent.dx,\n\t                    dy = resizeEvent.dy,\n\t\n\t                    start      = this.resizeRects.start,\n\t                    current    = this.resizeRects.current,\n\t                    restricted = this.resizeRects.restricted,\n\t                    delta      = this.resizeRects.delta,\n\t                    previous   = extend(this.resizeRects.previous, restricted),\n\t\n\t                    originalEdges = edges;\n\t\n\t                // `resize.preserveAspectRatio` takes precedence over `resize.square`\n\t                if (this.target.options.resize.preserveAspectRatio) {\n\t                    var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\t\n\t                    edges = this.prepared._linkedEdges;\n\t\n\t                    if ((originalEdges.left && originalEdges.bottom)\n\t                        || (originalEdges.right && originalEdges.top)) {\n\t                        dy = -dx / resizeStartAspectRatio;\n\t                    }\n\t                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n\t                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n\t                }\n\t                else if (this.target.options.resize.square) {\n\t                    edges = this.prepared._linkedEdges;\n\t\n\t                    if ((originalEdges.left && originalEdges.bottom)\n\t                        || (originalEdges.right && originalEdges.top)) {\n\t                        dy = -dx;\n\t                    }\n\t                    else if (originalEdges.left || originalEdges.right) { dy = dx; }\n\t                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n\t                }\n\t\n\t                // update the 'current' rect without modifications\n\t                if (edges.top   ) { current.top    += dy; }\n\t                if (edges.bottom) { current.bottom += dy; }\n\t                if (edges.left  ) { current.left   += dx; }\n\t                if (edges.right ) { current.right  += dx; }\n\t\n\t                if (invertible) {\n\t                    // if invertible, copy the current rect\n\t                    extend(restricted, current);\n\t\n\t                    if (invert === 'reposition') {\n\t                        // swap edge values if necessary to keep width/height positive\n\t                        var swap;\n\t\n\t                        if (restricted.top > restricted.bottom) {\n\t                            swap = restricted.top;\n\t\n\t                            restricted.top = restricted.bottom;\n\t                            restricted.bottom = swap;\n\t                        }\n\t                        if (restricted.left > restricted.right) {\n\t                            swap = restricted.left;\n\t\n\t                            restricted.left = restricted.right;\n\t                            restricted.right = swap;\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    // if not invertible, restrict to minimum of 0x0 rect\n\t                    restricted.top    = Math.min(current.top, start.bottom);\n\t                    restricted.bottom = Math.max(current.bottom, start.top);\n\t                    restricted.left   = Math.min(current.left, start.right);\n\t                    restricted.right  = Math.max(current.right, start.left);\n\t                }\n\t\n\t                restricted.width  = restricted.right  - restricted.left;\n\t                restricted.height = restricted.bottom - restricted.top ;\n\t\n\t                for (var edge in restricted) {\n\t                    delta[edge] = restricted[edge] - previous[edge];\n\t                }\n\t\n\t                resizeEvent.edges = this.prepared.edges;\n\t                resizeEvent.rect = restricted;\n\t                resizeEvent.deltaRect = delta;\n\t            }\n\t\n\t            this.target.fire(resizeEvent);\n\t\n\t            return resizeEvent;\n\t        },\n\t\n\t        gestureStart: function (event) {\n\t            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\t\n\t            gestureEvent.ds = 0;\n\t\n\t            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n\t            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n\t            this.gesture.scale = 1;\n\t\n\t            this.gesturing = true;\n\t\n\t            this.target.fire(gestureEvent);\n\t\n\t            return gestureEvent;\n\t        },\n\t\n\t        gestureMove: function (event) {\n\t            if (!this.pointerIds.length) {\n\t                return this.prevEvent;\n\t            }\n\t\n\t            var gestureEvent;\n\t\n\t            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n\t            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\t\n\t            this.target.fire(gestureEvent);\n\t\n\t            this.gesture.prevAngle = gestureEvent.angle;\n\t            this.gesture.prevDistance = gestureEvent.distance;\n\t\n\t            if (gestureEvent.scale !== Infinity &&\n\t                gestureEvent.scale !== null &&\n\t                gestureEvent.scale !== undefined  &&\n\t                !isNaN(gestureEvent.scale)) {\n\t\n\t                this.gesture.scale = gestureEvent.scale;\n\t            }\n\t\n\t            return gestureEvent;\n\t        },\n\t\n\t        pointerHold: function (pointer, event, eventTarget) {\n\t            this.collectEventTargets(pointer, event, eventTarget, 'hold');\n\t        },\n\t\n\t        pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'up' );\n\t            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t\n\t            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t            this.removePointer(pointer);\n\t        },\n\t\n\t        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n\t            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t            this.removePointer(pointer);\n\t        },\n\t\n\t        // http://www.quirksmode.org/dom/events/click.html\n\t        // >Events leading to dblclick\n\t        //\n\t        // IE8 doesn't fire down event before dblclick.\n\t        // This workaround tries to fire a tap and doubletap after dblclick\n\t        ie8Dblclick: function (pointer, event, eventTarget) {\n\t            if (this.prevTap\n\t                && event.clientX === this.prevTap.clientX\n\t                && event.clientY === this.prevTap.clientY\n\t                && eventTarget   === this.prevTap.target) {\n\t\n\t                this.downTargets[0] = eventTarget;\n\t                this.downTimes[0] = new Date().getTime();\n\t                this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t            }\n\t        },\n\t\n\t        // End interact move events and stop auto-scroll unless inertia is enabled\n\t        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n\t            var endEvent,\n\t                target = this.target,\n\t                options = target && target.options,\n\t                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n\t                inertiaStatus = this.inertiaStatus;\n\t\n\t            if (this.interacting()) {\n\t\n\t                if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\t\n\t                var pointerSpeed,\n\t                    now = new Date().getTime(),\n\t                    inertiaPossible = false,\n\t                    inertia = false,\n\t                    smoothEnd = false,\n\t                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n\t                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n\t                    dx = 0,\n\t                    dy = 0,\n\t                    startEvent;\n\t\n\t                if (this.dragging) {\n\t                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n\t                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n\t                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n\t                }\n\t                else {\n\t                    pointerSpeed = this.pointerDelta.client.speed;\n\t                }\n\t\n\t                // check if inertia should be started\n\t                inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n\t                                   && this.prepared.name !== 'gesture'\n\t                                   && event !== inertiaStatus.startEvent);\n\t\n\t                inertia = (inertiaPossible\n\t                           && (now - this.curCoords.timeStamp) < 50\n\t                           && pointerSpeed > inertiaOptions.minSpeed\n\t                           && pointerSpeed > inertiaOptions.endSpeed);\n\t\n\t                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\t\n\t                    var snapRestrict = {};\n\t\n\t                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\t\n\t                    if (endSnap) {\n\t                        this.setSnapping(this.curCoords.page, snapRestrict);\n\t                        if (snapRestrict.locked) {\n\t                            dx += snapRestrict.dx;\n\t                            dy += snapRestrict.dy;\n\t                        }\n\t                    }\n\t\n\t                    if (endRestrict) {\n\t                        this.setRestriction(this.curCoords.page, snapRestrict);\n\t                        if (snapRestrict.restricted) {\n\t                            dx += snapRestrict.dx;\n\t                            dy += snapRestrict.dy;\n\t                        }\n\t                    }\n\t\n\t                    if (dx || dy) {\n\t                        smoothEnd = true;\n\t                    }\n\t                }\n\t\n\t                if (inertia || smoothEnd) {\n\t                    copyCoords(inertiaStatus.upCoords, this.curCoords);\n\t\n\t                    this.pointers[0] = inertiaStatus.startEvent = startEvent =\n\t                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\t\n\t                    inertiaStatus.t0 = now;\n\t\n\t                    target.fire(inertiaStatus.startEvent);\n\t\n\t                    if (inertia) {\n\t                        inertiaStatus.vx0 = this.pointerDelta.client.vx;\n\t                        inertiaStatus.vy0 = this.pointerDelta.client.vy;\n\t                        inertiaStatus.v0 = pointerSpeed;\n\t\n\t                        this.calcInertia(inertiaStatus);\n\t\n\t                        var page = extend({}, this.curCoords.page),\n\t                            origin = getOriginXY(target, this.element),\n\t                            statusObject;\n\t\n\t                        page.x = page.x + inertiaStatus.xe - origin.x;\n\t                        page.y = page.y + inertiaStatus.ye - origin.y;\n\t\n\t                        statusObject = {\n\t                            useStatusXY: true,\n\t                            x: page.x,\n\t                            y: page.y,\n\t                            dx: 0,\n\t                            dy: 0,\n\t                            snap: null\n\t                        };\n\t\n\t                        statusObject.snap = statusObject;\n\t\n\t                        dx = dy = 0;\n\t\n\t                        if (endSnap) {\n\t                            var snap = this.setSnapping(this.curCoords.page, statusObject);\n\t\n\t                            if (snap.locked) {\n\t                                dx += snap.dx;\n\t                                dy += snap.dy;\n\t                            }\n\t                        }\n\t\n\t                        if (endRestrict) {\n\t                            var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\t\n\t                            if (restrict.restricted) {\n\t                                dx += restrict.dx;\n\t                                dy += restrict.dy;\n\t                            }\n\t                        }\n\t\n\t                        inertiaStatus.modifiedXe += dx;\n\t                        inertiaStatus.modifiedYe += dy;\n\t\n\t                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t                    }\n\t                    else {\n\t                        inertiaStatus.smoothEnd = true;\n\t                        inertiaStatus.xe = dx;\n\t                        inertiaStatus.ye = dy;\n\t\n\t                        inertiaStatus.sx = inertiaStatus.sy = 0;\n\t\n\t                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t                    }\n\t\n\t                    inertiaStatus.active = true;\n\t                    return;\n\t                }\n\t\n\t                if (endSnap || endRestrict) {\n\t                    // fire a move event at the snapped coordinates\n\t                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n\t                }\n\t            }\n\t\n\t            if (this.dragging) {\n\t                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\t\n\t                var draggableElement = this.element,\n\t                    drop = this.getDrop(endEvent, event, draggableElement);\n\t\n\t                this.dropTarget = drop.dropzone;\n\t                this.dropElement = drop.element;\n\t\n\t                var dropEvents = this.getDropEvents(event, endEvent);\n\t\n\t                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n\t                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n\t                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n\t                if (dropEvents.deactivate) {\n\t                    this.fireActiveDrops(dropEvents.deactivate);\n\t                }\n\t\n\t                target.fire(endEvent);\n\t            }\n\t            else if (this.resizing) {\n\t                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n\t                target.fire(endEvent);\n\t            }\n\t            else if (this.gesturing) {\n\t                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n\t                target.fire(endEvent);\n\t            }\n\t\n\t            this.stop(event);\n\t        },\n\t\n\t        collectDrops: function (element) {\n\t            var drops = [],\n\t                elements = [],\n\t                i;\n\t\n\t            element = element || this.element;\n\t\n\t            // collect all dropzones and their elements which qualify for a drop\n\t            for (i = 0; i < interactables.length; i++) {\n\t                if (!interactables[i].options.drop.enabled) { continue; }\n\t\n\t                var current = interactables[i],\n\t                    accept = current.options.drop.accept;\n\t\n\t                // test the draggable element against the dropzone's accept setting\n\t                if ((isElement(accept) && accept !== element)\n\t                    || (isString(accept)\n\t                        && !matchesSelector(element, accept))) {\n\t\n\t                    continue;\n\t                }\n\t\n\t                // query for new elements if necessary\n\t                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\t\n\t                for (var j = 0, len = dropElements.length; j < len; j++) {\n\t                    var currentElement = dropElements[j];\n\t\n\t                    if (currentElement === element) {\n\t                        continue;\n\t                    }\n\t\n\t                    drops.push(current);\n\t                    elements.push(currentElement);\n\t                }\n\t            }\n\t\n\t            return {\n\t                dropzones: drops,\n\t                elements: elements\n\t            };\n\t        },\n\t\n\t        fireActiveDrops: function (event) {\n\t            var i,\n\t                current,\n\t                currentElement,\n\t                prevElement;\n\t\n\t            // loop through all active dropzones and trigger event\n\t            for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t                current = this.activeDrops.dropzones[i];\n\t                currentElement = this.activeDrops.elements [i];\n\t\n\t                // prevent trigger of duplicate events on same element\n\t                if (currentElement !== prevElement) {\n\t                    // set current element as event target\n\t                    event.target = currentElement;\n\t                    current.fire(event);\n\t                }\n\t                prevElement = currentElement;\n\t            }\n\t        },\n\t\n\t        // Collect a new set of possible drops and save them in activeDrops.\n\t        // setActiveDrops should always be called when a drag has just started or a\n\t        // drag event happens while dynamicDrop is true\n\t        setActiveDrops: function (dragElement) {\n\t            // get dropzones and their elements that could receive the draggable\n\t            var possibleDrops = this.collectDrops(dragElement, true);\n\t\n\t            this.activeDrops.dropzones = possibleDrops.dropzones;\n\t            this.activeDrops.elements  = possibleDrops.elements;\n\t            this.activeDrops.rects     = [];\n\t\n\t            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n\t            }\n\t        },\n\t\n\t        getDrop: function (dragEvent, event, dragElement) {\n\t            var validDrops = [];\n\t\n\t            if (dynamicDrop) {\n\t                this.setActiveDrops(dragElement);\n\t            }\n\t\n\t            // collect all dropzones and their elements which qualify for a drop\n\t            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n\t                var current        = this.activeDrops.dropzones[j],\n\t                    currentElement = this.activeDrops.elements [j],\n\t                    rect           = this.activeDrops.rects    [j];\n\t\n\t                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n\t                                ? currentElement\n\t                                : null);\n\t            }\n\t\n\t            // get the most appropriate dropzone based on DOM depth and order\n\t            var dropIndex = indexOfDeepestElement(validDrops),\n\t                dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n\t                element   = this.activeDrops.elements [dropIndex] || null;\n\t\n\t            return {\n\t                dropzone: dropzone,\n\t                element: element\n\t            };\n\t        },\n\t\n\t        getDropEvents: function (pointerEvent, dragEvent) {\n\t            var dropEvents = {\n\t                enter     : null,\n\t                leave     : null,\n\t                activate  : null,\n\t                deactivate: null,\n\t                move      : null,\n\t                drop      : null\n\t            };\n\t\n\t            if (this.dropElement !== this.prevDropElement) {\n\t                // if there was a prevDropTarget, create a dragleave event\n\t                if (this.prevDropTarget) {\n\t                    dropEvents.leave = {\n\t                        target       : this.prevDropElement,\n\t                        dropzone     : this.prevDropTarget,\n\t                        relatedTarget: dragEvent.target,\n\t                        draggable    : dragEvent.interactable,\n\t                        dragEvent    : dragEvent,\n\t                        interaction  : this,\n\t                        timeStamp    : dragEvent.timeStamp,\n\t                        type         : 'dragleave'\n\t                    };\n\t\n\t                    dragEvent.dragLeave = this.prevDropElement;\n\t                    dragEvent.prevDropzone = this.prevDropTarget;\n\t                }\n\t                // if the dropTarget is not null, create a dragenter event\n\t                if (this.dropTarget) {\n\t                    dropEvents.enter = {\n\t                        target       : this.dropElement,\n\t                        dropzone     : this.dropTarget,\n\t                        relatedTarget: dragEvent.target,\n\t                        draggable    : dragEvent.interactable,\n\t                        dragEvent    : dragEvent,\n\t                        interaction  : this,\n\t                        timeStamp    : dragEvent.timeStamp,\n\t                        type         : 'dragenter'\n\t                    };\n\t\n\t                    dragEvent.dragEnter = this.dropElement;\n\t                    dragEvent.dropzone = this.dropTarget;\n\t                }\n\t            }\n\t\n\t            if (dragEvent.type === 'dragend' && this.dropTarget) {\n\t                dropEvents.drop = {\n\t                    target       : this.dropElement,\n\t                    dropzone     : this.dropTarget,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'drop'\n\t                };\n\t\n\t                dragEvent.dropzone = this.dropTarget;\n\t            }\n\t            if (dragEvent.type === 'dragstart') {\n\t                dropEvents.activate = {\n\t                    target       : null,\n\t                    dropzone     : null,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropactivate'\n\t                };\n\t            }\n\t            if (dragEvent.type === 'dragend') {\n\t                dropEvents.deactivate = {\n\t                    target       : null,\n\t                    dropzone     : null,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropdeactivate'\n\t                };\n\t            }\n\t            if (dragEvent.type === 'dragmove' && this.dropTarget) {\n\t                dropEvents.move = {\n\t                    target       : this.dropElement,\n\t                    dropzone     : this.dropTarget,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    dragmove     : dragEvent,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropmove'\n\t                };\n\t                dragEvent.dropzone = this.dropTarget;\n\t            }\n\t\n\t            return dropEvents;\n\t        },\n\t\n\t        currentAction: function () {\n\t            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n\t        },\n\t\n\t        interacting: function () {\n\t            return this.dragging || this.resizing || this.gesturing;\n\t        },\n\t\n\t        clearTargets: function () {\n\t            this.target = this.element = null;\n\t\n\t            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n\t        },\n\t\n\t        stop: function (event) {\n\t            if (this.interacting()) {\n\t                autoScroll.stop();\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t\n\t                var target = this.target;\n\t\n\t                if (target.options.styleCursor) {\n\t                    target._doc.documentElement.style.cursor = '';\n\t                }\n\t\n\t                // prevent Default only if were previously interacting\n\t                if (event && isFunction(event.preventDefault)) {\n\t                    this.checkAndPreventDefault(event, target, this.element);\n\t                }\n\t\n\t                if (this.dragging) {\n\t                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n\t                }\n\t            }\n\t\n\t            this.clearTargets();\n\t\n\t            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n\t            this.prepared.name = this.prevEvent = null;\n\t            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\t\n\t            // remove pointers if their ID isn't in this.pointerIds\n\t            for (var i = 0; i < this.pointers.length; i++) {\n\t                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n\t                    this.pointers.splice(i, 1);\n\t                }\n\t            }\n\t        },\n\t\n\t        inertiaFrame: function () {\n\t            var inertiaStatus = this.inertiaStatus,\n\t                options = this.target.options[this.prepared.name].inertia,\n\t                lambda = options.resistance,\n\t                t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\t\n\t            if (t < inertiaStatus.te) {\n\t\n\t                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\t\n\t                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n\t                    inertiaStatus.sx = inertiaStatus.xe * progress;\n\t                    inertiaStatus.sy = inertiaStatus.ye * progress;\n\t                }\n\t                else {\n\t                    var quadPoint = getQuadraticCurvePoint(\n\t                            0, 0,\n\t                            inertiaStatus.xe, inertiaStatus.ye,\n\t                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n\t                            progress);\n\t\n\t                    inertiaStatus.sx = quadPoint.x;\n\t                    inertiaStatus.sy = quadPoint.y;\n\t                }\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t            }\n\t            else {\n\t                inertiaStatus.ending = true;\n\t\n\t                inertiaStatus.sx = inertiaStatus.modifiedXe;\n\t                inertiaStatus.sy = inertiaStatus.modifiedYe;\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.active = inertiaStatus.ending = false;\n\t            }\n\t        },\n\t\n\t        smoothEndFrame: function () {\n\t            var inertiaStatus = this.inertiaStatus,\n\t                t = new Date().getTime() - inertiaStatus.t0,\n\t                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\t\n\t            if (t < duration) {\n\t                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n\t                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t            }\n\t            else {\n\t                inertiaStatus.ending = true;\n\t\n\t                inertiaStatus.sx = inertiaStatus.xe;\n\t                inertiaStatus.sy = inertiaStatus.ye;\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.smoothEnd =\n\t                  inertiaStatus.active = inertiaStatus.ending = false;\n\t            }\n\t        },\n\t\n\t        addPointer: function (pointer) {\n\t            var id = getPointerId(pointer),\n\t                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\t\n\t            if (index === -1) {\n\t                index = this.pointerIds.length;\n\t            }\n\t\n\t            this.pointerIds[index] = id;\n\t            this.pointers[index] = pointer;\n\t\n\t            return index;\n\t        },\n\t\n\t        removePointer: function (pointer) {\n\t            var id = getPointerId(pointer),\n\t                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\t\n\t            if (index === -1) { return; }\n\t\n\t            this.pointers   .splice(index, 1);\n\t            this.pointerIds .splice(index, 1);\n\t            this.downTargets.splice(index, 1);\n\t            this.downTimes  .splice(index, 1);\n\t            this.holdTimers .splice(index, 1);\n\t        },\n\t\n\t        recordPointer: function (pointer) {\n\t            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            if (index === -1) { return; }\n\t\n\t            this.pointers[index] = pointer;\n\t        },\n\t\n\t        collectEventTargets: function (pointer, event, eventTarget, eventType) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            // do not fire a tap event if the pointer was moved before being lifted\n\t            if (eventType === 'tap' && (this.pointerWasMoved\n\t                // or if the pointerup target is different to the pointerdown target\n\t                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n\t                return;\n\t            }\n\t\n\t            var targets = [],\n\t                elements = [],\n\t                element = eventTarget;\n\t\n\t            function collectSelectors (interactable, selector, context) {\n\t                var els = ie8MatchesSelector\n\t                        ? context.querySelectorAll(selector)\n\t                        : undefined;\n\t\n\t                if (interactable._iEvents[eventType]\n\t                    && isElement(element)\n\t                    && inContext(interactable, element)\n\t                    && !testIgnore(interactable, element, eventTarget)\n\t                    && testAllow(interactable, element, eventTarget)\n\t                    && matchesSelector(element, selector, els)) {\n\t\n\t                    targets.push(interactable);\n\t                    elements.push(element);\n\t                }\n\t            }\n\t\n\t            while (element) {\n\t                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n\t                    targets.push(interact(element));\n\t                    elements.push(element);\n\t                }\n\t\n\t                interactables.forEachSelector(collectSelectors);\n\t\n\t                element = parentElement(element);\n\t            }\n\t\n\t            // create the tap event even if there are no listeners so that\n\t            // doubletap can still be created and fired\n\t            if (targets.length || eventType === 'tap') {\n\t                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n\t            }\n\t        },\n\t\n\t        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n\t                pointerEvent = {},\n\t                i,\n\t                // for tap events\n\t                interval, createNewDoubleTap;\n\t\n\t            // if it's a doubletap then the event properties would have been\n\t            // copied from the tap event and provided as the pointer argument\n\t            if (eventType === 'doubletap') {\n\t                pointerEvent = pointer;\n\t            }\n\t            else {\n\t                pointerExtend(pointerEvent, event);\n\t                if (event !== pointer) {\n\t                    pointerExtend(pointerEvent, pointer);\n\t                }\n\t\n\t                pointerEvent.preventDefault           = preventOriginalDefault;\n\t                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n\t                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n\t                pointerEvent.interaction              = this;\n\t\n\t                pointerEvent.timeStamp       = new Date().getTime();\n\t                pointerEvent.originalEvent   = event;\n\t                pointerEvent.originalPointer = pointer;\n\t                pointerEvent.type            = eventType;\n\t                pointerEvent.pointerId       = getPointerId(pointer);\n\t                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n\t                                                    : isString(pointer.pointerType)\n\t                                                        ? pointer.pointerType\n\t                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n\t            }\n\t\n\t            if (eventType === 'tap') {\n\t                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\t\n\t                interval = pointerEvent.timeStamp - this.tapTime;\n\t                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n\t                       && this.prevTap.target === pointerEvent.target\n\t                       && interval < 500);\n\t\n\t                pointerEvent.double = createNewDoubleTap;\n\t\n\t                this.tapTime = pointerEvent.timeStamp;\n\t            }\n\t\n\t            for (i = 0; i < targets.length; i++) {\n\t                pointerEvent.currentTarget = elements[i];\n\t                pointerEvent.interactable = targets[i];\n\t                targets[i].fire(pointerEvent);\n\t\n\t                if (pointerEvent.immediatePropagationStopped\n\t                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (createNewDoubleTap) {\n\t                var doubleTap = {};\n\t\n\t                extend(doubleTap, pointerEvent);\n\t\n\t                doubleTap.dt   = interval;\n\t                doubleTap.type = 'doubletap';\n\t\n\t                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\t\n\t                this.prevTap = doubleTap;\n\t            }\n\t            else if (eventType === 'tap') {\n\t                this.prevTap = pointerEvent;\n\t            }\n\t        },\n\t\n\t        validateSelector: function (pointer, event, matches, matchElements) {\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var match = matches[i],\n\t                    matchElement = matchElements[i],\n\t                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\t\n\t                if (action && withinInteractionLimit(match, matchElement, action)) {\n\t                    this.target = match;\n\t                    this.element = matchElement;\n\t\n\t                    return action;\n\t                }\n\t            }\n\t        },\n\t\n\t        setSnapping: function (pageCoords, status) {\n\t            var snap = this.target.options[this.prepared.name].snap,\n\t                targets = [],\n\t                target,\n\t                page,\n\t                i;\n\t\n\t            status = status || this.snapStatus;\n\t\n\t            if (status.useStatusXY) {\n\t                page = { x: status.x, y: status.y };\n\t            }\n\t            else {\n\t                var origin = getOriginXY(this.target, this.element);\n\t\n\t                page = extend({}, pageCoords);\n\t\n\t                page.x -= origin.x;\n\t                page.y -= origin.y;\n\t            }\n\t\n\t            status.realX = page.x;\n\t            status.realY = page.y;\n\t\n\t            page.x = page.x - this.inertiaStatus.resumeDx;\n\t            page.y = page.y - this.inertiaStatus.resumeDy;\n\t\n\t            var len = snap.targets? snap.targets.length : 0;\n\t\n\t            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n\t                var relative = {\n\t                    x: page.x - this.snapOffsets[relIndex].x,\n\t                    y: page.y - this.snapOffsets[relIndex].y\n\t                };\n\t\n\t                for (i = 0; i < len; i++) {\n\t                    if (isFunction(snap.targets[i])) {\n\t                        target = snap.targets[i](relative.x, relative.y, this);\n\t                    }\n\t                    else {\n\t                        target = snap.targets[i];\n\t                    }\n\t\n\t                    if (!target) { continue; }\n\t\n\t                    targets.push({\n\t                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n\t                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\t\n\t                        range: isNumber(target.range)? target.range: snap.range\n\t                    });\n\t                }\n\t            }\n\t\n\t            var closest = {\n\t                    target: null,\n\t                    inRange: false,\n\t                    distance: 0,\n\t                    range: 0,\n\t                    dx: 0,\n\t                    dy: 0\n\t                };\n\t\n\t            for (i = 0, len = targets.length; i < len; i++) {\n\t                target = targets[i];\n\t\n\t                var range = target.range,\n\t                    dx = target.x - page.x,\n\t                    dy = target.y - page.y,\n\t                    distance = hypot(dx, dy),\n\t                    inRange = distance <= range;\n\t\n\t                // Infinite targets count as being out of range\n\t                // compared to non infinite ones that are in range\n\t                if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n\t                    inRange = false;\n\t                }\n\t\n\t                if (!closest.target || (inRange\n\t                    // is the closest target in range?\n\t                    ? (closest.inRange && range !== Infinity\n\t                        // the pointer is relatively deeper in this target\n\t                        ? distance / range < closest.distance / closest.range\n\t                        // this target has Infinite range and the closest doesn't\n\t                        : (range === Infinity && closest.range !== Infinity)\n\t                            // OR this target is closer that the previous closest\n\t                            || distance < closest.distance)\n\t                    // The other is not in range and the pointer is closer to this target\n\t                    : (!closest.inRange && distance < closest.distance))) {\n\t\n\t                    if (range === Infinity) {\n\t                        inRange = true;\n\t                    }\n\t\n\t                    closest.target = target;\n\t                    closest.distance = distance;\n\t                    closest.range = range;\n\t                    closest.inRange = inRange;\n\t                    closest.dx = dx;\n\t                    closest.dy = dy;\n\t\n\t                    status.range = range;\n\t                }\n\t            }\n\t\n\t            var snapChanged;\n\t\n\t            if (closest.target) {\n\t                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\t\n\t                status.snappedX = closest.target.x;\n\t                status.snappedY = closest.target.y;\n\t            }\n\t            else {\n\t                snapChanged = true;\n\t\n\t                status.snappedX = NaN;\n\t                status.snappedY = NaN;\n\t            }\n\t\n\t            status.dx = closest.dx;\n\t            status.dy = closest.dy;\n\t\n\t            status.changed = (snapChanged || (closest.inRange && !status.locked));\n\t            status.locked = closest.inRange;\n\t\n\t            return status;\n\t        },\n\t\n\t        setRestriction: function (pageCoords, status) {\n\t            var target = this.target,\n\t                restrict = target && target.options[this.prepared.name].restrict,\n\t                restriction = restrict && restrict.restriction,\n\t                page;\n\t\n\t            if (!restriction) {\n\t                return status;\n\t            }\n\t\n\t            status = status || this.restrictStatus;\n\t\n\t            page = status.useStatusXY\n\t                    ? page = { x: status.x, y: status.y }\n\t                    : page = extend({}, pageCoords);\n\t\n\t            if (status.snap && status.snap.locked) {\n\t                page.x += status.snap.dx || 0;\n\t                page.y += status.snap.dy || 0;\n\t            }\n\t\n\t            page.x -= this.inertiaStatus.resumeDx;\n\t            page.y -= this.inertiaStatus.resumeDy;\n\t\n\t            status.dx = 0;\n\t            status.dy = 0;\n\t            status.restricted = false;\n\t\n\t            var rect, restrictedX, restrictedY;\n\t\n\t            if (isString(restriction)) {\n\t                if (restriction === 'parent') {\n\t                    restriction = parentElement(this.element);\n\t                }\n\t                else if (restriction === 'self') {\n\t                    restriction = target.getRect(this.element);\n\t                }\n\t                else {\n\t                    restriction = closest(this.element, restriction);\n\t                }\n\t\n\t                if (!restriction) { return status; }\n\t            }\n\t\n\t            if (isFunction(restriction)) {\n\t                restriction = restriction(page.x, page.y, this.element);\n\t            }\n\t\n\t            if (isElement(restriction)) {\n\t                restriction = getElementRect(restriction);\n\t            }\n\t\n\t            rect = restriction;\n\t\n\t            if (!restriction) {\n\t                restrictedX = page.x;\n\t                restrictedY = page.y;\n\t            }\n\t            // object is assumed to have\n\t            // x, y, width, height or\n\t            // left, top, right, bottom\n\t            else if ('x' in restriction && 'y' in restriction) {\n\t                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n\t                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n\t            }\n\t            else {\n\t                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n\t                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n\t            }\n\t\n\t            status.dx = restrictedX - page.x;\n\t            status.dy = restrictedY - page.y;\n\t\n\t            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n\t            status.restricted = !!(status.dx || status.dy);\n\t\n\t            status.restrictedX = restrictedX;\n\t            status.restrictedY = restrictedY;\n\t\n\t            return status;\n\t        },\n\t\n\t        checkAndPreventDefault: function (event, interactable, element) {\n\t            if (!(interactable = interactable || this.target)) { return; }\n\t\n\t            var options = interactable.options,\n\t                prevent = options.preventDefault;\n\t\n\t            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n\t                // do not preventDefault on pointerdown if the prepared action is a drag\n\t                // and dragging can only start from a certain direction - this allows\n\t                // a touch to pan the viewport if a drag isn't in the right direction\n\t                if (/down|start/i.test(event.type)\n\t                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\t\n\t                    return;\n\t                }\n\t\n\t                // with manualStart, only preventDefault while interacting\n\t                if (options[this.prepared.name] && options[this.prepared.name].manualStart\n\t                    && !this.interacting()) {\n\t                    return;\n\t                }\n\t\n\t                event.preventDefault();\n\t                return;\n\t            }\n\t\n\t            if (prevent === 'always') {\n\t                event.preventDefault();\n\t                return;\n\t            }\n\t        },\n\t\n\t        calcInertia: function (status) {\n\t            var inertiaOptions = this.target.options[this.prepared.name].inertia,\n\t                lambda = inertiaOptions.resistance,\n\t                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\t\n\t            status.x0 = this.prevEvent.pageX;\n\t            status.y0 = this.prevEvent.pageY;\n\t            status.t0 = status.startEvent.timeStamp / 1000;\n\t            status.sx = status.sy = 0;\n\t\n\t            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n\t            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n\t            status.te = inertiaDur;\n\t\n\t            status.lambda_v0 = lambda / status.v0;\n\t            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n\t        },\n\t\n\t        autoScrollMove: function (pointer) {\n\t            if (!(this.interacting()\n\t                && checkAutoScroll(this.target, this.prepared.name))) {\n\t                return;\n\t            }\n\t\n\t            if (this.inertiaStatus.active) {\n\t                autoScroll.x = autoScroll.y = 0;\n\t                return;\n\t            }\n\t\n\t            var top,\n\t                right,\n\t                bottom,\n\t                left,\n\t                options = this.target.options[this.prepared.name].autoScroll,\n\t                container = options.container || getWindow(this.element);\n\t\n\t            if (isWindow(container)) {\n\t                left   = pointer.clientX < autoScroll.margin;\n\t                top    = pointer.clientY < autoScroll.margin;\n\t                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n\t                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n\t            }\n\t            else {\n\t                var rect = getElementClientRect(container);\n\t\n\t                left   = pointer.clientX < rect.left   + autoScroll.margin;\n\t                top    = pointer.clientY < rect.top    + autoScroll.margin;\n\t                right  = pointer.clientX > rect.right  - autoScroll.margin;\n\t                bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n\t            }\n\t\n\t            autoScroll.x = (right ? 1: left? -1: 0);\n\t            autoScroll.y = (bottom? 1:  top? -1: 0);\n\t\n\t            if (!autoScroll.isScrolling) {\n\t                // set the autoScroll properties to those of the target\n\t                autoScroll.margin = options.margin;\n\t                autoScroll.speed  = options.speed;\n\t\n\t                autoScroll.start(this);\n\t            }\n\t        },\n\t\n\t        _updateEventTargets: function (target, currentTarget) {\n\t            this._eventTarget    = target;\n\t            this._curEventTarget = currentTarget;\n\t        }\n\t\n\t    };\n\t\n\t    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n\t        var i = 0, len = interactions.length,\n\t            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n\t                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n\t                          || pointer.pointerType === 4),\n\t            interaction;\n\t\n\t        var id = getPointerId(pointer);\n\t\n\t        // try to resume inertia with a new pointer\n\t        if (/down|start/i.test(eventType)) {\n\t            for (i = 0; i < len; i++) {\n\t                interaction = interactions[i];\n\t\n\t                var element = eventTarget;\n\t\n\t                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n\t                    && (interaction.mouse === mouseEvent)) {\n\t                    while (element) {\n\t                        // if the element is the interaction element\n\t                        if (element === interaction.element) {\n\t                            return interaction;\n\t                        }\n\t                        element = parentElement(element);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // if it's a mouse interaction\n\t        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\t\n\t            // find a mouse interaction that's not in inertia phase\n\t            for (i = 0; i < len; i++) {\n\t                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n\t                    return interactions[i];\n\t                }\n\t            }\n\t\n\t            // find any interaction specifically for mouse.\n\t            // if the eventType is a mousedown, and inertia is active\n\t            // ignore the interaction\n\t            for (i = 0; i < len; i++) {\n\t                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n\t                    return interaction;\n\t                }\n\t            }\n\t\n\t            // create a new interaction for mouse\n\t            interaction = new Interaction();\n\t            interaction.mouse = true;\n\t\n\t            return interaction;\n\t        }\n\t\n\t        // get interaction that has this pointer\n\t        for (i = 0; i < len; i++) {\n\t            if (contains(interactions[i].pointerIds, id)) {\n\t                return interactions[i];\n\t            }\n\t        }\n\t\n\t        // at this stage, a pointerUp should not return an interaction\n\t        if (/up|end|out/i.test(eventType)) {\n\t            return null;\n\t        }\n\t\n\t        // get first idle interaction\n\t        for (i = 0; i < len; i++) {\n\t            interaction = interactions[i];\n\t\n\t            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n\t                && !interaction.interacting()\n\t                && !(!mouseEvent && interaction.mouse)) {\n\t\n\t                return interaction;\n\t            }\n\t        }\n\t\n\t        return new Interaction();\n\t    }\n\t\n\t    function doOnInteractions (method) {\n\t        return (function (event) {\n\t            var interaction,\n\t                eventTarget = getActualElement(event.path\n\t                                               ? event.path[0]\n\t                                               : event.target),\n\t                curEventTarget = getActualElement(event.currentTarget),\n\t                i;\n\t\n\t            if (supportsTouch && /touch/.test(event.type)) {\n\t                prevTouchTime = new Date().getTime();\n\t\n\t                for (i = 0; i < event.changedTouches.length; i++) {\n\t                    var pointer = event.changedTouches[i];\n\t\n\t                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\t\n\t                    if (!interaction) { continue; }\n\t\n\t                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t                    interaction[method](pointer, event, eventTarget, curEventTarget);\n\t                }\n\t            }\n\t            else {\n\t                if (!supportsPointerEvent && /mouse/.test(event.type)) {\n\t                    // ignore mouse events while touch interactions are active\n\t                    for (i = 0; i < interactions.length; i++) {\n\t                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n\t                            return;\n\t                        }\n\t                    }\n\t\n\t                    // try to ignore mouse events that are simulated by the browser\n\t                    // after a touch event\n\t                    if (new Date().getTime() - prevTouchTime < 500) {\n\t                        return;\n\t                    }\n\t                }\n\t\n\t                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\t\n\t                if (!interaction) { return; }\n\t\n\t                interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t                interaction[method](event, event, eventTarget, curEventTarget);\n\t            }\n\t        });\n\t    }\n\t\n\t    function InteractEvent (interaction, event, action, phase, element, related) {\n\t        var client,\n\t            page,\n\t            target      = interaction.target,\n\t            snapStatus  = interaction.snapStatus,\n\t            restrictStatus  = interaction.restrictStatus,\n\t            pointers    = interaction.pointers,\n\t            deltaSource = (target && target.options || defaultOptions).deltaSource,\n\t            sourceX     = deltaSource + 'X',\n\t            sourceY     = deltaSource + 'Y',\n\t            options     = target? target.options: defaultOptions,\n\t            origin      = getOriginXY(target, element),\n\t            starting    = phase === 'start',\n\t            ending      = phase === 'end',\n\t            coords      = starting? interaction.startCoords : interaction.curCoords;\n\t\n\t        element = element || interaction.element;\n\t\n\t        page   = extend({}, coords.page);\n\t        client = extend({}, coords.client);\n\t\n\t        page.x -= origin.x;\n\t        page.y -= origin.y;\n\t\n\t        client.x -= origin.x;\n\t        client.y -= origin.y;\n\t\n\t        var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\t\n\t        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n\t            this.snap = {\n\t                range  : snapStatus.range,\n\t                locked : snapStatus.locked,\n\t                x      : snapStatus.snappedX,\n\t                y      : snapStatus.snappedY,\n\t                realX  : snapStatus.realX,\n\t                realY  : snapStatus.realY,\n\t                dx     : snapStatus.dx,\n\t                dy     : snapStatus.dy\n\t            };\n\t\n\t            if (snapStatus.locked) {\n\t                page.x += snapStatus.dx;\n\t                page.y += snapStatus.dy;\n\t                client.x += snapStatus.dx;\n\t                client.y += snapStatus.dy;\n\t            }\n\t        }\n\t\n\t        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n\t            page.x += restrictStatus.dx;\n\t            page.y += restrictStatus.dy;\n\t            client.x += restrictStatus.dx;\n\t            client.y += restrictStatus.dy;\n\t\n\t            this.restrict = {\n\t                dx: restrictStatus.dx,\n\t                dy: restrictStatus.dy\n\t            };\n\t        }\n\t\n\t        this.pageX     = page.x;\n\t        this.pageY     = page.y;\n\t        this.clientX   = client.x;\n\t        this.clientY   = client.y;\n\t\n\t        this.x0        = interaction.startCoords.page.x - origin.x;\n\t        this.y0        = interaction.startCoords.page.y - origin.y;\n\t        this.clientX0  = interaction.startCoords.client.x - origin.x;\n\t        this.clientY0  = interaction.startCoords.client.y - origin.y;\n\t        this.ctrlKey   = event.ctrlKey;\n\t        this.altKey    = event.altKey;\n\t        this.shiftKey  = event.shiftKey;\n\t        this.metaKey   = event.metaKey;\n\t        this.button    = event.button;\n\t        this.buttons   = event.buttons;\n\t        this.target    = element;\n\t        this.t0        = interaction.downTimes[0];\n\t        this.type      = action + (phase || '');\n\t\n\t        this.interaction = interaction;\n\t        this.interactable = target;\n\t\n\t        var inertiaStatus = interaction.inertiaStatus;\n\t\n\t        if (inertiaStatus.active) {\n\t            this.detail = 'inertia';\n\t        }\n\t\n\t        if (related) {\n\t            this.relatedTarget = related;\n\t        }\n\t\n\t        // end event dx, dy is difference between start and end points\n\t        if (ending) {\n\t            if (deltaSource === 'client') {\n\t                this.dx = client.x - interaction.startCoords.client.x;\n\t                this.dy = client.y - interaction.startCoords.client.y;\n\t            }\n\t            else {\n\t                this.dx = page.x - interaction.startCoords.page.x;\n\t                this.dy = page.y - interaction.startCoords.page.y;\n\t            }\n\t        }\n\t        else if (starting) {\n\t            this.dx = 0;\n\t            this.dy = 0;\n\t        }\n\t        // copy properties from previousmove if starting inertia\n\t        else if (phase === 'inertiastart') {\n\t            this.dx = interaction.prevEvent.dx;\n\t            this.dy = interaction.prevEvent.dy;\n\t        }\n\t        else {\n\t            if (deltaSource === 'client') {\n\t                this.dx = client.x - interaction.prevEvent.clientX;\n\t                this.dy = client.y - interaction.prevEvent.clientY;\n\t            }\n\t            else {\n\t                this.dx = page.x - interaction.prevEvent.pageX;\n\t                this.dy = page.y - interaction.prevEvent.pageY;\n\t            }\n\t        }\n\t        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n\t            && !inertiaStatus.active\n\t            && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\t\n\t            inertiaStatus.resumeDx += this.dx;\n\t            inertiaStatus.resumeDy += this.dy;\n\t\n\t            this.dx = this.dy = 0;\n\t        }\n\t\n\t        if (action === 'resize' && interaction.resizeAxes) {\n\t            if (options.resize.square) {\n\t                if (interaction.resizeAxes === 'y') {\n\t                    this.dx = this.dy;\n\t                }\n\t                else {\n\t                    this.dy = this.dx;\n\t                }\n\t                this.axes = 'xy';\n\t            }\n\t            else {\n\t                this.axes = interaction.resizeAxes;\n\t\n\t                if (interaction.resizeAxes === 'x') {\n\t                    this.dy = 0;\n\t                }\n\t                else if (interaction.resizeAxes === 'y') {\n\t                    this.dx = 0;\n\t                }\n\t            }\n\t        }\n\t        else if (action === 'gesture') {\n\t            this.touches = [pointers[0], pointers[1]];\n\t\n\t            if (starting) {\n\t                this.distance = touchDistance(pointers, deltaSource);\n\t                this.box      = touchBBox(pointers);\n\t                this.scale    = 1;\n\t                this.ds       = 0;\n\t                this.angle    = touchAngle(pointers, undefined, deltaSource);\n\t                this.da       = 0;\n\t            }\n\t            else if (ending || event instanceof InteractEvent) {\n\t                this.distance = interaction.prevEvent.distance;\n\t                this.box      = interaction.prevEvent.box;\n\t                this.scale    = interaction.prevEvent.scale;\n\t                this.ds       = this.scale - 1;\n\t                this.angle    = interaction.prevEvent.angle;\n\t                this.da       = this.angle - interaction.gesture.startAngle;\n\t            }\n\t            else {\n\t                this.distance = touchDistance(pointers, deltaSource);\n\t                this.box      = touchBBox(pointers);\n\t                this.scale    = this.distance / interaction.gesture.startDistance;\n\t                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\t\n\t                this.ds = this.scale - interaction.gesture.prevScale;\n\t                this.da = this.angle - interaction.gesture.prevAngle;\n\t            }\n\t        }\n\t\n\t        if (starting) {\n\t            this.timeStamp = interaction.downTimes[0];\n\t            this.dt        = 0;\n\t            this.duration  = 0;\n\t            this.speed     = 0;\n\t            this.velocityX = 0;\n\t            this.velocityY = 0;\n\t        }\n\t        else if (phase === 'inertiastart') {\n\t            this.timeStamp = interaction.prevEvent.timeStamp;\n\t            this.dt        = interaction.prevEvent.dt;\n\t            this.duration  = interaction.prevEvent.duration;\n\t            this.speed     = interaction.prevEvent.speed;\n\t            this.velocityX = interaction.prevEvent.velocityX;\n\t            this.velocityY = interaction.prevEvent.velocityY;\n\t        }\n\t        else {\n\t            this.timeStamp = new Date().getTime();\n\t            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n\t            this.duration  = this.timeStamp - interaction.downTimes[0];\n\t\n\t            if (event instanceof InteractEvent) {\n\t                var dx = this[sourceX] - interaction.prevEvent[sourceX],\n\t                    dy = this[sourceY] - interaction.prevEvent[sourceY],\n\t                    dt = this.dt / 1000;\n\t\n\t                this.speed = hypot(dx, dy) / dt;\n\t                this.velocityX = dx / dt;\n\t                this.velocityY = dy / dt;\n\t            }\n\t            // if normal move or end event, use previous user event coords\n\t            else {\n\t                // speed and velocity in pixels per second\n\t                this.speed = interaction.pointerDelta[deltaSource].speed;\n\t                this.velocityX = interaction.pointerDelta[deltaSource].vx;\n\t                this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\t            }\n\t        }\n\t\n\t        if ((ending || phase === 'inertiastart')\n\t            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\t\n\t            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n\t                overlap = 22.5;\n\t\n\t            if (angle < 0) {\n\t                angle += 360;\n\t            }\n\t\n\t            var left = 135 - overlap <= angle && angle < 225 + overlap,\n\t                up   = 225 - overlap <= angle && angle < 315 + overlap,\n\t\n\t                right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n\t                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\t\n\t            this.swipe = {\n\t                up   : up,\n\t                down : down,\n\t                left : left,\n\t                right: right,\n\t                angle: angle,\n\t                speed: interaction.prevEvent.speed,\n\t                velocity: {\n\t                    x: interaction.prevEvent.velocityX,\n\t                    y: interaction.prevEvent.velocityY\n\t                }\n\t            };\n\t        }\n\t    }\n\t\n\t    InteractEvent.prototype = {\n\t        preventDefault: blank,\n\t        stopImmediatePropagation: function () {\n\t            this.immediatePropagationStopped = this.propagationStopped = true;\n\t        },\n\t        stopPropagation: function () {\n\t            this.propagationStopped = true;\n\t        }\n\t    };\n\t\n\t    function preventOriginalDefault () {\n\t        this.originalEvent.preventDefault();\n\t    }\n\t\n\t    function getActionCursor (action) {\n\t        var cursor = '';\n\t\n\t        if (action.name === 'drag') {\n\t            cursor =  actionCursors.drag;\n\t        }\n\t        if (action.name === 'resize') {\n\t            if (action.axis) {\n\t                cursor =  actionCursors[action.name + action.axis];\n\t            }\n\t            else if (action.edges) {\n\t                var cursorKey = 'resize',\n\t                    edgeNames = ['top', 'bottom', 'left', 'right'];\n\t\n\t                for (var i = 0; i < 4; i++) {\n\t                    if (action.edges[edgeNames[i]]) {\n\t                        cursorKey += edgeNames[i];\n\t                    }\n\t                }\n\t\n\t                cursor = actionCursors[cursorKey];\n\t            }\n\t        }\n\t\n\t        return cursor;\n\t    }\n\t\n\t    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n\t        // false, '', undefined, null\n\t        if (!value) { return false; }\n\t\n\t        // true value, use pointer coords and element rect\n\t        if (value === true) {\n\t            // if dimensions are negative, \"switch\" edges\n\t            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n\t                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\t\n\t            if (width < 0) {\n\t                if      (name === 'left' ) { name = 'right'; }\n\t                else if (name === 'right') { name = 'left' ; }\n\t            }\n\t            if (height < 0) {\n\t                if      (name === 'top'   ) { name = 'bottom'; }\n\t                else if (name === 'bottom') { name = 'top'   ; }\n\t            }\n\t\n\t            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n\t            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\t\n\t            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n\t            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n\t        }\n\t\n\t        // the remaining checks require an element\n\t        if (!isElement(element)) { return false; }\n\t\n\t        return isElement(value)\n\t                    // the value is an element to use as a resize handle\n\t                    ? value === element\n\t                    // otherwise check if element matches value as selector\n\t                    : matchesUpTo(element, value, interactableElement);\n\t    }\n\t\n\t    function defaultActionChecker (pointer, interaction, element) {\n\t        var rect = this.getRect(element),\n\t            shouldResize = false,\n\t            action = null,\n\t            resizeAxes = null,\n\t            resizeEdges,\n\t            page = extend({}, interaction.curCoords.page),\n\t            options = this.options;\n\t\n\t        if (!rect) { return null; }\n\t\n\t        if (actionIsEnabled.resize && options.resize.enabled) {\n\t            var resizeOptions = options.resize;\n\t\n\t            resizeEdges = {\n\t                left: false, right: false, top: false, bottom: false\n\t            };\n\t\n\t            // if using resize.edges\n\t            if (isObject(resizeOptions.edges)) {\n\t                for (var edge in resizeEdges) {\n\t                    resizeEdges[edge] = checkResizeEdge(edge,\n\t                                                        resizeOptions.edges[edge],\n\t                                                        page,\n\t                                                        interaction._eventTarget,\n\t                                                        element,\n\t                                                        rect,\n\t                                                        resizeOptions.margin || margin);\n\t                }\n\t\n\t                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n\t                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\t\n\t                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n\t            }\n\t            else {\n\t                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n\t                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\t\n\t                shouldResize = right || bottom;\n\t                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n\t            }\n\t        }\n\t\n\t        action = shouldResize\n\t            ? 'resize'\n\t            : actionIsEnabled.drag && options.drag.enabled\n\t                ? 'drag'\n\t                : null;\n\t\n\t        if (actionIsEnabled.gesture\n\t            && interaction.pointerIds.length >=2\n\t            && !(interaction.dragging || interaction.resizing)) {\n\t            action = 'gesture';\n\t        }\n\t\n\t        if (action) {\n\t            return {\n\t                name: action,\n\t                axis: resizeAxes,\n\t                edges: resizeEdges\n\t            };\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    // Check if action is enabled globally and the current target supports it\n\t    // If so, return the validated action. Otherwise, return null\n\t    function validateAction (action, interactable) {\n\t        if (!isObject(action)) { return null; }\n\t\n\t        var actionName = action.name,\n\t            options = interactable.options;\n\t\n\t        if ((  (actionName  === 'resize'   && options.resize.enabled )\n\t            || (actionName      === 'drag'     && options.drag.enabled  )\n\t            || (actionName      === 'gesture'  && options.gesture.enabled))\n\t            && actionIsEnabled[actionName]) {\n\t\n\t            if (actionName === 'resize' || actionName === 'resizeyx') {\n\t                actionName = 'resizexy';\n\t            }\n\t\n\t            return action;\n\t        }\n\t        return null;\n\t    }\n\t\n\t    var listeners = {},\n\t        interactionListeners = [\n\t            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n\t            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n\t            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n\t            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n\t        ];\n\t\n\t    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n\t        var name = interactionListeners[i];\n\t\n\t        listeners[name] = doOnInteractions(name);\n\t    }\n\t\n\t    // bound to the interactable context when a DOM event\n\t    // listener is added to a selector interactable\n\t    function delegateListener (event, useCapture) {\n\t        var fakeEvent = {},\n\t            delegated = delegatedEvents[event.type],\n\t            eventTarget = getActualElement(event.path\n\t                                           ? event.path[0]\n\t                                           : event.target),\n\t            element = eventTarget;\n\t\n\t        useCapture = useCapture? true: false;\n\t\n\t        // duplicate the event so that currentTarget can be changed\n\t        for (var prop in event) {\n\t            fakeEvent[prop] = event[prop];\n\t        }\n\t\n\t        fakeEvent.originalEvent = event;\n\t        fakeEvent.preventDefault = preventOriginalDefault;\n\t\n\t        // climb up document tree looking for selector matches\n\t        while (isElement(element)) {\n\t            for (var i = 0; i < delegated.selectors.length; i++) {\n\t                var selector = delegated.selectors[i],\n\t                    context = delegated.contexts[i];\n\t\n\t                if (matchesSelector(element, selector)\n\t                    && nodeContains(context, eventTarget)\n\t                    && nodeContains(context, element)) {\n\t\n\t                    var listeners = delegated.listeners[i];\n\t\n\t                    fakeEvent.currentTarget = element;\n\t\n\t                    for (var j = 0; j < listeners.length; j++) {\n\t                        if (listeners[j][1] === useCapture) {\n\t                            listeners[j][0](fakeEvent);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t\n\t            element = parentElement(element);\n\t        }\n\t    }\n\t\n\t    function delegateUseCapture (event) {\n\t        return delegateListener.call(this, event, true);\n\t    }\n\t\n\t    interactables.indexOfElement = function indexOfElement (element, context) {\n\t        context = context || document;\n\t\n\t        for (var i = 0; i < this.length; i++) {\n\t            var interactable = this[i];\n\t\n\t            if ((interactable.selector === element\n\t                && (interactable._context === context))\n\t                || (!interactable.selector && interactable._element === element)) {\n\t\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    interactables.get = function interactableGet (element, options) {\n\t        return this[this.indexOfElement(element, options && options.context)];\n\t    };\n\t\n\t    interactables.forEachSelector = function (callback) {\n\t        for (var i = 0; i < this.length; i++) {\n\t            var interactable = this[i];\n\t\n\t            if (!interactable.selector) {\n\t                continue;\n\t            }\n\t\n\t            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\t\n\t            if (ret !== undefined) {\n\t                return ret;\n\t            }\n\t        }\n\t    };\n\t\n\t    /*\\\n\t     * interact\n\t     [ method ]\n\t     *\n\t     * The methods of this variable can be used to set elements as\n\t     * interactables and also to change various default settings.\n\t     *\n\t     * Calling it as a function and passing an element or a valid CSS selector\n\t     * string returns an Interactable object which has various methods to\n\t     * configure it.\n\t     *\n\t     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n\t     = (object) An @Interactable\n\t     *\n\t     > Usage\n\t     | interact(document.getElementById('draggable')).draggable(true);\n\t     |\n\t     | var rectables = interact('rect');\n\t     | rectables\n\t     |     .gesturable(true)\n\t     |     .on('gesturemove', function (event) {\n\t     |         // something cool...\n\t     |     })\n\t     |     .autoScroll(true);\n\t    \\*/\n\t    function interact (element, options) {\n\t        return interactables.get(element, options) || new Interactable(element, options);\n\t    }\n\t\n\t    /*\\\n\t     * Interactable\n\t     [ property ]\n\t     **\n\t     * Object type returned by @interact\n\t    \\*/\n\t    function Interactable (element, options) {\n\t        this._element = element;\n\t        this._iEvents = this._iEvents || {};\n\t\n\t        var _window;\n\t\n\t        if (trySelector(element)) {\n\t            this.selector = element;\n\t\n\t            var context = options && options.context;\n\t\n\t            _window = context? getWindow(context) : window;\n\t\n\t            if (context && (_window.Node\n\t                    ? context instanceof _window.Node\n\t                    : (isElement(context) || context === _window.document))) {\n\t\n\t                this._context = context;\n\t            }\n\t        }\n\t        else {\n\t            _window = getWindow(element);\n\t\n\t            if (isElement(element, _window)) {\n\t\n\t                if (PointerEvent) {\n\t                    events.add(this._element, pEventTypes.down, listeners.pointerDown );\n\t                    events.add(this._element, pEventTypes.move, listeners.pointerHover);\n\t                }\n\t                else {\n\t                    events.add(this._element, 'mousedown' , listeners.pointerDown );\n\t                    events.add(this._element, 'mousemove' , listeners.pointerHover);\n\t                    events.add(this._element, 'touchstart', listeners.pointerDown );\n\t                    events.add(this._element, 'touchmove' , listeners.pointerHover);\n\t                }\n\t            }\n\t        }\n\t\n\t        this._doc = _window.document;\n\t\n\t        if (!contains(documents, this._doc)) {\n\t            listenToDocument(this._doc);\n\t        }\n\t\n\t        interactables.push(this);\n\t\n\t        this.set(options);\n\t    }\n\t\n\t    Interactable.prototype = {\n\t        setOnEvents: function (action, phases) {\n\t            if (action === 'drop') {\n\t                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n\t                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n\t                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n\t                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n\t                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n\t                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n\t            }\n\t            else {\n\t                action = 'on' + action;\n\t\n\t                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n\t                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n\t                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n\t                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.draggable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether drag actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of drag events\n\t         | var isDraggable = interact('ul li').draggable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n\t         = (object) This Interactable\n\t         | interact(element).draggable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // the axis in which the first movement must be\n\t         |     // for the drag sequence to start\n\t         |     // 'xy' by default - any direction\n\t         |     axis: 'x' || 'y' || 'xy',\n\t         |\n\t         |     // max number of drags that can happen concurrently\n\t         |     // with elements of this Interactable. Infinity by default\n\t         |     max: Infinity,\n\t         |\n\t         |     // max number of drags that can target the same element+Interactable\n\t         |     // 1 by default\n\t         |     maxPerElement: 2\n\t         | });\n\t        \\*/\n\t        draggable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.drag.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('drag', options);\n\t                this.setOnEvents('drag', options);\n\t\n\t                if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t                    this.options.drag.axis = options.axis;\n\t                }\n\t                else if (options.axis === null) {\n\t                    delete this.options.drag.axis;\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.drag.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drag;\n\t        },\n\t\n\t        setPerAction: function (action, options) {\n\t            // for all the default per-action options\n\t            for (var option in options) {\n\t                // if this option exists for this action\n\t                if (option in defaultOptions[action]) {\n\t                    // if the option in the options arg is an object value\n\t                    if (isObject(options[option])) {\n\t                        // duplicate the object\n\t                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\t\n\t                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n\t                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n\t                        }\n\t                    }\n\t                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n\t                        this.options[action][option].enabled = options[option];\n\t                    }\n\t                    else if (options[option] !== undefined) {\n\t                        // or if it's not undefined, do a plain assignment\n\t                        this.options[action][option] = options[option];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.dropzone\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether elements can be dropped onto this\n\t         * Interactable to trigger drop events\n\t         *\n\t         * Dropzones can receive the following events:\n\t         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n\t         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n\t         *  - `dragmove` when a draggable that has entered the dropzone is moved\n\t         *  - `drop` when a draggable is dropped into this dropzone\n\t         *\n\t         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n\t         *\n\t         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n\t         *   - `'pointer'`, the pointer must be over the dropzone (default)\n\t         *   - `'center'`, the draggable element's center must be over the dropzone\n\t         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n\t         *       e.g. `0.5` for drop to happen when half of the area of the\n\t         *       draggable is over the dropzone\n\t         *\n\t         - options (boolean | object | null) #optional The new value to be set.\n\t         | interact('.drop').dropzone({\n\t         |   accept: '.can-drop' || document.getElementById('single-drop'),\n\t         |   overlap: 'pointer' || 'center' || zeroToOne\n\t         | }\n\t         = (boolean | object) The current setting or this Interactable\n\t        \\*/\n\t        dropzone: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.drop.enabled = options.enabled === false? false: true;\n\t                this.setOnEvents('drop', options);\n\t\n\t                if (/^(pointer|center)$/.test(options.overlap)) {\n\t                    this.options.drop.overlap = options.overlap;\n\t                }\n\t                else if (isNumber(options.overlap)) {\n\t                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n\t                }\n\t                if ('accept' in options) {\n\t                  this.options.drop.accept = options.accept;\n\t                }\n\t                if ('checker' in options) {\n\t                  this.options.drop.checker = options.checker;\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.drop.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop;\n\t        },\n\t\n\t        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n\t            var dropped = false;\n\t\n\t            // if the dropzone has no rect (eg. display: none)\n\t            // call the custom dropChecker or just return false\n\t            if (!(rect = rect || this.getRect(dropElement))) {\n\t                return (this.options.drop.checker\n\t                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n\t                    : false);\n\t            }\n\t\n\t            var dropOverlap = this.options.drop.overlap;\n\t\n\t            if (dropOverlap === 'pointer') {\n\t                var page = getPageXY(dragEvent),\n\t                    origin = getOriginXY(draggable, draggableElement),\n\t                    horizontal,\n\t                    vertical;\n\t\n\t                page.x += origin.x;\n\t                page.y += origin.y;\n\t\n\t                horizontal = (page.x > rect.left) && (page.x < rect.right);\n\t                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\t\n\t                dropped = horizontal && vertical;\n\t            }\n\t\n\t            var dragRect = draggable.getRect(draggableElement);\n\t\n\t            if (dropOverlap === 'center') {\n\t                var cx = dragRect.left + dragRect.width  / 2,\n\t                    cy = dragRect.top  + dragRect.height / 2;\n\t\n\t                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n\t            }\n\t\n\t            if (isNumber(dropOverlap)) {\n\t                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n\t                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n\t                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\t\n\t                dropped = overlapRatio >= dropOverlap;\n\t            }\n\t\n\t            if (this.options.drop.checker) {\n\t                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n\t            }\n\t\n\t            return dropped;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.dropChecker\n\t         [ method ]\n\t         *\n\t         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n\t         *\n\t         * Gets or sets the function used to check if a dragged element is\n\t         * over this Interactable.\n\t         *\n\t         - checker (function) #optional The function that will be called when checking for a drop\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         * The checker function takes the following arguments:\n\t         *\n\t         - dragEvent (InteractEvent) The related dragmove or dragend event\n\t         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n\t         - dropped (boolean) The value from the default drop checker\n\t         - dropzone (Interactable) The dropzone interactable\n\t         - dropElement (Element) The dropzone element\n\t         - draggable (Interactable) The Interactable being dragged\n\t         - draggableElement (Element) The actual element that's being dragged\n\t         *\n\t         > Usage:\n\t         | interact(target)\n\t         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n\t         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n\t         |                       dropped,           // bool result of the default checker\n\t         |                       dropzone,          // dropzone Interactable\n\t         |                       dropElement,       // dropzone elemnt\n\t         |                       draggable,         // draggable Interactable\n\t         |                       draggableElement) {// draggable element\n\t         |\n\t         |   return dropped && event.target.hasAttribute('allow-drop');\n\t         | }\n\t        \\*/\n\t        dropChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.options.drop.checker = checker;\n\t\n\t                return this;\n\t            }\n\t            if (checker === null) {\n\t                delete this.options.getRect;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop.checker;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.accept\n\t         [ method ]\n\t         *\n\t         * Deprecated. add an `accept` property to the options object passed to\n\t         * @Interactable.dropzone instead.\n\t         *\n\t         * Gets or sets the Element or CSS selector match that this\n\t         * Interactable accepts if it is a dropzone.\n\t         *\n\t         - newValue (Element | string | null) #optional\n\t         * If it is an Element, then only that element can be dropped into this dropzone.\n\t         * If it is a string, the element being dragged must match it as a selector.\n\t         * If it is null, the accept options is cleared - it accepts any element.\n\t         *\n\t         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n\t        \\*/\n\t        accept: function (newValue) {\n\t            if (isElement(newValue)) {\n\t                this.options.drop.accept = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            // test if it is a valid CSS selector\n\t            if (trySelector(newValue)) {\n\t                this.options.drop.accept = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.drop.accept;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop.accept;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.resizable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether resize actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of resize elements\n\t         | var isResizeable = interact('input[type=text]').resizable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n\t         = (object) This Interactable\n\t         | interact(element).resizable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     edges: {\n\t         |       top   : true,       // Use pointer coords to check for resize.\n\t         |       left  : false,      // Disable resizing from left edge.\n\t         |       bottom: '.resize-s',// Resize if pointer target matches selector\n\t         |       right : handleEl    // Resize if pointer target is the given Element\n\t         |     },\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height are adjusted at a 1:1 ratio.\n\t         |     square: false,\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height maintain the aspect ratio they had when resizing started.\n\t         |     preserveAspectRatio: false,\n\t         |\n\t         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t         |     // 'negate' will allow the rect to have negative width/height\n\t         |     // 'reposition' will keep the width/height positive by swapping\n\t         |     // the top and bottom edges and/or swapping the left and right edges\n\t         |     invert: 'none' || 'negate' || 'reposition'\n\t         |\n\t         |     // limit multiple resizes.\n\t         |     // See the explanation in the @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t        resizable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.resize.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('resize', options);\n\t                this.setOnEvents('resize', options);\n\t\n\t                if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t                    this.options.resize.axis = options.axis;\n\t                }\n\t                else if (options.axis === null) {\n\t                    this.options.resize.axis = defaultOptions.resize.axis;\n\t                }\n\t\n\t                if (isBool(options.preserveAspectRatio)) {\n\t                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n\t                }\n\t                else if (isBool(options.square)) {\n\t                    this.options.resize.square = options.square;\n\t                }\n\t\n\t                return this;\n\t            }\n\t            if (isBool(options)) {\n\t                this.options.resize.enabled = options;\n\t\n\t                return this;\n\t            }\n\t            return this.options.resize;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.squareResize\n\t         [ method ]\n\t         *\n\t         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n\t         *\n\t         * Gets or sets whether resizing is forced 1:1 aspect\n\t         *\n\t         = (boolean) Current setting\n\t         *\n\t         * or\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (object) this Interactable\n\t        \\*/\n\t        squareResize: function (newValue) {\n\t            if (isBool(newValue)) {\n\t                this.options.resize.square = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.resize.square;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.resize.square;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.gesturable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether multitouch gestures can be performed on the\n\t         * Interactable's element\n\t         *\n\t         = (boolean) Indicates if this can be the target of gesture events\n\t         | var isGestureable = interact(element).gesturable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n\t         = (object) this Interactable\n\t         | interact(element).gesturable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // limit multiple gestures.\n\t         |     // See the explanation in @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t        gesturable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.gesture.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('gesture', options);\n\t                this.setOnEvents('gesture', options);\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.gesture.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.gesture;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.autoScroll\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `autoscroll` property to the options object\n\t         * passed to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets whether dragging and resizing near the edges of the\n\t         * window/container trigger autoScroll for this Interactable\n\t         *\n\t         = (object) Object with autoScroll properties\n\t         *\n\t         * or\n\t         *\n\t         - options (object | boolean) #optional\n\t         * options can be:\n\t         * - an object with margin, distance and interval properties,\n\t         * - true or false to enable or disable autoScroll or\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t        autoScroll: function (options) {\n\t            if (isObject(options)) {\n\t                options = extend({ actions: ['drag', 'resize']}, options);\n\t            }\n\t            else if (isBool(options)) {\n\t                options = { actions: ['drag', 'resize'], enabled: options };\n\t            }\n\t\n\t            return this.setOptions('autoScroll', options);\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.snap\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `snap` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how action coordinates are snapped. By\n\t         * default, snapping is relative to the pointer coordinates. You can\n\t         * change this by setting the\n\t         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | interact(document.querySelector('#thing')).snap({\n\t         |     targets: [\n\t         |         // snap to this specific point\n\t         |         {\n\t         |             x: 100,\n\t         |             y: 100,\n\t         |             range: 25\n\t         |         },\n\t         |         // give this function the x and y page coords and snap to the object returned\n\t         |         function (x, y) {\n\t         |             return {\n\t         |                 x: x,\n\t         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n\t         |                 range: 40\n\t         |             };\n\t         |         },\n\t         |         // create a function that snaps to a grid\n\t         |         interact.createSnapGrid({\n\t         |             x: 50,\n\t         |             y: 50,\n\t         |             range: 10,              // optional\n\t         |             offset: { x: 5, y: 10 } // optional\n\t         |         })\n\t         |     ],\n\t         |     // do not snap during normal movement.\n\t         |     // Instead, trigger only one snapped move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     relativePoints: [\n\t         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n\t         |         { x: 1, y: 1 },  // and also to the bottom right\n\t         |     ],  \n\t         |\n\t         |     // offset the snap target coordinates\n\t         |     // can be an object with x/y or 'startCoords'\n\t         |     offset: { x: 50, y: 50 }\n\t         |   }\n\t         | });\n\t        \\*/\n\t        snap: function (options) {\n\t            var ret = this.setOptions('snap', options);\n\t\n\t            if (ret === this) { return this; }\n\t\n\t            return ret.drag;\n\t        },\n\t\n\t        setOptions: function (option, options) {\n\t            var actions = options && isArray(options.actions)\n\t                    ? options.actions\n\t                    : ['drag'];\n\t\n\t            var i;\n\t\n\t            if (isObject(options) || isBool(options)) {\n\t                for (i = 0; i < actions.length; i++) {\n\t                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\t\n\t                    if (!isObject(this.options[action])) { continue; }\n\t\n\t                    var thisOption = this.options[action][option];\n\t\n\t                    if (isObject(options)) {\n\t                        extend(thisOption, options);\n\t                        thisOption.enabled = options.enabled === false? false: true;\n\t\n\t                        if (option === 'snap') {\n\t                            if (thisOption.mode === 'grid') {\n\t                                thisOption.targets = [\n\t                                    interact.createSnapGrid(extend({\n\t                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n\t                                    }, thisOption.grid || {}))\n\t                                ];\n\t                            }\n\t                            else if (thisOption.mode === 'anchor') {\n\t                                thisOption.targets = thisOption.anchors;\n\t                            }\n\t                            else if (thisOption.mode === 'path') {\n\t                                thisOption.targets = thisOption.paths;\n\t                            }\n\t\n\t                            if ('elementOrigin' in options) {\n\t                                thisOption.relativePoints = [options.elementOrigin];\n\t                            }\n\t                        }\n\t                    }\n\t                    else if (isBool(options)) {\n\t                        thisOption.enabled = options;\n\t                    }\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            var ret = {},\n\t                allActions = ['drag', 'resize', 'gesture'];\n\t\n\t            for (i = 0; i < allActions.length; i++) {\n\t                if (option in defaultOptions[allActions[i]]) {\n\t                    ret[allActions[i]] = this.options[allActions[i]][option];\n\t                }\n\t            }\n\t\n\t            return ret;\n\t        },\n\t\n\t\n\t        /*\\\n\t         * Interactable.inertia\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `inertia` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how events continue to run after the pointer is released\n\t         **\n\t         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | // enable and use default settings\n\t         | interact(element).inertia(true);\n\t         |\n\t         | // enable and use custom settings\n\t         | interact(element).inertia({\n\t         |     // value greater than 0\n\t         |     // high values slow the object down more quickly\n\t         |     resistance     : 16,\n\t         |\n\t         |     // the minimum launch speed (pixels per second) that results in inertia start\n\t         |     minSpeed       : 200,\n\t         |\n\t         |     // inertia will stop when the object slows down to this speed\n\t         |     endSpeed       : 20,\n\t         |\n\t         |     // boolean; should actions be resumed when the pointer goes down during inertia\n\t         |     allowResume    : true,\n\t         |\n\t         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n\t         |     zeroResumeDelta: false,\n\t         |\n\t         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n\t         |     // the pointer without triggering inertia will animate from the release\n\t         |     // point to the snaped/restricted point in the given amount of time (ms)\n\t         |     smoothEndDuration: 300,\n\t         |\n\t         |     // an array of action types that can have inertia (no gesture)\n\t         |     actions        : ['drag', 'resize']\n\t         | });\n\t         |\n\t         | // reset custom settings and use all defaults\n\t         | interact(element).inertia(null);\n\t        \\*/\n\t        inertia: function (options) {\n\t            var ret = this.setOptions('inertia', options);\n\t\n\t            if (ret === this) { return this; }\n\t\n\t            return ret.drag;\n\t        },\n\t\n\t        getAction: function (pointer, event, interaction, element) {\n\t            var action = this.defaultActionChecker(pointer, interaction, element);\n\t\n\t            if (this.options.actionChecker) {\n\t                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n\t            }\n\t\n\t            return action;\n\t        },\n\t\n\t        defaultActionChecker: defaultActionChecker,\n\t\n\t        /*\\\n\t         * Interactable.actionChecker\n\t         [ method ]\n\t         *\n\t         * Gets or sets the function used to check action to be performed on\n\t         * pointerDown\n\t         *\n\t         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         | interact('.resize-drag')\n\t         |   .resizable(true)\n\t         |   .draggable(true)\n\t         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n\t         |\n\t         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n\t         |     // force drag with handle target\n\t         |     action.name = drag;\n\t         |   }\n\t         |   else {\n\t         |     // resize from the top and right edges\n\t         |     action.name  = 'resize';\n\t         |     action.edges = { top: true, right: true };\n\t         |   }\n\t         |\n\t         |   return action;\n\t         | });\n\t        \\*/\n\t        actionChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.options.actionChecker = checker;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (checker === null) {\n\t                delete this.options.actionChecker;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.actionChecker;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.getRect\n\t         [ method ]\n\t         *\n\t         * The default function to get an Interactables bounding rect. Can be\n\t         * overridden using @Interactable.rectChecker.\n\t         *\n\t         - element (Element) #optional The element to measure.\n\t         = (object) The object's bounding rectangle.\n\t         o {\n\t         o     top   : 0,\n\t         o     left  : 0,\n\t         o     bottom: 0,\n\t         o     right : 0,\n\t         o     width : 0,\n\t         o     height: 0\n\t         o }\n\t        \\*/\n\t        getRect: function rectCheck (element) {\n\t            element = element || this._element;\n\t\n\t            if (this.selector && !(isElement(element))) {\n\t                element = this._context.querySelector(this.selector);\n\t            }\n\t\n\t            return getElementRect(element);\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.rectChecker\n\t         [ method ]\n\t         *\n\t         * Returns or sets the function used to calculate the interactable's\n\t         * element's rectangle\n\t         *\n\t         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n\t         = (function | object) The checker function or this Interactable\n\t        \\*/\n\t        rectChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.getRect = checker;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (checker === null) {\n\t                delete this.options.getRect;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.getRect;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.styleCursor\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether the action that would be performed when the\n\t         * mouse on the element are checked on `mousemove` so that the cursor\n\t         * may be styled appropriately\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (boolean | Interactable) The current setting or this Interactable\n\t        \\*/\n\t        styleCursor: function (newValue) {\n\t            if (isBool(newValue)) {\n\t                this.options.styleCursor = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.styleCursor;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.styleCursor;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.preventDefault\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether to prevent the browser's default behaviour\n\t         * in response to pointer events. Can be set to:\n\t         *  - `'always'` to always prevent\n\t         *  - `'never'` to never prevent\n\t         *  - `'auto'` to let interact.js try to determine what would be best\n\t         *\n\t         - newValue (string) #optional `true`, `false` or `'auto'`\n\t         = (string | Interactable) The current setting or this Interactable\n\t        \\*/\n\t        preventDefault: function (newValue) {\n\t            if (/^(always|never|auto)$/.test(newValue)) {\n\t                this.options.preventDefault = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isBool(newValue)) {\n\t                this.options.preventDefault = newValue? 'always' : 'never';\n\t                return this;\n\t            }\n\t\n\t            return this.options.preventDefault;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.origin\n\t         [ method ]\n\t         *\n\t         * Gets or sets the origin of the Interactable's element.  The x and y\n\t         * of the origin will be subtracted from action event coordinates.\n\t         *\n\t         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n\t         * OR\n\t         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n\t         **\n\t         = (object) The current origin or this Interactable\n\t        \\*/\n\t        origin: function (newValue) {\n\t            if (trySelector(newValue)) {\n\t                this.options.origin = newValue;\n\t                return this;\n\t            }\n\t            else if (isObject(newValue)) {\n\t                this.options.origin = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.origin;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.deltaSource\n\t         [ method ]\n\t         *\n\t         * Returns or sets the mouse coordinate types used to calculate the\n\t         * movement of the pointer.\n\t         *\n\t         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n\t         = (string | object) The current deltaSource or this Interactable\n\t        \\*/\n\t        deltaSource: function (newValue) {\n\t            if (newValue === 'page' || newValue === 'client') {\n\t                this.options.deltaSource = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.deltaSource;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.restrict\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `restrict` property to the options object passed to\n\t         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n\t         *\n\t         * Returns or sets the rectangles within which actions on this\n\t         * interactable (after snap calculations) are restricted. By default,\n\t         * restricting is relative to the pointer coordinates. You can change\n\t         * this by setting the\n\t         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n\t         = (object) The current restrictions object or this Interactable\n\t         **\n\t         | interact(element).restrict({\n\t         |     // the rect will be `interact.getElementRect(element.parentNode)`\n\t         |     drag: element.parentNode,\n\t         |\n\t         |     // x and y are relative to the the interactable's origin\n\t         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n\t         | })\n\t         |\n\t         | interact('.draggable').restrict({\n\t         |     // the rect will be the selected element's parent\n\t         |     drag: 'parent',\n\t         |\n\t         |     // do not restrict during normal movement.\n\t         |     // Instead, trigger only one restricted move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n\t         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n\t         | });\n\t        \\*/\n\t        restrict: function (options) {\n\t            if (!isObject(options)) {\n\t                return this.setOptions('restrict', options);\n\t            }\n\t\n\t            var actions = ['drag', 'resize', 'gesture'],\n\t                ret;\n\t\n\t            for (var i = 0; i < actions.length; i++) {\n\t                var action = actions[i];\n\t\n\t                if (action in options) {\n\t                    var perAction = extend({\n\t                            actions: [action],\n\t                            restriction: options[action]\n\t                        }, options);\n\t\n\t                    ret = this.setOptions('restrict', perAction);\n\t                }\n\t            }\n\t\n\t            return ret;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.context\n\t         [ method ]\n\t         *\n\t         * Gets the selector context Node of the Interactable. The default is `window.document`.\n\t         *\n\t         = (Node) The context Node of this Interactable\n\t         **\n\t        \\*/\n\t        context: function () {\n\t            return this._context;\n\t        },\n\t\n\t        _context: document,\n\t\n\t        /*\\\n\t         * Interactable.ignoreFrom\n\t         [ method ]\n\t         *\n\t         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n\t         * event or any of it's parents match the given CSS selector or\n\t         * Element, no drag/resize/gesture is started.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n\t         = (string | Element | object) The current ignoreFrom value or this Interactable\n\t         **\n\t         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n\t         | // or\n\t         | interact(element).ignoreFrom('input, textarea, a');\n\t        \\*/\n\t        ignoreFrom: function (newValue) {\n\t            if (trySelector(newValue)) {            // CSS selector to match event.target\n\t                this.options.ignoreFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isElement(newValue)) {              // specific element\n\t                this.options.ignoreFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.ignoreFrom;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.allowFrom\n\t         [ method ]\n\t         *\n\t         * A drag/resize/gesture is started only If the target of the\n\t         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n\t         * parents match the given CSS selector or Element.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n\t         = (string | Element | object) The current allowFrom value or this Interactable\n\t         **\n\t         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n\t         | // or\n\t         | interact(element).allowFrom('.handle');\n\t        \\*/\n\t        allowFrom: function (newValue) {\n\t            if (trySelector(newValue)) {            // CSS selector to match event.target\n\t                this.options.allowFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isElement(newValue)) {              // specific element\n\t                this.options.allowFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.allowFrom;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.element\n\t         [ method ]\n\t         *\n\t         * If this is not a selector Interactable, it returns the element this\n\t         * interactable represents\n\t         *\n\t         = (Element) HTML / SVG Element\n\t        \\*/\n\t        element: function () {\n\t            return this._element;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.fire\n\t         [ method ]\n\t         *\n\t         * Calls listeners for the given InteractEvent type bound globally\n\t         * and directly to this Interactable\n\t         *\n\t         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t        fire: function (iEvent) {\n\t            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n\t                return this;\n\t            }\n\t\n\t            var listeners,\n\t                i,\n\t                len,\n\t                onEvent = 'on' + iEvent.type,\n\t                funcName = '';\n\t\n\t            // Interactable#on() listeners\n\t            if (iEvent.type in this._iEvents) {\n\t                listeners = this._iEvents[iEvent.type];\n\t\n\t                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t                    funcName = listeners[i].name;\n\t                    listeners[i](iEvent);\n\t                }\n\t            }\n\t\n\t            // interactable.onevent listener\n\t            if (isFunction(this[onEvent])) {\n\t                funcName = this[onEvent].name;\n\t                this[onEvent](iEvent);\n\t            }\n\t\n\t            // interact.on() listeners\n\t            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\t\n\t                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t                    funcName = listeners[i].name;\n\t                    listeners[i](iEvent);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.on\n\t         [ method ]\n\t         *\n\t         * Binds a listener for an InteractEvent or DOM event.\n\t         *\n\t         - eventType  (string | array | object) The types of events to listen for\n\t         - listener   (function) The function to be called on the given event(s)\n\t         - useCapture (boolean) #optional useCapture flag for addEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t        on: function (eventType, listener, useCapture) {\n\t            var i;\n\t\n\t            if (isString(eventType) && eventType.search(' ') !== -1) {\n\t                eventType = eventType.trim().split(/ +/);\n\t            }\n\t\n\t            if (isArray(eventType)) {\n\t                for (i = 0; i < eventType.length; i++) {\n\t                    this.on(eventType[i], listener, useCapture);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isObject(eventType)) {\n\t                for (var prop in eventType) {\n\t                    this.on(prop, eventType[prop], listener);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (eventType === 'wheel') {\n\t                eventType = wheelEvent;\n\t            }\n\t\n\t            // convert to boolean\n\t            useCapture = useCapture? true: false;\n\t\n\t            if (contains(eventTypes, eventType)) {\n\t                // if this type of event was never bound to this Interactable\n\t                if (!(eventType in this._iEvents)) {\n\t                    this._iEvents[eventType] = [listener];\n\t                }\n\t                else {\n\t                    this._iEvents[eventType].push(listener);\n\t                }\n\t            }\n\t            // delegated event for selector\n\t            else if (this.selector) {\n\t                if (!delegatedEvents[eventType]) {\n\t                    delegatedEvents[eventType] = {\n\t                        selectors: [],\n\t                        contexts : [],\n\t                        listeners: []\n\t                    };\n\t\n\t                    // add delegate listener functions\n\t                    for (i = 0; i < documents.length; i++) {\n\t                        events.add(documents[i], eventType, delegateListener);\n\t                        events.add(documents[i], eventType, delegateUseCapture, true);\n\t                    }\n\t                }\n\t\n\t                var delegated = delegatedEvents[eventType],\n\t                    index;\n\t\n\t                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t                    if (delegated.selectors[index] === this.selector\n\t                        && delegated.contexts[index] === this._context) {\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                if (index === -1) {\n\t                    index = delegated.selectors.length;\n\t\n\t                    delegated.selectors.push(this.selector);\n\t                    delegated.contexts .push(this._context);\n\t                    delegated.listeners.push([]);\n\t                }\n\t\n\t                // keep listener and useCapture flag\n\t                delegated.listeners[index].push([listener, useCapture]);\n\t            }\n\t            else {\n\t                events.add(this._element, eventType, listener, useCapture);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.off\n\t         [ method ]\n\t         *\n\t         * Removes an InteractEvent or DOM event listener\n\t         *\n\t         - eventType  (string | array | object) The types of events that were listened for\n\t         - listener   (function) The listener function to be removed\n\t         - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t        off: function (eventType, listener, useCapture) {\n\t            var i;\n\t\n\t            if (isString(eventType) && eventType.search(' ') !== -1) {\n\t                eventType = eventType.trim().split(/ +/);\n\t            }\n\t\n\t            if (isArray(eventType)) {\n\t                for (i = 0; i < eventType.length; i++) {\n\t                    this.off(eventType[i], listener, useCapture);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isObject(eventType)) {\n\t                for (var prop in eventType) {\n\t                    this.off(prop, eventType[prop], listener);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            var eventList,\n\t                index = -1;\n\t\n\t            // convert to boolean\n\t            useCapture = useCapture? true: false;\n\t\n\t            if (eventType === 'wheel') {\n\t                eventType = wheelEvent;\n\t            }\n\t\n\t            // if it is an action event type\n\t            if (contains(eventTypes, eventType)) {\n\t                eventList = this._iEvents[eventType];\n\t\n\t                if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n\t                    this._iEvents[eventType].splice(index, 1);\n\t                }\n\t            }\n\t            // delegated event\n\t            else if (this.selector) {\n\t                var delegated = delegatedEvents[eventType],\n\t                    matchFound = false;\n\t\n\t                if (!delegated) { return this; }\n\t\n\t                // count from last index of delegated to 0\n\t                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t                    // look for matching selector and context Node\n\t                    if (delegated.selectors[index] === this.selector\n\t                        && delegated.contexts[index] === this._context) {\n\t\n\t                        var listeners = delegated.listeners[index];\n\t\n\t                        // each item of the listeners array is an array: [function, useCaptureFlag]\n\t                        for (i = listeners.length - 1; i >= 0; i--) {\n\t                            var fn = listeners[i][0],\n\t                                useCap = listeners[i][1];\n\t\n\t                            // check if the listener functions and useCapture flags match\n\t                            if (fn === listener && useCap === useCapture) {\n\t                                // remove the listener from the array of listeners\n\t                                listeners.splice(i, 1);\n\t\n\t                                // if all listeners for this interactable have been removed\n\t                                // remove the interactable from the delegated arrays\n\t                                if (!listeners.length) {\n\t                                    delegated.selectors.splice(index, 1);\n\t                                    delegated.contexts .splice(index, 1);\n\t                                    delegated.listeners.splice(index, 1);\n\t\n\t                                    // remove delegate function from context\n\t                                    events.remove(this._context, eventType, delegateListener);\n\t                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\t\n\t                                    // remove the arrays if they are empty\n\t                                    if (!delegated.selectors.length) {\n\t                                        delegatedEvents[eventType] = null;\n\t                                    }\n\t                                }\n\t\n\t                                // only remove one listener\n\t                                matchFound = true;\n\t                                break;\n\t                            }\n\t                        }\n\t\n\t                        if (matchFound) { break; }\n\t                    }\n\t                }\n\t            }\n\t            // remove listener from this Interatable's element\n\t            else {\n\t                events.remove(this._element, eventType, listener, useCapture);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.set\n\t         [ method ]\n\t         *\n\t         * Reset the options of this Interactable\n\t         - options (object) The new settings to apply\n\t         = (object) This Interactable\n\t        \\*/\n\t        set: function (options) {\n\t            if (!isObject(options)) {\n\t                options = {};\n\t            }\n\t\n\t            this.options = extend({}, defaultOptions.base);\n\t\n\t            var i,\n\t                actions = ['drag', 'drop', 'resize', 'gesture'],\n\t                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n\t                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\t\n\t            for (i = 0; i < actions.length; i++) {\n\t                var action = actions[i];\n\t\n\t                this.options[action] = extend({}, defaultOptions[action]);\n\t\n\t                this.setPerAction(action, perActions);\n\t\n\t                this[methods[i]](options[action]);\n\t            }\n\t\n\t            var settings = [\n\t                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n\t                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n\t                    'rectChecker', 'styleCursor'\n\t                ];\n\t\n\t            for (i = 0, len = settings.length; i < len; i++) {\n\t                var setting = settings[i];\n\t\n\t                this.options[setting] = defaultOptions.base[setting];\n\t\n\t                if (setting in options) {\n\t                    this[setting](options[setting]);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.unset\n\t         [ method ]\n\t         *\n\t         * Remove this interactable from the list of interactables and remove\n\t         * it's drag, drop, resize and gesture capabilities\n\t         *\n\t         = (object) @interact\n\t        \\*/\n\t        unset: function () {\n\t            events.remove(this._element, 'all');\n\t\n\t            if (!isString(this.selector)) {\n\t                events.remove(this, 'all');\n\t                if (this.options.styleCursor) {\n\t                    this._element.style.cursor = '';\n\t                }\n\t            }\n\t            else {\n\t                // remove delegated events\n\t                for (var type in delegatedEvents) {\n\t                    var delegated = delegatedEvents[type];\n\t\n\t                    for (var i = 0; i < delegated.selectors.length; i++) {\n\t                        if (delegated.selectors[i] === this.selector\n\t                            && delegated.contexts[i] === this._context) {\n\t\n\t                            delegated.selectors.splice(i, 1);\n\t                            delegated.contexts .splice(i, 1);\n\t                            delegated.listeners.splice(i, 1);\n\t\n\t                            // remove the arrays if they are empty\n\t                            if (!delegated.selectors.length) {\n\t                                delegatedEvents[type] = null;\n\t                            }\n\t                        }\n\t\n\t                        events.remove(this._context, type, delegateListener);\n\t                        events.remove(this._context, type, delegateUseCapture, true);\n\t\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dropzone(false);\n\t\n\t            interactables.splice(indexOf(interactables, this), 1);\n\t\n\t            return interact;\n\t        }\n\t    };\n\t\n\t    function warnOnce (method, message) {\n\t        var warned = false;\n\t\n\t        return function () {\n\t            if (!warned) {\n\t                window.console.warn(message);\n\t                warned = true;\n\t            }\n\t\n\t            return method.apply(this, arguments);\n\t        };\n\t    }\n\t\n\t    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n\t         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n\t    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n\t         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n\t    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n\t         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n\t    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n\t         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n\t    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n\t         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\t\n\t    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n\t         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n\t    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n\t         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n\t    Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n\t         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\t\n\t    /*\\\n\t     * interact.isSet\n\t     [ method ]\n\t     *\n\t     * Check if an element has been set\n\t     - element (Element) The Element being searched for\n\t     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\t    \\*/\n\t    interact.isSet = function(element, options) {\n\t        return interactables.indexOfElement(element, options && options.context) !== -1;\n\t    };\n\t\n\t    /*\\\n\t     * interact.on\n\t     [ method ]\n\t     *\n\t     * Adds a global listener for an InteractEvent or adds a DOM event to\n\t     * `document`\n\t     *\n\t     - type       (string | array | object) The types of events to listen for\n\t     - listener   (function) The function to be called on the given event(s)\n\t     - useCapture (boolean) #optional useCapture flag for addEventListener\n\t     = (object) interact\n\t    \\*/\n\t    interact.on = function (type, listener, useCapture) {\n\t        if (isString(type) && type.search(' ') !== -1) {\n\t            type = type.trim().split(/ +/);\n\t        }\n\t\n\t        if (isArray(type)) {\n\t            for (var i = 0; i < type.length; i++) {\n\t                interact.on(type[i], listener, useCapture);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (isObject(type)) {\n\t            for (var prop in type) {\n\t                interact.on(prop, type[prop], listener);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        // if it is an InteractEvent type, add listener to globalEvents\n\t        if (contains(eventTypes, type)) {\n\t            // if this type of event was never bound\n\t            if (!globalEvents[type]) {\n\t                globalEvents[type] = [listener];\n\t            }\n\t            else {\n\t                globalEvents[type].push(listener);\n\t            }\n\t        }\n\t        // If non InteractEvent type, addEventListener to document\n\t        else {\n\t            events.add(document, type, listener, useCapture);\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.off\n\t     [ method ]\n\t     *\n\t     * Removes a global InteractEvent listener or DOM event from `document`\n\t     *\n\t     - type       (string | array | object) The types of events that were listened for\n\t     - listener   (function) The listener function to be removed\n\t     - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t     = (object) interact\n\t     \\*/\n\t    interact.off = function (type, listener, useCapture) {\n\t        if (isString(type) && type.search(' ') !== -1) {\n\t            type = type.trim().split(/ +/);\n\t        }\n\t\n\t        if (isArray(type)) {\n\t            for (var i = 0; i < type.length; i++) {\n\t                interact.off(type[i], listener, useCapture);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (isObject(type)) {\n\t            for (var prop in type) {\n\t                interact.off(prop, type[prop], listener);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (!contains(eventTypes, type)) {\n\t            events.remove(document, type, listener, useCapture);\n\t        }\n\t        else {\n\t            var index;\n\t\n\t            if (type in globalEvents\n\t                && (index = indexOf(globalEvents[type], listener)) !== -1) {\n\t                globalEvents[type].splice(index, 1);\n\t            }\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.enableDragging\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether dragging is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableDragging = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.drag = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.drag;\n\t    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\t\n\t    /*\\\n\t     * interact.enableResizing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether resizing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableResizing = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.resize = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.resize;\n\t    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\t\n\t    /*\\\n\t     * interact.enableGesturing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether gesturing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableGesturing = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.gesture = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.gesture;\n\t    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\t\n\t    interact.eventTypes = eventTypes;\n\t\n\t    /*\\\n\t     * interact.debug\n\t     [ method ]\n\t     *\n\t     * Returns debugging data\n\t     = (object) An object with properties that outline the current state and expose internal functions and variables\n\t    \\*/\n\t    interact.debug = function () {\n\t        var interaction = interactions[0] || new Interaction();\n\t\n\t        return {\n\t            interactions          : interactions,\n\t            target                : interaction.target,\n\t            dragging              : interaction.dragging,\n\t            resizing              : interaction.resizing,\n\t            gesturing             : interaction.gesturing,\n\t            prepared              : interaction.prepared,\n\t            matches               : interaction.matches,\n\t            matchElements         : interaction.matchElements,\n\t\n\t            prevCoords            : interaction.prevCoords,\n\t            startCoords           : interaction.startCoords,\n\t\n\t            pointerIds            : interaction.pointerIds,\n\t            pointers              : interaction.pointers,\n\t            addPointer            : listeners.addPointer,\n\t            removePointer         : listeners.removePointer,\n\t            recordPointer        : listeners.recordPointer,\n\t\n\t            snap                  : interaction.snapStatus,\n\t            restrict              : interaction.restrictStatus,\n\t            inertia               : interaction.inertiaStatus,\n\t\n\t            downTime              : interaction.downTimes[0],\n\t            downEvent             : interaction.downEvent,\n\t            downPointer           : interaction.downPointer,\n\t            prevEvent             : interaction.prevEvent,\n\t\n\t            Interactable          : Interactable,\n\t            interactables         : interactables,\n\t            pointerIsDown         : interaction.pointerIsDown,\n\t            defaultOptions        : defaultOptions,\n\t            defaultActionChecker  : defaultActionChecker,\n\t\n\t            actionCursors         : actionCursors,\n\t            dragMove              : listeners.dragMove,\n\t            resizeMove            : listeners.resizeMove,\n\t            gestureMove           : listeners.gestureMove,\n\t            pointerUp             : listeners.pointerUp,\n\t            pointerDown           : listeners.pointerDown,\n\t            pointerMove           : listeners.pointerMove,\n\t            pointerHover          : listeners.pointerHover,\n\t\n\t            eventTypes            : eventTypes,\n\t\n\t            events                : events,\n\t            globalEvents          : globalEvents,\n\t            delegatedEvents       : delegatedEvents,\n\t\n\t            prefixedPropREs       : prefixedPropREs\n\t        };\n\t    };\n\t\n\t    // expose the functions used to calculate multi-touch properties\n\t    interact.getPointerAverage = pointerAverage;\n\t    interact.getTouchBBox     = touchBBox;\n\t    interact.getTouchDistance = touchDistance;\n\t    interact.getTouchAngle    = touchAngle;\n\t\n\t    interact.getElementRect         = getElementRect;\n\t    interact.getElementClientRect   = getElementClientRect;\n\t    interact.matchesSelector        = matchesSelector;\n\t    interact.closest                = closest;\n\t\n\t    /*\\\n\t     * interact.margin\n\t     [ method ]\n\t     *\n\t     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n\t     * Returns or sets the margin for autocheck resizing used in\n\t     * @Interactable.getAction. That is the distance from the bottom and right\n\t     * edges of an element clicking in which will start resizing\n\t     *\n\t     - newValue (number) #optional\n\t     = (number | interact) The current margin value or interact\n\t    \\*/\n\t    interact.margin = warnOnce(function (newvalue) {\n\t        if (isNumber(newvalue)) {\n\t            margin = newvalue;\n\t\n\t            return interact;\n\t        }\n\t        return margin;\n\t    },\n\t    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\t\n\t    /*\\\n\t     * interact.supportsTouch\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports touch input\n\t    \\*/\n\t    interact.supportsTouch = function () {\n\t        return supportsTouch;\n\t    };\n\t\n\t    /*\\\n\t     * interact.supportsPointerEvent\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports PointerEvents\n\t    \\*/\n\t    interact.supportsPointerEvent = function () {\n\t        return supportsPointerEvent;\n\t    };\n\t\n\t    /*\\\n\t     * interact.stop\n\t     [ method ]\n\t     *\n\t     * Cancels all interactions (end events are not fired)\n\t     *\n\t     - event (Event) An event on which to call preventDefault()\n\t     = (object) interact\n\t    \\*/\n\t    interact.stop = function (event) {\n\t        for (var i = interactions.length - 1; i >= 0; i--) {\n\t            interactions[i].stop(event);\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.dynamicDrop\n\t     [ method ]\n\t     *\n\t     * Returns or sets whether the dimensions of dropzone elements are\n\t     * calculated on every dragmove or only on dragstart for the default\n\t     * dropChecker\n\t     *\n\t     - newValue (boolean) #optional True to check on each move. False to check only before start\n\t     = (boolean | interact) The current setting or interact\n\t    \\*/\n\t    interact.dynamicDrop = function (newValue) {\n\t        if (isBool(newValue)) {\n\t            //if (dragging && dynamicDrop !== newValue && !newValue) {\n\t                //calcRects(dropzones);\n\t            //}\n\t\n\t            dynamicDrop = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return dynamicDrop;\n\t    };\n\t\n\t    /*\\\n\t     * interact.pointerMoveTolerance\n\t     [ method ]\n\t     * Returns or sets the distance the pointer must be moved before an action\n\t     * sequence occurs. This also affects tolerance for tap events.\n\t     *\n\t     - newValue (number) #optional The movement from the start position must be greater than this value\n\t     = (number | Interactable) The current setting or interact\n\t    \\*/\n\t    interact.pointerMoveTolerance = function (newValue) {\n\t        if (isNumber(newValue)) {\n\t            pointerMoveTolerance = newValue;\n\t\n\t            return this;\n\t        }\n\t\n\t        return pointerMoveTolerance;\n\t    };\n\t\n\t    /*\\\n\t     * interact.maxInteractions\n\t     [ method ]\n\t     **\n\t     * Returns or sets the maximum number of concurrent interactions allowed.\n\t     * By default only 1 interaction is allowed at a time (for backwards\n\t     * compatibility). To allow multiple interactions on the same Interactables\n\t     * and elements, you need to enable it in the draggable, resizable and\n\t     * gesturable `'max'` and `'maxPerElement'` options.\n\t     **\n\t     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\t    \\*/\n\t    interact.maxInteractions = function (newValue) {\n\t        if (isNumber(newValue)) {\n\t            maxInteractions = newValue;\n\t\n\t            return this;\n\t        }\n\t\n\t        return maxInteractions;\n\t    };\n\t\n\t    interact.createSnapGrid = function (grid) {\n\t        return function (x, y) {\n\t            var offsetX = 0,\n\t                offsetY = 0;\n\t\n\t            if (isObject(grid.offset)) {\n\t                offsetX = grid.offset.x;\n\t                offsetY = grid.offset.y;\n\t            }\n\t\n\t            var gridx = Math.round((x - offsetX) / grid.x),\n\t                gridy = Math.round((y - offsetY) / grid.y),\n\t\n\t                newX = gridx * grid.x + offsetX,\n\t                newY = gridy * grid.y + offsetY;\n\t\n\t            return {\n\t                x: newX,\n\t                y: newY,\n\t                range: grid.range\n\t            };\n\t        };\n\t    };\n\t\n\t    function endAllInteractions (event) {\n\t        for (var i = 0; i < interactions.length; i++) {\n\t            interactions[i].pointerEnd(event, event);\n\t        }\n\t    }\n\t\n\t    function listenToDocument (doc) {\n\t        if (contains(documents, doc)) { return; }\n\t\n\t        var win = doc.defaultView || doc.parentWindow;\n\t\n\t        // add delegate event listener\n\t        for (var eventType in delegatedEvents) {\n\t            events.add(doc, eventType, delegateListener);\n\t            events.add(doc, eventType, delegateUseCapture, true);\n\t        }\n\t\n\t        if (PointerEvent) {\n\t            if (PointerEvent === win.MSPointerEvent) {\n\t                pEventTypes = {\n\t                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n\t                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n\t            }\n\t            else {\n\t                pEventTypes = {\n\t                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n\t                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n\t            }\n\t\n\t            events.add(doc, pEventTypes.down  , listeners.selectorDown );\n\t            events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n\t            events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n\t            events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n\t            events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n\t            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\t\n\t            // autoscroll\n\t            events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n\t        }\n\t        else {\n\t            events.add(doc, 'mousedown', listeners.selectorDown);\n\t            events.add(doc, 'mousemove', listeners.pointerMove );\n\t            events.add(doc, 'mouseup'  , listeners.pointerUp   );\n\t            events.add(doc, 'mouseover', listeners.pointerOver );\n\t            events.add(doc, 'mouseout' , listeners.pointerOut  );\n\t\n\t            events.add(doc, 'touchstart' , listeners.selectorDown );\n\t            events.add(doc, 'touchmove'  , listeners.pointerMove  );\n\t            events.add(doc, 'touchend'   , listeners.pointerUp    );\n\t            events.add(doc, 'touchcancel', listeners.pointerCancel);\n\t\n\t            // autoscroll\n\t            events.add(doc, 'mousemove', listeners.autoScrollMove);\n\t            events.add(doc, 'touchmove', listeners.autoScrollMove);\n\t        }\n\t\n\t        events.add(win, 'blur', endAllInteractions);\n\t\n\t        try {\n\t            if (win.frameElement) {\n\t                var parentDoc = win.frameElement.ownerDocument,\n\t                    parentWindow = parentDoc.defaultView;\n\t\n\t                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n\t                events.add(parentWindow, 'blur'         , endAllInteractions );\n\t            }\n\t        }\n\t        catch (error) {\n\t            interact.windowParentError = error;\n\t        }\n\t\n\t        // prevent native HTML5 drag on interact.js target elements\n\t        events.add(doc, 'dragstart', function (event) {\n\t            for (var i = 0; i < interactions.length; i++) {\n\t                var interaction = interactions[i];\n\t\n\t                if (interaction.element\n\t                    && (interaction.element === event.target\n\t                        || nodeContains(interaction.element, event.target))) {\n\t\n\t                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t\n\t        if (events.useAttachEvent) {\n\t            // For IE's lack of Event#preventDefault\n\t            events.add(doc, 'selectstart', function (event) {\n\t                var interaction = interactions[0];\n\t\n\t                if (interaction.currentAction()) {\n\t                    interaction.checkAndPreventDefault(event);\n\t                }\n\t            });\n\t\n\t            // For IE's bad dblclick event sequence\n\t            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n\t        }\n\t\n\t        documents.push(doc);\n\t    }\n\t\n\t    listenToDocument(document);\n\t\n\t    function indexOf (array, target) {\n\t        for (var i = 0, len = array.length; i < len; i++) {\n\t            if (array[i] === target) {\n\t                return i;\n\t            }\n\t        }\n\t\n\t        return -1;\n\t    }\n\t\n\t    function contains (array, target) {\n\t        return indexOf(array, target) !== -1;\n\t    }\n\t\n\t    function matchesSelector (element, selector, nodeList) {\n\t        if (ie8MatchesSelector) {\n\t            return ie8MatchesSelector(element, selector, nodeList);\n\t        }\n\t\n\t        // remove /deep/ from selectors if shadowDOM polyfill is used\n\t        if (window !== realWindow) {\n\t            selector = selector.replace(/\\/deep\\//g, ' ');\n\t        }\n\t\n\t        return element[prefixedMatchesSelector](selector);\n\t    }\n\t\n\t    function matchesUpTo (element, selector, limit) {\n\t        while (isElement(element)) {\n\t            if (matchesSelector(element, selector)) {\n\t                return true;\n\t            }\n\t\n\t            element = parentElement(element);\n\t\n\t            if (element === limit) {\n\t                return matchesSelector(element, selector);\n\t            }\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    // For IE8's lack of an Element#matchesSelector\n\t    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n\t    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n\t        ie8MatchesSelector = function (element, selector, elems) {\n\t            elems = elems || element.parentNode.querySelectorAll(selector);\n\t\n\t            for (var i = 0, len = elems.length; i < len; i++) {\n\t                if (elems[i] === element) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            return false;\n\t        };\n\t    }\n\t\n\t    // requestAnimationFrame polyfill\n\t    (function() {\n\t        var lastTime = 0,\n\t            vendors = ['ms', 'moz', 'webkit', 'o'];\n\t\n\t        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n\t            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n\t            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n\t        }\n\t\n\t        if (!reqFrame) {\n\t            reqFrame = function(callback) {\n\t                var currTime = new Date().getTime(),\n\t                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n\t                    id = setTimeout(function() { callback(currTime + timeToCall); },\n\t                  timeToCall);\n\t                lastTime = currTime + timeToCall;\n\t                return id;\n\t            };\n\t        }\n\t\n\t        if (!cancelFrame) {\n\t            cancelFrame = function(id) {\n\t                clearTimeout(id);\n\t            };\n\t        }\n\t    }());\n\t\n\t    /* global exports: true, module, define */\n\t\n\t    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n\t    if (true) {\n\t        if (typeof module !== 'undefined' && module.exports) {\n\t            exports = module.exports = interact;\n\t        }\n\t        exports.interact = interact;\n\t    }\n\t    // AMD\n\t    else if (typeof define === 'function' && define.amd) {\n\t        define('interact', function() {\n\t            return interact;\n\t        });\n\t    }\n\t    else {\n\t        realWindow.interact = interact;\n\t    }\n\t\n\t} (typeof window === 'undefined'? undefined : window));\n\n\n/***/ },\n\n/***/ 33:\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div class=\\\"w-app card\\\" v-bind:class=\\\"[loading ? 'isLoading': '', isDeleted ? 'animated zoomOutDown': '', isMax ? 'is-fullwidth' : '']\\\" @click=bringToFront @mousedown=bringToFront @animationend=makeMe draggable=true tabindex=0 _v-ca6846e8=\\\"\\\"> <header class=card-header _v-ca6846e8=\\\"\\\"> <p class=card-header-title _v-ca6846e8=\\\"\\\"> {{title}} </p> <a class=card-header-icon _v-ca6846e8=\\\"\\\"> <i class=\\\"fa fa-minus\\\" _v-ca6846e8=\\\"\\\"></i> </a> <a class=card-header-icon @click=maxApp _v-ca6846e8=\\\"\\\"> <i class=fa v-bind:class=\\\"[isMax ? 'fa-compress': 'fa-expand']\\\" _v-ca6846e8=\\\"\\\"></i> </a> <a class=card-header-icon @click=closeApp _v-ca6846e8=\\\"\\\"> <i class=\\\"fa fa-times\\\" _v-ca6846e8=\\\"\\\"></i> </a> </header> <header v-if=hasSubNav class=\\\"card-header card-header--subnav\\\" _v-ca6846e8=\\\"\\\"> <slot name=header _v-ca6846e8=\\\"\\\"></slot> </header> <div class=card-content _v-ca6846e8=\\\"\\\"> <div class=content _v-ca6846e8=\\\"\\\"> <slot _v-ca6846e8=\\\"\\\"></slot> </div> </div> </div> \";\n\n/***/ },\n\n/***/ 34:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(29)\n\t__webpack_require__(28)\n\t__vue_script__ = __webpack_require__(24)\n\t__vue_template__ = __webpack_require__(33)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n\n/***/ 42:\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n\n/***/ 58:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(43).f\n\t  , has = __webpack_require__(35)\n\t  , TAG = __webpack_require__(20)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n\n/***/ 70:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(71)\n\t  , $export        = __webpack_require__(69)\n\t  , redefine       = __webpack_require__(89)\n\t  , hide           = __webpack_require__(36)\n\t  , has            = __webpack_require__(35)\n\t  , Iterators      = __webpack_require__(42)\n\t  , $iterCreate    = __webpack_require__(109)\n\t  , setToStringTag = __webpack_require__(58)\n\t  , getPrototypeOf = __webpack_require__(113)\n\t  , ITERATOR       = __webpack_require__(20)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n\n/***/ 71:\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n\n/***/ 87:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\tvar anObject    = __webpack_require__(49)\n\t  , dPs         = __webpack_require__(111)\n\t  , enumBugKeys = __webpack_require__(85)\n\t  , IE_PROTO    = __webpack_require__(73)('IE_PROTO')\n\t  , Empty       = function(){ /* empty */ }\n\t  , PROTOTYPE   = 'prototype';\n\t\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function(){\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = __webpack_require__(107)('iframe')\n\t    , i      = enumBugKeys.length\n\t    , lt     = '<'\n\t    , gt     = '>'\n\t    , iframeDocument;\n\t  iframe.style.display = 'none';\n\t  __webpack_require__(108).appendChild(iframe);\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n\t  // createDict = iframe.contentWindow.Object;\n\t  // html.removeChild(iframe);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n\t  return createDict();\n\t};\n\t\n\tmodule.exports = Object.create || function create(O, Properties){\n\t  var result;\n\t  if(O !== null){\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty;\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : dPs(result, Properties);\n\t};\n\n\n/***/ },\n\n/***/ 89:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(36);\n\n/***/ },\n\n/***/ 105:\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n\n/***/ 108:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(25).document && document.documentElement;\n\n/***/ },\n\n/***/ 109:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(87)\n\t  , descriptor     = __webpack_require__(72)\n\t  , setToStringTag = __webpack_require__(58)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(36)(IteratorPrototype, __webpack_require__(20)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n\n/***/ 110:\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n\n/***/ 111:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(43)\n\t  , anObject = __webpack_require__(49)\n\t  , getKeys  = __webpack_require__(51);\n\t\n\tmodule.exports = __webpack_require__(50) ? Object.defineProperties : function defineProperties(O, Properties){\n\t  anObject(O);\n\t  var keys   = getKeys(Properties)\n\t    , length = keys.length\n\t    , i = 0\n\t    , P;\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n\t  return O;\n\t};\n\n/***/ },\n\n/***/ 113:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\tvar has         = __webpack_require__(35)\n\t  , toObject    = __webpack_require__(92)\n\t  , IE_PROTO    = __webpack_require__(73)('IE_PROTO')\n\t  , ObjectProto = Object.prototype;\n\t\n\tmodule.exports = Object.getPrototypeOf || function(O){\n\t  O = toObject(O);\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectProto : null;\n\t};\n\n/***/ },\n\n/***/ 114:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(91)\n\t  , defined   = __webpack_require__(84);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n\n/***/ 116:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global         = __webpack_require__(25)\n\t  , core           = __webpack_require__(41)\n\t  , LIBRARY        = __webpack_require__(71)\n\t  , wksExt         = __webpack_require__(117)\n\t  , defineProperty = __webpack_require__(43).f;\n\tmodule.exports = function(name){\n\t  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n\t  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n\t};\n\n/***/ },\n\n/***/ 117:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.f = __webpack_require__(20);\n\n/***/ },\n\n/***/ 118:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(105)\n\t  , step             = __webpack_require__(110)\n\t  , Iterators        = __webpack_require__(42)\n\t  , toIObject        = __webpack_require__(44);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(70)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n\n/***/ 119:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(114)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(70)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n\n/***/ 120:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(118);\n\tvar global        = __webpack_require__(25)\n\t  , hide          = __webpack_require__(36)\n\t  , Iterators     = __webpack_require__(42)\n\t  , TO_STRING_TAG = __webpack_require__(20)('toStringTag');\n\t\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype;\n\t  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t  Iterators[NAME] = Iterators.Array;\n\t}\n\n/***/ },\n\n/***/ 144:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n\tvar $keys      = __webpack_require__(145)\n\t  , hiddenKeys = __webpack_require__(85).concat('length', 'prototype');\n\t\n\texports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n\t  return $keys(O, hiddenKeys);\n\t};\n\n/***/ },\n\n/***/ 318:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof2 = __webpack_require__(336);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tvar _Applications = __webpack_require__(303);\n\t\n\tvar apps = _interopRequireWildcard(_Applications);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar localforage = __webpack_require__(75);\n\texports.default = {\n\t  data: function data() {\n\t    console.log('apps:', apps.comps);\n\t    return {};\n\t  },\n\t  cmd: function cmd(vue, command) {\n\t    var myCmd = command.split(' ');\n\t\n\t    var _ret = function () {\n\t      switch (myCmd[0]) {\n\t        case 'test':\n\t          return {\n\t            v: { type: 'string', data: 'success' }\n\t          };\n\t        case 'touch':\n\t          if (myCmd.length > 1) {\n\t            localforage.setItem(myCmd[1], '').then(function () {\n\t              vue.results.push({ dataType: 'string', data: myCmd[1], command: command });\n\t            }).catch(function (e) {\n\t              vue.results.push({ dataType: 'string', data: e, command: command });\n\t            });\n\t          } else {\n\t            return {\n\t              v: { dataType: 'string', data: 'Requires at least 1 argument' }\n\t            };\n\t          }\n\t          break;\n\t        case 'cat':\n\t          if (myCmd.length > 1) {\n\t            localforage.getItem(myCmd[1]).then(function (data) {\n\t              vue.results.push({ dataType: 'string', data: data, command: command });\n\t            }).catch(function (e) {\n\t              vue.results.push({ dataType: 'string', data: e, command: command });\n\t            });\n\t          } else {\n\t            return {\n\t              v: { dataType: 'string', data: 'Requires at least 1 argument' }\n\t            };\n\t          }\n\t          break;\n\t        case 'ls':\n\t          var result = [];\n\t          localforage.iterate(function (value, key, iterationNumber) {\n\t            result.push(key);\n\t          }).then(function () {\n\t            vue.results.push({ dataType: 'list', data: result, command: command });\n\t          });\n\t          break;\n\t        case 'help':\n\t          return {\n\t            v: { type: 'string', data: 'Try help, ls, cat, touch, or any app name.' }\n\t          };\n\t        default:\n\t          vue.$dispatch('openApp', command);\n\t          return {\n\t            v: true\n\t          };\n\t      }\n\t    }();\n\t\n\t    if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === \"object\") return _ret.v;\n\t  }\n\t};\n\n/***/ },\n\n/***/ 324:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _extends2 = __webpack_require__(141);\n\t\n\tvar _extends3 = _interopRequireDefault(_extends2);\n\t\n\tvar _wApp = __webpack_require__(34);\n\t\n\tvar _wApp2 = _interopRequireDefault(_wApp);\n\t\n\tvar _commands = __webpack_require__(318);\n\t\n\tvar _commands2 = _interopRequireDefault(_commands);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  data: function data() {\n\t    return {\n\t      commandPosition: 1,\n\t      command: '',\n\t      results: [{ command: 'welcome', dataType: 'string', data: 'Welcome to w-os' }]\n\t    };\n\t  },\n\t\n\t  components: {\n\t    wApp: _wApp2.default\n\t  },\n\t  watch: {\n\t    results: function results(e) {\n\t      var results = document.querySelectorAll('.terminal--result');\n\t      results[results.length - 1].scrollIntoView({ block: 'end', behavior: 'smooth' });\n\t    }\n\t  },\n\t  methods: {\n\t    openNew: function openNew(app) {\n\t      this.$dispatch('openApp', app);\n\t    },\n\t    giveFocus: function giveFocus(shell) {\n\t      shell.currentTarget.querySelector('input').focus();\n\t    },\n\t    monitorKeys: function monitorKeys(e) {\n\t      console.log('key monitor:', e);\n\t      console.log('commandPosition:', this.commandPosition);\n\t      if (e === 'up' && this.results[this.commandPosition - 1]) {\n\t        this.$set('commandPosition', this.$get('commandPosition') - 1);\n\t      } else if (e === 'down') {\n\t        this.$set('commandPosition', this.$get('commandPosition') + 1);\n\t      }\n\t      if (this.$get('commandPosition') >= this.results.length) {\n\t        this.$set('command', '');\n\t        this.$set('commandPosition', this.results.length);\n\t      } else {\n\t        this.$set('command', this.results[this.$get('commandPosition')].command);\n\t      }\n\t      console.log('commandPosition:', this.commandPosition);\n\t    },\n\t    runCommand: function runCommand(e) {\n\t      var command = this.$get('command');\n\t      var result = _commands2.default.cmd(this, command);\n\t\n\t      if (result) {\n\t        this.results.push((0, _extends3.default)({}, result, { command: command }));\n\t      }\n\t      this.$set('command', '');\n\t      if (this.commandPosition < this.results.length) {\n\t        this.$set('commandPosition', this.results.length);\n\t      } else {\n\t        this.$set('commandPosition', this.commandPosition + 1);\n\t      }\n\t      console.log('results:', this.$get('results'));\n\t    }\n\t  }\n\t};\n\n/***/ },\n\n/***/ 334:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(341), __esModule: true };\n\n/***/ },\n\n/***/ 335:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(342), __esModule: true };\n\n/***/ },\n\n/***/ 336:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _iterator = __webpack_require__(335);\n\t\n\tvar _iterator2 = _interopRequireDefault(_iterator);\n\t\n\tvar _symbol = __webpack_require__(334);\n\t\n\tvar _symbol2 = _interopRequireDefault(_symbol);\n\t\n\tvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj; };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n\t  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t} : function (obj) {\n\t  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t};\n\n/***/ },\n\n/***/ 341:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(362);\n\t__webpack_require__(361);\n\t__webpack_require__(363);\n\t__webpack_require__(364);\n\tmodule.exports = __webpack_require__(41).Symbol;\n\n/***/ },\n\n/***/ 342:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(119);\n\t__webpack_require__(120);\n\tmodule.exports = __webpack_require__(117).f('iterator');\n\n/***/ },\n\n/***/ 347:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar getKeys = __webpack_require__(51)\n\t  , gOPS    = __webpack_require__(112)\n\t  , pIE     = __webpack_require__(88);\n\tmodule.exports = function(it){\n\t  var result     = getKeys(it)\n\t    , getSymbols = gOPS.f;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = pIE.f\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n\t  } return result;\n\t};\n\n/***/ },\n\n/***/ 348:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(106);\n\tmodule.exports = Array.isArray || function isArray(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n\n/***/ 349:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(51)\n\t  , toIObject = __webpack_require__(44);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n\n/***/ 350:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar META     = __webpack_require__(74)('meta')\n\t  , isObject = __webpack_require__(86)\n\t  , has      = __webpack_require__(35)\n\t  , setDesc  = __webpack_require__(43).f\n\t  , id       = 0;\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\tvar FREEZE = !__webpack_require__(57)(function(){\n\t  return isExtensible(Object.preventExtensions({}));\n\t});\n\tvar setMeta = function(it){\n\t  setDesc(it, META, {value: {\n\t    i: 'O' + ++id, // object ID\n\t    w: {}          // weak collections IDs\n\t  }});\n\t};\n\tvar fastKey = function(it, create){\n\t  // return primitive with prefix\n\t  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return 'F';\n\t    // not necessary to add metadata\n\t    if(!create)return 'E';\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return object ID\n\t  } return it[META].i;\n\t};\n\tvar getWeak = function(it, create){\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return true;\n\t    // not necessary to add metadata\n\t    if(!create)return false;\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return hash weak collections IDs\n\t  } return it[META].w;\n\t};\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function(it){\n\t  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n\t  return it;\n\t};\n\tvar meta = module.exports = {\n\t  KEY:      META,\n\t  NEED:     false,\n\t  fastKey:  fastKey,\n\t  getWeak:  getWeak,\n\t  onFreeze: onFreeze\n\t};\n\n/***/ },\n\n/***/ 352:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pIE            = __webpack_require__(88)\n\t  , createDesc     = __webpack_require__(72)\n\t  , toIObject      = __webpack_require__(44)\n\t  , toPrimitive    = __webpack_require__(115)\n\t  , has            = __webpack_require__(35)\n\t  , IE8_DOM_DEFINE = __webpack_require__(142)\n\t  , gOPD           = Object.getOwnPropertyDescriptor;\n\t\n\texports.f = __webpack_require__(50) ? gOPD : function getOwnPropertyDescriptor(O, P){\n\t  O = toIObject(O);\n\t  P = toPrimitive(P, true);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return gOPD(O, P);\n\t  } catch(e){ /* empty */ }\n\t  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n\t};\n\n/***/ },\n\n/***/ 353:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(44)\n\t  , gOPN      = __webpack_require__(144).f\n\t  , toString  = {}.toString;\n\t\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\t\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return gOPN(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\t\n\tmodule.exports.f = function getOwnPropertyNames(it){\n\t  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n\t};\n\n\n/***/ },\n\n/***/ 361:\n/***/ function(module, exports) {\n\n\n\n/***/ },\n\n/***/ 362:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar global         = __webpack_require__(25)\n\t  , has            = __webpack_require__(35)\n\t  , DESCRIPTORS    = __webpack_require__(50)\n\t  , $export        = __webpack_require__(69)\n\t  , redefine       = __webpack_require__(89)\n\t  , META           = __webpack_require__(350).KEY\n\t  , $fails         = __webpack_require__(57)\n\t  , shared         = __webpack_require__(90)\n\t  , setToStringTag = __webpack_require__(58)\n\t  , uid            = __webpack_require__(74)\n\t  , wks            = __webpack_require__(20)\n\t  , wksExt         = __webpack_require__(117)\n\t  , wksDefine      = __webpack_require__(116)\n\t  , keyOf          = __webpack_require__(349)\n\t  , enumKeys       = __webpack_require__(347)\n\t  , isArray        = __webpack_require__(348)\n\t  , anObject       = __webpack_require__(49)\n\t  , toIObject      = __webpack_require__(44)\n\t  , toPrimitive    = __webpack_require__(115)\n\t  , createDesc     = __webpack_require__(72)\n\t  , _create        = __webpack_require__(87)\n\t  , gOPNExt        = __webpack_require__(353)\n\t  , $GOPD          = __webpack_require__(352)\n\t  , $DP            = __webpack_require__(43)\n\t  , $keys          = __webpack_require__(51)\n\t  , gOPD           = $GOPD.f\n\t  , dP             = $DP.f\n\t  , gOPN           = gOPNExt.f\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , PROTOTYPE      = 'prototype'\n\t  , HIDDEN         = wks('_hidden')\n\t  , TO_PRIMITIVE   = wks('toPrimitive')\n\t  , isEnum         = {}.propertyIsEnumerable\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , OPSymbols      = shared('op-symbols')\n\t  , ObjectProto    = Object[PROTOTYPE]\n\t  , USE_NATIVE     = typeof $Symbol == 'function'\n\t  , QObject        = global.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\t\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(dP({}, 'a', {\n\t    get: function(){ return dP(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = gOPD(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  dP(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n\t} : dP;\n\t\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\t  sym._k = tag;\n\t  return sym;\n\t};\n\t\n\tvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n\t  return typeof it == 'symbol';\n\t} : function(it){\n\t  return it instanceof $Symbol;\n\t};\n\t\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n\t  anObject(it);\n\t  key = toPrimitive(key, true);\n\t  anObject(D);\n\t  if(has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return dP(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key = toPrimitive(key, true));\n\t  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  it  = toIObject(it);\n\t  key = toPrimitive(key, true);\n\t  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n\t  var D = gOPD(it, key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = gOPN(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n\t  } return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var IS_OP  = it === ObjectProto\n\t    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n\t  } return result;\n\t};\n\t\n\t// 19.4.1.1 Symbol([description])\n\tif(!USE_NATIVE){\n\t  $Symbol = function Symbol(){\n\t    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n\t    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\t    var $set = function(value){\n\t      if(this === ObjectProto)$set.call(OPSymbols, value);\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    };\n\t    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n\t    return wrap(tag);\n\t  };\n\t  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n\t    return this._k;\n\t  });\n\t\n\t  $GOPD.f = $getOwnPropertyDescriptor;\n\t  $DP.f   = $defineProperty;\n\t  __webpack_require__(144).f = gOPNExt.f = $getOwnPropertyNames;\n\t  __webpack_require__(88).f  = $propertyIsEnumerable;\n\t  __webpack_require__(112).f = $getOwnPropertySymbols;\n\t\n\t  if(DESCRIPTORS && !__webpack_require__(71)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t\n\t  wksExt.f = function(name){\n\t    return wrap(wks(name));\n\t  }\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\t\n\tfor(var symbols = (\n\t  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\t\n\tfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n\t    throw TypeError(key + ' is not a symbol!');\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t});\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\t\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t})), 'JSON', {\n\t  stringify: function stringify(it){\n\t    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t    var args = [it]\n\t      , i    = 1\n\t      , replacer, $replacer;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    replacer = args[1];\n\t    if(typeof replacer == 'function')$replacer = replacer;\n\t    if($replacer || !isArray(replacer))replacer = function(key, value){\n\t      if($replacer)value = $replacer.call(this, key, value);\n\t      if(!isSymbol(value))return value;\n\t    };\n\t    args[1] = replacer;\n\t    return _stringify.apply($JSON, args);\n\t  }\n\t});\n\t\n\t// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\t$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(36)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n\n/***/ 363:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(116)('asyncIterator');\n\n/***/ },\n\n/***/ 364:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(116)('observable');\n\n/***/ },\n\n/***/ 367:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".card.app--terminal{background:transparent}.card.app--terminal .card-header{background-color:#fff}.card.app--terminal .card-content{background-color:rgba(0,0,0,.75);min-height:15em;max-height:20em;overflow-y:auto}.card.app--terminal .terminal--output{overflow-y:auto}.card.app--terminal .terminal--output ul{list-style:none;margin-top:0}.card.app--terminal .terminal--input .control.has-icon .input:focus+.fa,.card.app--terminal .terminal--input .control.has-icon .textarea:focus+.fa{color:#1fc8db}.card.app--terminal .terminal--input input{background-color:unset;color:#1fc8db;border:unset}.card.app--terminal.is-fullwidth .card-content{height:90%;overflow-y:auto;min-height:unset;max-height:unset}.card.app--terminal.is-fullwidth .content{height:90%}.card.app--terminal.is-fullwidth .terminal--output{min-height:unset}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/apps/terminal/terminal.vue\"],\"names\":[],\"mappings\":\"AAAA,oBAAoB,sBAAsB,CAAC,iCAAiC,qBAAqB,CAAC,kCAAkC,iCAAkC,gBAAgB,gBAAgB,eAAe,CAAC,sCAAsC,eAAe,CAAC,yCAAyC,gBAAgB,YAAc,CAAC,mJAAmJ,aAAa,CAAC,2CAA2C,uBAAuB,cAAc,YAAY,CAAC,+CAA+C,WAAW,gBAAgB,iBAAiB,gBAAgB,CAAC,0CAA0C,UAAU,CAAC,mDAAmD,gBAAgB,CAAC\",\"file\":\"terminal.vue\",\"sourcesContent\":[\".card.app--terminal{background:transparent}.card.app--terminal .card-header{background-color:#fff}.card.app--terminal .card-content{background-color:rgba(0,0,0,0.75);min-height:15em;max-height:20em;overflow-y:auto}.card.app--terminal .terminal--output{overflow-y:auto}.card.app--terminal .terminal--output ul{list-style:none;margin-top:0em}.card.app--terminal .terminal--input .control.has-icon .input:focus+.fa,.card.app--terminal .terminal--input .control.has-icon .textarea:focus+.fa{color:#1fc8db}.card.app--terminal .terminal--input input{background-color:unset;color:#1fc8db;border:unset}.card.app--terminal.is-fullwidth .card-content{height:90%;overflow-y:auto;min-height:unset;max-height:unset}.card.app--terminal.is-fullwidth .content{height:90%}.card.app--terminal.is-fullwidth .terminal--output{min-height:unset}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 378:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(367);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(14)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js?sourceMap!./../../../../node_modules/vue-loader/lib/style-rewriter.js!./../../../../node_modules/sass-loader/index.js?indentedSyntax&sourceMap!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./terminal.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js?sourceMap!./../../../../node_modules/vue-loader/lib/style-rewriter.js!./../../../../node_modules/sass-loader/index.js?indentedSyntax&sourceMap!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./terminal.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 751:\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <w-app title=Terminal class=\\\"app--terminal animated fadeInDown\\\" :has-sub-nav=true @keyup.up=\\\"monitorKeys('up')\\\" @keyup.down=\\\"monitorKeys('down')\\\" @click=giveFocus> <nav slot=header> <p class=panel-tabs> <a @click=\\\"openNew('terminal')\\\" class=\\\"\\\" href=#>New</a> </p> </nav> <div class=terminal--output> <div class=terminal--result v-if=\\\"results.length > 0\\\" v-for=\\\"(idx, result) in results\\\" track-by=$index> <span>$ {{ result.command }}</span> <ul v-if=\\\"result.dataType === 'list'\\\"> <li v-for=\\\"(x, item) in result.data\\\" track-by=$index>{{item}}</li> </ul> <span v-else><br/>{{result.data}}</span> </div> </div> <form @submit.prevent=runCommand class=terminal--input> <p class=\\\"control has-icon\\\"> <input class=input type=text v-model=command placeholder=\\\"\\\" autofocus> <i class=\\\"fa fa-dollar\\\"></i> </p> </form> </w-app> \";\n\n/***/ },\n\n/***/ 764:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(378)\n\t__vue_script__ = __webpack_require__(324)\n\t__vue_template__ = __webpack_require__(751)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** static/js/2.86b1f5685590fdb01722.js\n **/","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks.js\n ** module id = 20\n ** module chunks = 2 3\n **/","<template>\n  <div class=\"w-app card\"\n    v-bind:class=\"[loading ? 'isLoading': '', isDeleted ? 'animated zoomOutDown': '', isMax ? 'is-fullwidth' : '']\"     \n    @click=\"bringToFront\"\n    @mousedown=\"bringToFront\"\n    @animationend=\"makeMe\"  \n    draggable='true'\n    tabindex=\"0\">\n    <header class=\"card-header\">\n      <p class=\"card-header-title\">\n        {{title}}\n      </p>\n      <a class=\"card-header-icon\" >\n        <i class=\"fa fa-minus\"></i>\n      </a>\n      <a class=\"card-header-icon\" @click='maxApp'>\n        <i class=\"fa\" v-bind:class=\"[isMax ? 'fa-compress': 'fa-expand']\"></i>\n      </a>\n      <a class=\"card-header-icon\" @click='closeApp'>\n        <i class=\"fa fa-times\"></i>\n      </a>\n    </header>\n    <header v-if='hasSubNav' class='card-header card-header--subnav'>\n      <slot name='header'></slot>\n    </header>\n    <div class=\"card-content\">\n      <div class=\"content\">\n        <slot></slot>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nlet interact = require('interact.js')\ninteract('.w-app header')\n  .draggable({\n    inertia: true,\n    restrict: {\n      restriction: '.bound',\n      endOnly: true,\n      elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n    },\n    autoScroll: true,\n    onmove: dragMoveListener,\n    // call this function on every dragend event\n    onend: function (event) {\n    //   var textEl = event.target.querySelector('p')\n\n    //   textEl && (textEl.textContent =\n    //     'moved a distance of ' +\n    //     (Math.sqrt(event.dx * event.dx +\n    //     event.dy * event.dy) | 0) + 'px')\n    }\n  })\n  // .resizable({\n  //   preserveAspectRatio: false,\n  //   edges: { left: true, right: true, bottom: true, top: true }\n  // })\n  // .on('resizemove', function (event) {\n  //   var target = event.target\n  //   var x = (parseFloat(target.getAttribute('data-x')) || 0)\n  //   var y = (parseFloat(target.getAttribute('data-y')) || 0)\n\n  //   // update the element's style\n  //   target.style.width = event.rect.width + 'px'\n  //   target.style.height = event.rect.height + 'px'\n\n  //   // translate when resizing from top or left edges\n  //   x += event.deltaRect.left\n  //   y += event.deltaRect.top\n\n  //   target.style.webkitTransform = target.style.transform =\n  //       'translate(' + x + 'px,' + y + 'px)'\n\n  //   target.setAttribute('data-x', x)\n  //   target.setAttribute('data-y', y)\n  // })\nfunction dragMoveListener (event) {\n  var target = event.target.parentNode\n      // keep the dragged position in the data-x/data-y attributes\n  var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx\n  var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy\n\n  // translate the element\n  target.style.webkitTransform =\n  target.style.transform =\n    'translate(' + x + 'px, ' + y + 'px)'\n  // target.style.zIndex = 1\n  // update the posiion attributes\n  target.setAttribute('data-x', x)\n  target.setAttribute('data-y', y)\n}\nexport default {\n  data () {\n    return {\n      // note: changing this line won't causes changes\n      // with hot-reload because the reloaded component\n      // preserves its current state and we are modifying\n      // its initial state.\n      hasFocus: false,\n      isMax: false,\n      isDeleted: false\n    }\n  },\n  methods: {\n    bringToFront (e) {\n      this.$dispatch('bringToFront', e.currentTarget)\n      this.$dispatch('loseFocus')\n      this.$set('hasFocus', true)\n    },\n    closeApp (e) {\n      this.$set('isDeleted', true)\n      this.$dispatch('closeApp', e)\n    },\n    maxApp (e) {\n      this.$set('isMax', !this.isMax)\n    },\n    makeMe (e) {\n      let target = e.currentTarget\n      if (this.isDeleted) {\n        target.parentNode.removeChild(target)\n      } else {\n        target.classList.remove('animated')\n        target.classList.remove('fadeInDown')\n        this.$dispatch('addMe', target)\n        this.$dispatch('loseFocus')\n        this.$set('hasFocus', true)\n      }\n    }\n  },\n  events: {\n    loseFocus () {\n      this.$set('hasFocus', false)\n    }\n  },\n  props: {\n    title: {\n      type: String,\n      required: true\n    },\n    loading: {\n      type: Boolean\n    },\n    hasSubNav: {\n      type: Boolean,\n      default: false,\n      required: true\n    }\n  }\n}\n</script>\n<style lang='css' scoped>\n  .w-app {\n    position: absolute;\n\t  color: #FFF;\n    top: 100px;\n    left: 100px;\n    box-shadow: 0px 0px 5px black;\n    z-index: 0;\n    .card-header {\n      cursor: move;\n    }\n    transition: 1s background ease-in-out;\n  }\n  .card-header .card-header-icon {\n    width: 24px;\n    color: #42afe3;\n  }\n  .card-content {\n    width: unset;\n  }\n  .is-fullwidth {\n    transform: translate(-100px, -44px) !important;\n    height: 93%;\n    .card-content {\n      height: 100%;\n      overflow-y: auto;\n    }\n  }\n  .isLoading {\n    background-color: #c3c3c3;\n  }\n</style>\n\n<style>\n  .card-header--subnav .panel-tabs a {\n    color: #42afe3;\n  }\n</style>\n\n\n/** WEBPACK FOOTER **\n ** wApp.vue?464ab078\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".card-header--subnav .panel-tabs a{color:#42afe3}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/wApp.vue\"],\"names\":[],\"mappings\":\"AA0LA,mCACE,aAAe,CAChB\",\"file\":\"wApp.vue\",\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n.card-header--subnav .panel-tabs a {\\n  color: #42afe3;\\n}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js!./~/vue-loader/lib/selector.js?type=style&index=1!./src/components/wApp.vue\n ** module id = 26\n ** module chunks = 0 1 2 3 4 5\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".w-app[_v-ca6846e8]{position:absolute;color:#fff;top:100px;left:100px;box-shadow:0 0 5px #000;z-index:0;.card-header{cursor:move}-webkit-transition:background 1s ease-in-out;transition:background 1s ease-in-out}.card-header .card-header-icon[_v-ca6846e8]{width:24px;color:#42afe3}.card-content[_v-ca6846e8]{width:unset}.is-fullwidth[_v-ca6846e8]{-webkit-transform:translate(-100px,-44px)!important;transform:translate(-100px,-44px)!important;height:93%;.card-content{height:100%;overflow-y:auto}}.isLoading[_v-ca6846e8]{background-color:#c3c3c3}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/wApp.vue\"],\"names\":[],\"mappings\":\"AAyJE,oBACE,kBAAmB,AACpB,WAAY,AACX,UAAW,AACX,WAAY,AACZ,wBAA8B,AAC9B,UAAW,AACX,aACE,WAAa,CACd,AACD,6CAA8C,AAC9C,oCAAsC,CACvC,AACD,4CACE,WAAY,AACZ,aAAe,CAChB,AACD,2BACE,WAAa,CACd,AACD,2BACE,oDAAuD,AAC/C,4CAA+C,AACvD,WAAY,AACZ,cACE,YAAa,AACb,eAAiB,CAClB,CACF,AACD,wBACE,wBAA0B,CAC3B\",\"file\":\"wApp.vue\",\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  .w-app[_v-ca6846e8] {\\n    position: absolute;\\n\\t  color: #FFF;\\n    top: 100px;\\n    left: 100px;\\n    box-shadow: 0px 0px 5px black;\\n    z-index: 0;\\n    .card-header {\\n      cursor: move;\\n    }\\n    -webkit-transition: 1s background ease-in-out;\\n    transition: 1s background ease-in-out;\\n  }\\n  .card-header .card-header-icon[_v-ca6846e8] {\\n    width: 24px;\\n    color: #42afe3;\\n  }\\n  .card-content[_v-ca6846e8] {\\n    width: unset;\\n  }\\n  .is-fullwidth[_v-ca6846e8] {\\n    -webkit-transform: translate(-100px, -44px) !important;\\n            transform: translate(-100px, -44px) !important;\\n    height: 93%;\\n    .card-content {\\n      height: 100%;\\n      overflow-y: auto;\\n    }\\n  }\\n  .isLoading[_v-ca6846e8] {\\n    background-color: #c3c3c3;\\n  }\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/wApp.vue\n ** module id = 27\n ** module chunks = 0 1 2 3 4 5\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js!./~/vue-loader/lib/selector.js?type=style&index=1!./src/components/wApp.vue\n ** module id = 28\n ** module chunks = 0 1 2 3 4 5\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/wApp.vue\n ** module id = 29\n ** module chunks = 0 1 2 3 4 5\n **/","/**\n * interact.js v1.2.6\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function (realWindow) {\n    'use strict';\n\n    // return early if there's no window to work with (eg. Node.js)\n    if (!realWindow) { return; }\n\n    var // get wrapped window if using Shadow DOM polyfill\n        window = (function () {\n            // create a TextNode\n            var el = realWindow.document.createTextNode('');\n\n            // check if it's wrapped by a polyfill\n            if (el.ownerDocument !== realWindow.document\n                && typeof realWindow.wrap === 'function'\n                && realWindow.wrap(el) === el) {\n                // return wrapped window\n                return realWindow.wrap(realWindow);\n            }\n\n            // no Shadow DOM polyfil or native implementation\n            return realWindow;\n        }()),\n\n        document           = window.document,\n        DocumentFragment   = window.DocumentFragment   || blank,\n        SVGElement         = window.SVGElement         || blank,\n        SVGSVGElement      = window.SVGSVGElement      || blank,\n        SVGElementInstance = window.SVGElementInstance || blank,\n        HTMLElement        = window.HTMLElement        || window.Element,\n\n        PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n        pEventTypes,\n\n        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\n        tmpXY = {},     // reduce object creation in getXY()\n\n        documents       = [],   // all documents being listened to\n\n        interactables   = [],   // all set interactables\n        interactions    = [],   // all interactions\n\n        dynamicDrop     = false,\n\n        // {\n        //      type: {\n        //          selectors: ['selector', ...],\n        //          contexts : [document, ...],\n        //          listeners: [[listener, useCapture], ...]\n        //      }\n        //  }\n        delegatedEvents = {},\n\n        defaultOptions = {\n            base: {\n                accept        : null,\n                actionChecker : null,\n                styleCursor   : true,\n                preventDefault: 'auto',\n                origin        : { x: 0, y: 0 },\n                deltaSource   : 'page',\n                allowFrom     : null,\n                ignoreFrom    : null,\n                _context      : document,\n                dropChecker   : null\n            },\n\n            drag: {\n                enabled: false,\n                manualStart: true,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                axis: 'xy'\n            },\n\n            drop: {\n                enabled: false,\n                accept: null,\n                overlap: 'pointer'\n            },\n\n            resize: {\n                enabled: false,\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                square: false,\n                preserveAspectRatio: false,\n                axis: 'xy',\n\n                // use default margin\n                margin: NaN,\n\n                // object with props left, right, top, bottom which are\n                // true/false values to resize when the pointer is over that edge,\n                // CSS selectors to match the handles for each direction\n                // or the Elements for each handle\n                edges: null,\n\n                // a value of 'none' will limit the resize rect to a minimum of 0x0\n                // 'negate' will alow the rect to have negative width/height\n                // 'reposition' will keep the width/height positive by swapping\n                // the top and bottom edges and/or swapping the left and right edges\n                invert: 'none'\n            },\n\n            gesture: {\n                manualStart: false,\n                enabled: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                restrict: null\n            },\n\n            perAction: {\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: {\n                    enabled     : false,\n                    endOnly     : false,\n                    range       : Infinity,\n                    targets     : null,\n                    offsets     : null,\n\n                    relativePoints: null\n                },\n\n                restrict: {\n                    enabled: false,\n                    endOnly: false\n                },\n\n                autoScroll: {\n                    enabled     : false,\n                    container   : null,     // the item that is scrolled (Window or HTMLElement)\n                    margin      : 60,\n                    speed       : 300       // the scroll speed in pixels per second\n                },\n\n                inertia: {\n                    enabled          : false,\n                    resistance       : 10,    // the lambda in exponential decay\n                    minSpeed         : 100,   // target speed must be above this for inertia to start\n                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n                    allowResume      : true,  // allow resuming an action in inertia phase\n                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n                }\n            },\n\n            _holdDuration: 600\n        },\n\n        // Things related to autoScroll\n        autoScroll = {\n            interaction: null,\n            i: null,    // the handle returned by window.setInterval\n            x: 0, y: 0, // Direction each pulse is to scroll in\n\n            // scroll the window by the values in scroll.x/y\n            scroll: function () {\n                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n                    container = options.container || getWindow(autoScroll.interaction.element),\n                    now = new Date().getTime(),\n                    // change in time in seconds\n                    dtx = (now - autoScroll.prevTimeX) / 1000,\n                    dty = (now - autoScroll.prevTimeY) / 1000,\n                    vx, vy, sx, sy;\n\n                // displacement\n                if (options.velocity) {\n                  vx = options.velocity.x;\n                  vy = options.velocity.y;\n                }\n                else {\n                  vx = vy = options.speed\n                }\n \n                sx = vx * dtx;\n                sy = vy * dty;\n\n                if (sx >= 1 || sy >= 1) {\n                    if (isWindow(container)) {\n                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n                    }\n                    else if (container) {\n                        container.scrollLeft += autoScroll.x * sx;\n                        container.scrollTop  += autoScroll.y * sy;\n                    }\n\n                    if (sx >=1) autoScroll.prevTimeX = now;\n                    if (sy >= 1) autoScroll.prevTimeY = now;\n                }\n\n                if (autoScroll.isScrolling) {\n                    cancelFrame(autoScroll.i);\n                    autoScroll.i = reqFrame(autoScroll.scroll);\n                }\n            },\n\n            isScrolling: false,\n            prevTimeX: 0,\n            prevTimeY: 0,\n\n            start: function (interaction) {\n                autoScroll.isScrolling = true;\n                cancelFrame(autoScroll.i);\n\n                autoScroll.interaction = interaction;\n                autoScroll.prevTimeX = new Date().getTime();\n                autoScroll.prevTimeY = new Date().getTime();\n                autoScroll.i = reqFrame(autoScroll.scroll);\n            },\n\n            stop: function () {\n                autoScroll.isScrolling = false;\n                cancelFrame(autoScroll.i);\n            }\n        },\n\n        // Does the browser support touch input?\n        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\n        // Does the browser support PointerEvents\n        supportsPointerEvent = !!PointerEvent,\n\n        // Less Precision with touch input\n        margin = supportsTouch || supportsPointerEvent? 20: 10,\n\n        pointerMoveTolerance = 1,\n\n        // for ignoring browser's simulated mouse events\n        prevTouchTime = 0,\n\n        // Allow this many interactions to happen simultaneously\n        maxInteractions = Infinity,\n\n        // Check if is IE9 or older\n        actionCursors = (document.all && !window.atob) ? {\n            drag    : 'move',\n            resizex : 'e-resize',\n            resizey : 's-resize',\n            resizexy: 'se-resize',\n\n            resizetop        : 'n-resize',\n            resizeleft       : 'w-resize',\n            resizebottom     : 's-resize',\n            resizeright      : 'e-resize',\n            resizetopleft    : 'se-resize',\n            resizebottomright: 'se-resize',\n            resizetopright   : 'ne-resize',\n            resizebottomleft : 'ne-resize',\n\n            gesture : ''\n        } : {\n            drag    : 'move',\n            resizex : 'ew-resize',\n            resizey : 'ns-resize',\n            resizexy: 'nwse-resize',\n\n            resizetop        : 'ns-resize',\n            resizeleft       : 'ew-resize',\n            resizebottom     : 'ns-resize',\n            resizeright      : 'ew-resize',\n            resizetopleft    : 'nwse-resize',\n            resizebottomright: 'nwse-resize',\n            resizetopright   : 'nesw-resize',\n            resizebottomleft : 'nesw-resize',\n\n            gesture : ''\n        },\n\n        actionIsEnabled = {\n            drag   : true,\n            resize : true,\n            gesture: true\n        },\n\n        // because Webkit and Opera still use 'mousewheel' event type\n        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\n        eventTypes = [\n            'dragstart',\n            'dragmove',\n            'draginertiastart',\n            'dragend',\n            'dragenter',\n            'dragleave',\n            'dropactivate',\n            'dropdeactivate',\n            'dropmove',\n            'drop',\n            'resizestart',\n            'resizemove',\n            'resizeinertiastart',\n            'resizeend',\n            'gesturestart',\n            'gesturemove',\n            'gestureinertiastart',\n            'gestureend',\n\n            'down',\n            'move',\n            'up',\n            'cancel',\n            'tap',\n            'doubletap',\n            'hold'\n        ],\n\n        globalEvents = {},\n\n        // Opera Mobile must be handled differently\n        isOperaMobile = navigator.appName == 'Opera' &&\n            supportsTouch &&\n            navigator.userAgent.match('Presto'),\n\n        // scrolling doesn't change the result of getClientRects on iOS 7\n        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n                         && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n        // prefix matchesSelector\n        prefixedMatchesSelector = 'matches' in Element.prototype?\n                'matches': 'webkitMatchesSelector' in Element.prototype?\n                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n                            'oMatchesSelector': 'msMatchesSelector',\n\n        // will be polyfill function if browser is IE8\n        ie8MatchesSelector,\n\n        // native requestAnimationFrame or polyfill\n        reqFrame = realWindow.requestAnimationFrame,\n        cancelFrame = realWindow.cancelAnimationFrame,\n\n        // Events wrapper\n        events = (function () {\n            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n                on             = useAttachEvent? 'on': '',\n\n                elements          = [],\n                targets           = [],\n                attachedListeners = [];\n\n            function add (element, type, listener, useCapture) {\n                var elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex];\n\n                if (!target) {\n                    target = {\n                        events: {},\n                        typeCount: 0\n                    };\n\n                    elementIndex = elements.push(element) - 1;\n                    targets.push(target);\n\n                    attachedListeners.push((useAttachEvent ? {\n                            supplied: [],\n                            wrapped : [],\n                            useCount: []\n                        } : null));\n                }\n\n                if (!target.events[type]) {\n                    target.events[type] = [];\n                    target.typeCount++;\n                }\n\n                if (!contains(target.events[type], listener)) {\n                    var ret;\n\n                    if (useAttachEvent) {\n                        var listeners = attachedListeners[elementIndex],\n                            listenerIndex = indexOf(listeners.supplied, listener);\n\n                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n                            if (!event.immediatePropagationStopped) {\n                                event.target = event.srcElement;\n                                event.currentTarget = element;\n\n                                event.preventDefault = event.preventDefault || preventDef;\n                                event.stopPropagation = event.stopPropagation || stopProp;\n                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n                                if (/mouse|click/.test(event.type)) {\n                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n                                }\n\n                                listener(event);\n                            }\n                        };\n\n                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\n                        if (listenerIndex === -1) {\n                            listeners.supplied.push(listener);\n                            listeners.wrapped.push(wrapped);\n                            listeners.useCount.push(1);\n                        }\n                        else {\n                            listeners.useCount[listenerIndex]++;\n                        }\n                    }\n                    else {\n                        ret = element[addEvent](type, listener, useCapture || false);\n                    }\n                    target.events[type].push(listener);\n\n                    return ret;\n                }\n            }\n\n            function remove (element, type, listener, useCapture) {\n                var i,\n                    elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex],\n                    listeners,\n                    listenerIndex,\n                    wrapped = listener;\n\n                if (!target || !target.events) {\n                    return;\n                }\n\n                if (useAttachEvent) {\n                    listeners = attachedListeners[elementIndex];\n                    listenerIndex = indexOf(listeners.supplied, listener);\n                    wrapped = listeners.wrapped[listenerIndex];\n                }\n\n                if (type === 'all') {\n                    for (type in target.events) {\n                        if (target.events.hasOwnProperty(type)) {\n                            remove(element, type, 'all');\n                        }\n                    }\n                    return;\n                }\n\n                if (target.events[type]) {\n                    var len = target.events[type].length;\n\n                    if (listener === 'all') {\n                        for (i = 0; i < len; i++) {\n                            remove(element, type, target.events[type][i], Boolean(useCapture));\n                        }\n                        return;\n                    } else {\n                        for (i = 0; i < len; i++) {\n                            if (target.events[type][i] === listener) {\n                                element[removeEvent](on + type, wrapped, useCapture || false);\n                                target.events[type].splice(i, 1);\n\n                                if (useAttachEvent && listeners) {\n                                    listeners.useCount[listenerIndex]--;\n                                    if (listeners.useCount[listenerIndex] === 0) {\n                                        listeners.supplied.splice(listenerIndex, 1);\n                                        listeners.wrapped.splice(listenerIndex, 1);\n                                        listeners.useCount.splice(listenerIndex, 1);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n                    }\n\n                    if (target.events[type] && target.events[type].length === 0) {\n                        target.events[type] = null;\n                        target.typeCount--;\n                    }\n                }\n\n                if (!target.typeCount) {\n                    targets.splice(elementIndex, 1);\n                    elements.splice(elementIndex, 1);\n                    attachedListeners.splice(elementIndex, 1);\n                }\n            }\n\n            function preventDef () {\n                this.returnValue = false;\n            }\n\n            function stopProp () {\n                this.cancelBubble = true;\n            }\n\n            function stopImmProp () {\n                this.cancelBubble = true;\n                this.immediatePropagationStopped = true;\n            }\n\n            return {\n                add: add,\n                remove: remove,\n                useAttachEvent: useAttachEvent,\n\n                _elements: elements,\n                _targets: targets,\n                _attachedListeners: attachedListeners\n            };\n        }());\n\n    function blank () {}\n\n    function isElement (o) {\n        if (!o || (typeof o !== 'object')) { return false; }\n\n        var _window = getWindow(o) || window;\n\n        return (/object|function/.test(typeof _window.Element)\n            ? o instanceof _window.Element //DOM2\n            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n    }\n    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n    function isArray (thing) {\n        return isObject(thing)\n                && (typeof thing.length !== undefined)\n                && isFunction(thing.splice);\n    }\n    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n    function isFunction (thing) { return typeof thing === 'function'; }\n    function isNumber   (thing) { return typeof thing === 'number'  ; }\n    function isBool     (thing) { return typeof thing === 'boolean' ; }\n    function isString   (thing) { return typeof thing === 'string'  ; }\n\n    function trySelector (value) {\n        if (!isString(value)) { return false; }\n\n        // an exception will be raised if it is invalid\n        document.querySelector(value);\n        return true;\n    }\n\n    function extend (dest, source) {\n        for (var prop in source) {\n            dest[prop] = source[prop];\n        }\n        return dest;\n    }\n\n    var prefixedPropREs = {\n      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n    };\n\n    function pointerExtend (dest, source) {\n        for (var prop in source) {\n          var deprecated = false;\n\n          // skip deprecated prefixed properties\n          for (var vendor in prefixedPropREs) {\n            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n              deprecated = true;\n              break;\n            }\n          }\n\n          if (!deprecated) {\n            dest[prop] = source[prop];\n          }\n        }\n        return dest;\n    }\n\n    function copyCoords (dest, src) {\n        dest.page = dest.page || {};\n        dest.page.x = src.page.x;\n        dest.page.y = src.page.y;\n\n        dest.client = dest.client || {};\n        dest.client.x = src.client.x;\n        dest.client.y = src.client.y;\n\n        dest.timeStamp = src.timeStamp;\n    }\n\n    function setEventXY (targetObj, pointers, interaction) {\n        var pointer = (pointers.length > 1\n                       ? pointerAverage(pointers)\n                       : pointers[0]);\n\n        getPageXY(pointer, tmpXY, interaction);\n        targetObj.page.x = tmpXY.x;\n        targetObj.page.y = tmpXY.y;\n\n        getClientXY(pointer, tmpXY, interaction);\n        targetObj.client.x = tmpXY.x;\n        targetObj.client.y = tmpXY.y;\n\n        targetObj.timeStamp = new Date().getTime();\n    }\n\n    function setEventDeltas (targetObj, prev, cur) {\n        targetObj.page.x     = cur.page.x      - prev.page.x;\n        targetObj.page.y     = cur.page.y      - prev.page.y;\n        targetObj.client.x   = cur.client.x    - prev.client.x;\n        targetObj.client.y   = cur.client.y    - prev.client.y;\n        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\n        // set pointer velocity\n        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n        targetObj.page.vx      = targetObj.page.x / dt;\n        targetObj.page.vy      = targetObj.page.y / dt;\n\n        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n        targetObj.client.vx    = targetObj.client.x / dt;\n        targetObj.client.vy    = targetObj.client.y / dt;\n    }\n\n    function isNativePointer (pointer) {\n        return (pointer instanceof window.Event\n            || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n    }\n\n    // Get specified X/Y coords for mouse or event.touches[0]\n    function getXY (type, pointer, xy) {\n        xy = xy || {};\n        type = type || 'page';\n\n        xy.x = pointer[type + 'X'];\n        xy.y = pointer[type + 'Y'];\n\n        return xy;\n    }\n\n    function getPageXY (pointer, page) {\n        page = page || {};\n\n        // Opera Mobile handles the viewport and scrolling oddly\n        if (isOperaMobile && isNativePointer(pointer)) {\n            getXY('screen', pointer, page);\n\n            page.x += window.scrollX;\n            page.y += window.scrollY;\n        }\n        else {\n            getXY('page', pointer, page);\n        }\n\n        return page;\n    }\n\n    function getClientXY (pointer, client) {\n        client = client || {};\n\n        if (isOperaMobile && isNativePointer(pointer)) {\n            // Opera Mobile handles the viewport and scrolling oddly\n            getXY('screen', pointer, client);\n        }\n        else {\n          getXY('client', pointer, client);\n        }\n\n        return client;\n    }\n\n    function getScrollXY (win) {\n        win = win || window;\n        return {\n            x: win.scrollX || win.document.documentElement.scrollLeft,\n            y: win.scrollY || win.document.documentElement.scrollTop\n        };\n    }\n\n    function getPointerId (pointer) {\n        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n    }\n\n    function getActualElement (element) {\n        return (element instanceof SVGElementInstance\n            ? element.correspondingUseElement\n            : element);\n    }\n\n    function getWindow (node) {\n        if (isWindow(node)) {\n            return node;\n        }\n\n        var rootNode = (node.ownerDocument || node);\n\n        return rootNode.defaultView || rootNode.parentWindow || window;\n    }\n\n    function getElementClientRect (element) {\n        var clientRect = (element instanceof SVGElement\n                            ? element.getBoundingClientRect()\n                            : element.getClientRects()[0]);\n\n        return clientRect && {\n            left  : clientRect.left,\n            right : clientRect.right,\n            top   : clientRect.top,\n            bottom: clientRect.bottom,\n            width : clientRect.width || clientRect.right - clientRect.left,\n            height: clientRect.height || clientRect.bottom - clientRect.top\n        };\n    }\n\n    function getElementRect (element) {\n        var clientRect = getElementClientRect(element);\n\n        if (!isIOS7 && clientRect) {\n            var scroll = getScrollXY(getWindow(element));\n\n            clientRect.left   += scroll.x;\n            clientRect.right  += scroll.x;\n            clientRect.top    += scroll.y;\n            clientRect.bottom += scroll.y;\n        }\n\n        return clientRect;\n    }\n\n    function getTouchPair (event) {\n        var touches = [];\n\n        // array of touches is supplied\n        if (isArray(event)) {\n            touches[0] = event[0];\n            touches[1] = event[1];\n        }\n        // an event\n        else {\n            if (event.type === 'touchend') {\n                if (event.touches.length === 1) {\n                    touches[0] = event.touches[0];\n                    touches[1] = event.changedTouches[0];\n                }\n                else if (event.touches.length === 0) {\n                    touches[0] = event.changedTouches[0];\n                    touches[1] = event.changedTouches[1];\n                }\n            }\n            else {\n                touches[0] = event.touches[0];\n                touches[1] = event.touches[1];\n            }\n        }\n\n        return touches;\n    }\n\n    function pointerAverage (pointers) {\n        var average = {\n            pageX  : 0,\n            pageY  : 0,\n            clientX: 0,\n            clientY: 0,\n            screenX: 0,\n            screenY: 0\n        };\n        var prop;\n\n        for (var i = 0; i < pointers.length; i++) {\n            for (prop in average) {\n                average[prop] += pointers[i][prop];\n            }\n        }\n        for (prop in average) {\n            average[prop] /= pointers.length;\n        }\n\n        return average;\n    }\n\n    function touchBBox (event) {\n        if (!event.length && !(event.touches && event.touches.length > 1)) {\n            return;\n        }\n\n        var touches = getTouchPair(event),\n            minX = Math.min(touches[0].pageX, touches[1].pageX),\n            minY = Math.min(touches[0].pageY, touches[1].pageY),\n            maxX = Math.max(touches[0].pageX, touches[1].pageX),\n            maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n        return {\n            x: minX,\n            y: minY,\n            left: minX,\n            top: minY,\n            width: maxX - minX,\n            height: maxY - minY\n        };\n    }\n\n    function touchDistance (event, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event);\n\n\n        var dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY];\n\n        return hypot(dx, dy);\n    }\n\n    function touchAngle (event, prevAngle, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event),\n            dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY],\n            angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n        if (isNumber(prevAngle)) {\n            var dr = angle - prevAngle,\n                drClamped = dr % 360;\n\n            if (drClamped > 315) {\n                angle -= 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped > 135) {\n                angle -= 180 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -315) {\n                angle += 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -135) {\n                angle += 180 + (angle / 360)|0 * 360;\n            }\n        }\n\n        return  angle;\n    }\n\n    function getOriginXY (interactable, element) {\n        var origin = interactable\n                ? interactable.options.origin\n                : defaultOptions.origin;\n\n        if (origin === 'parent') {\n            origin = parentElement(element);\n        }\n        else if (origin === 'self') {\n            origin = interactable.getRect(element);\n        }\n        else if (trySelector(origin)) {\n            origin = closest(element, origin) || { x: 0, y: 0 };\n        }\n\n        if (isFunction(origin)) {\n            origin = origin(interactable && element);\n        }\n\n        if (isElement(origin))  {\n            origin = getElementRect(origin);\n        }\n\n        origin.x = ('x' in origin)? origin.x : origin.left;\n        origin.y = ('y' in origin)? origin.y : origin.top;\n\n        return origin;\n    }\n\n    // http://stackoverflow.com/a/5634528/2280888\n    function _getQBezierValue(t, p1, p2, p3) {\n        var iT = 1 - t;\n        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n    }\n\n    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n        return {\n            x:  _getQBezierValue(position, startX, cpX, endX),\n            y:  _getQBezierValue(position, startY, cpY, endY)\n        };\n    }\n\n    // http://gizma.com/easing/\n    function easeOutQuad (t, b, c, d) {\n        t /= d;\n        return -c * t*(t-2) + b;\n    }\n\n    function nodeContains (parent, child) {\n        while (child) {\n            if (child === parent) {\n                return true;\n            }\n\n            child = child.parentNode;\n        }\n\n        return false;\n    }\n\n    function closest (child, selector) {\n        var parent = parentElement(child);\n\n        while (isElement(parent)) {\n            if (matchesSelector(parent, selector)) { return parent; }\n\n            parent = parentElement(parent);\n        }\n\n        return null;\n    }\n\n    function parentElement (node) {\n        var parent = node.parentNode;\n\n        if (isDocFrag(parent)) {\n            // skip past #shado-root fragments\n            while ((parent = parent.host) && isDocFrag(parent)) {}\n\n            return parent;\n        }\n\n        return parent;\n    }\n\n    function inContext (interactable, element) {\n        return interactable._context === element.ownerDocument\n                || nodeContains(interactable._context, element);\n    }\n\n    function testIgnore (interactable, interactableElement, element) {\n        var ignoreFrom = interactable.options.ignoreFrom;\n\n        if (!ignoreFrom || !isElement(element)) { return false; }\n\n        if (isString(ignoreFrom)) {\n            return matchesUpTo(element, ignoreFrom, interactableElement);\n        }\n        else if (isElement(ignoreFrom)) {\n            return nodeContains(ignoreFrom, element);\n        }\n\n        return false;\n    }\n\n    function testAllow (interactable, interactableElement, element) {\n        var allowFrom = interactable.options.allowFrom;\n\n        if (!allowFrom) { return true; }\n\n        if (!isElement(element)) { return false; }\n\n        if (isString(allowFrom)) {\n            return matchesUpTo(element, allowFrom, interactableElement);\n        }\n        else if (isElement(allowFrom)) {\n            return nodeContains(allowFrom, element);\n        }\n\n        return false;\n    }\n\n    function checkAxis (axis, interactable) {\n        if (!interactable) { return false; }\n\n        var thisAxis = interactable.options.drag.axis;\n\n        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n    }\n\n    function checkSnap (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return options[action].snap && options[action].snap.enabled;\n    }\n\n    function checkRestrict (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].restrict && options[action].restrict.enabled;\n    }\n\n    function checkAutoScroll (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].autoScroll && options[action].autoScroll.enabled;\n    }\n\n    function withinInteractionLimit (interactable, element, action) {\n        var options = interactable.options,\n            maxActions = options[action.name].max,\n            maxPerElement = options[action.name].maxPerElement,\n            activeInteractions = 0,\n            targetCount = 0,\n            targetElementCount = 0;\n\n        for (var i = 0, len = interactions.length; i < len; i++) {\n            var interaction = interactions[i],\n                otherAction = interaction.prepared.name,\n                active = interaction.interacting();\n\n            if (!active) { continue; }\n\n            activeInteractions++;\n\n            if (activeInteractions >= maxInteractions) {\n                return false;\n            }\n\n            if (interaction.target !== interactable) { continue; }\n\n            targetCount += (otherAction === action.name)|0;\n\n            if (targetCount >= maxActions) {\n                return false;\n            }\n\n            if (interaction.element === element) {\n                targetElementCount++;\n\n                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n                    return false;\n                }\n            }\n        }\n\n        return maxInteractions > 0;\n    }\n\n    // Test for the element that's \"above\" all other qualifiers\n    function indexOfDeepestElement (elements) {\n        var dropzone,\n            deepestZone = elements[0],\n            index = deepestZone? 0: -1,\n            parent,\n            deepestZoneParents = [],\n            dropzoneParents = [],\n            child,\n            i,\n            n;\n\n        for (i = 1; i < elements.length; i++) {\n            dropzone = elements[i];\n\n            // an element might belong to multiple selector dropzones\n            if (!dropzone || dropzone === deepestZone) {\n                continue;\n            }\n\n            if (!deepestZone) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            // check if the deepest or current are document.documentElement or document.rootElement\n            // - if the current dropzone is, do nothing and continue\n            if (dropzone.parentNode === dropzone.ownerDocument) {\n                continue;\n            }\n            // - if deepest is, update with the current dropzone and continue to next\n            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            if (!deepestZoneParents.length) {\n                parent = deepestZone;\n                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n                    deepestZoneParents.unshift(parent);\n                    parent = parent.parentNode;\n                }\n            }\n\n            // if this element is an svg element and the current deepest is\n            // an HTMLElement\n            if (deepestZone instanceof HTMLElement\n                && dropzone instanceof SVGElement\n                && !(dropzone instanceof SVGSVGElement)) {\n\n                if (dropzone === deepestZone.parentNode) {\n                    continue;\n                }\n\n                parent = dropzone.ownerSVGElement;\n            }\n            else {\n                parent = dropzone;\n            }\n\n            dropzoneParents = [];\n\n            while (parent.parentNode !== parent.ownerDocument) {\n                dropzoneParents.unshift(parent);\n                parent = parent.parentNode;\n            }\n\n            n = 0;\n\n            // get (position of last common ancestor) + 1\n            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n                n++;\n            }\n\n            var parents = [\n                dropzoneParents[n - 1],\n                dropzoneParents[n],\n                deepestZoneParents[n]\n            ];\n\n            child = parents[0].lastChild;\n\n            while (child) {\n                if (child === parents[1]) {\n                    deepestZone = dropzone;\n                    index = i;\n                    deepestZoneParents = [];\n\n                    break;\n                }\n                else if (child === parents[2]) {\n                    break;\n                }\n\n                child = child.previousSibling;\n            }\n        }\n\n        return index;\n    }\n\n    function Interaction () {\n        this.target          = null; // current interactable being interacted with\n        this.element         = null; // the target element of the interactable\n        this.dropTarget      = null; // the dropzone a drag target might be dropped into\n        this.dropElement     = null; // the element at the time of checking\n        this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n        this.prevDropElement = null; // the element at the time of checking\n\n        this.prepared        = {     // action that's ready to be fired on next move event\n            name : null,\n            axis : null,\n            edges: null\n        };\n\n        this.matches         = [];   // all selectors that are matched by target element\n        this.matchElements   = [];   // corresponding elements\n\n        this.inertiaStatus = {\n            active       : false,\n            smoothEnd    : false,\n            ending       : false,\n\n            startEvent: null,\n            upCoords: {},\n\n            xe: 0, ye: 0,\n            sx: 0, sy: 0,\n\n            t0: 0,\n            vx0: 0, vys: 0,\n            duration: 0,\n\n            resumeDx: 0,\n            resumeDy: 0,\n\n            lambda_v0: 0,\n            one_ve_v0: 0,\n            i  : null\n        };\n\n        if (isFunction(Function.prototype.bind)) {\n            this.boundInertiaFrame = this.inertiaFrame.bind(this);\n            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n        }\n        else {\n            var that = this;\n\n            this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n        }\n\n        this.activeDrops = {\n            dropzones: [],      // the dropzones that are mentioned below\n            elements : [],      // elements of dropzones that accept the target draggable\n            rects    : []       // the rects of the elements mentioned above\n        };\n\n        // keep track of added pointers\n        this.pointers    = [];\n        this.pointerIds  = [];\n        this.downTargets = [];\n        this.downTimes   = [];\n        this.holdTimers  = [];\n\n        // Previous native pointer move event coordinates\n        this.prevCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n        // current native pointer move event coordinates\n        this.curCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Starting InteractEvent pointer coordinates\n        this.startCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Change in coordinates and time of the pointer\n        this.pointerDelta = {\n            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            timeStamp: 0\n        };\n\n        this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n        this.downPointer = {};\n\n        this._eventTarget    = null;\n        this._curEventTarget = null;\n\n        this.prevEvent = null;      // previous action event\n        this.tapTime   = 0;         // time of the most recent tap event\n        this.prevTap   = null;\n\n        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.snapOffsets    = [];\n\n        this.gesture = {\n            start: { x: 0, y: 0 },\n\n            startDistance: 0,   // distance between two touches of touchStart\n            prevDistance : 0,\n            distance     : 0,\n\n            scale: 1,           // gesture.distance / gesture.startDistance\n\n            startAngle: 0,      // angle of line joining two touches\n            prevAngle : 0       // angle of the previous gesture event\n        };\n\n        this.snapStatus = {\n            x       : 0, y       : 0,\n            dx      : 0, dy      : 0,\n            realX   : 0, realY   : 0,\n            snappedX: 0, snappedY: 0,\n            targets : [],\n            locked  : false,\n            changed : false\n        };\n\n        this.restrictStatus = {\n            dx         : 0, dy         : 0,\n            restrictedX: 0, restrictedY: 0,\n            snap       : null,\n            restricted : false,\n            changed    : false\n        };\n\n        this.restrictStatus.snap = this.snapStatus;\n\n        this.pointerIsDown   = false;\n        this.pointerWasMoved = false;\n        this.gesturing       = false;\n        this.dragging        = false;\n        this.resizing        = false;\n        this.resizeAxes      = 'xy';\n\n        this.mouse = false;\n\n        interactions.push(this);\n    }\n\n    Interaction.prototype = {\n        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\n        pointerOver: function (pointer, event, eventTarget) {\n            if (this.prepared.name || !this.mouse) { return; }\n\n            var curMatches = [],\n                curMatchElements = [],\n                prevTargetElement = this.element;\n\n            this.addPointer(pointer);\n\n            if (this.target\n                && (testIgnore(this.target, this.element, eventTarget)\n                    || !testAllow(this.target, this.element, eventTarget))) {\n                // if the eventTarget should be ignored or shouldn't be allowed\n                // clear the previous target\n                this.target = null;\n                this.element = null;\n                this.matches = [];\n                this.matchElements = [];\n            }\n\n            var elementInteractable = interactables.get(eventTarget),\n                elementAction = (elementInteractable\n                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)\n                                 && testAllow(elementInteractable, eventTarget, eventTarget)\n                                 && validateAction(\n                                     elementInteractable.getAction(pointer, event, this, eventTarget),\n                                     elementInteractable));\n\n            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n                 elementAction = null;\n            }\n\n            function pushCurMatches (interactable, selector) {\n                if (interactable\n                    && inContext(interactable, eventTarget)\n                    && !testIgnore(interactable, eventTarget, eventTarget)\n                    && testAllow(interactable, eventTarget, eventTarget)\n                    && matchesSelector(eventTarget, selector)) {\n\n                    curMatches.push(interactable);\n                    curMatchElements.push(eventTarget);\n                }\n            }\n\n            if (elementAction) {\n                this.target = elementInteractable;\n                this.element = eventTarget;\n                this.matches = [];\n                this.matchElements = [];\n            }\n            else {\n                interactables.forEachSelector(pushCurMatches);\n\n                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n                    this.matches = curMatches;\n                    this.matchElements = curMatchElements;\n\n                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n                    events.add(eventTarget,\n                                        PointerEvent? pEventTypes.move : 'mousemove',\n                                        listeners.pointerHover);\n                }\n                else if (this.target) {\n                    if (nodeContains(prevTargetElement, eventTarget)) {\n                        this.pointerHover(pointer, event, this.matches, this.matchElements);\n                        events.add(this.element,\n                                            PointerEvent? pEventTypes.move : 'mousemove',\n                                            listeners.pointerHover);\n                    }\n                    else {\n                        this.target = null;\n                        this.element = null;\n                        this.matches = [];\n                        this.matchElements = [];\n                    }\n                }\n            }\n        },\n\n        // Check what action would be performed on pointerMove target if a mouse\n        // button were pressed and change the cursor accordingly\n        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n            var target = this.target;\n\n            if (!this.prepared.name && this.mouse) {\n\n                var action;\n\n                // update pointer coords for defaultActionChecker to use\n                this.setEventXY(this.curCoords, [pointer]);\n\n                if (matches) {\n                    action = this.validateSelector(pointer, event, matches, matchElements);\n                }\n                else if (target) {\n                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n                }\n\n                if (target && target.options.styleCursor) {\n                    if (action) {\n                        target._doc.documentElement.style.cursor = getActionCursor(action);\n                    }\n                    else {\n                        target._doc.documentElement.style.cursor = '';\n                    }\n                }\n            }\n            else if (this.prepared.name) {\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        pointerOut: function (pointer, event, eventTarget) {\n            if (this.prepared.name) { return; }\n\n            // Remove temporary event listeners for selector Interactables\n            if (!interactables.get(eventTarget)) {\n                events.remove(eventTarget,\n                                       PointerEvent? pEventTypes.move : 'mousemove',\n                                       listeners.pointerHover);\n            }\n\n            if (this.target && this.target.options.styleCursor && !this.interacting()) {\n                this.target._doc.documentElement.style.cursor = '';\n            }\n        },\n\n        selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n            var that = this,\n                // copy event to be used in timeout for IE8\n                eventCopy = events.useAttachEvent? extend({}, event) : event,\n                element = eventTarget,\n                pointerIndex = this.addPointer(pointer),\n                action;\n\n            this.holdTimers[pointerIndex] = setTimeout(function () {\n                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n            }, defaultOptions._holdDuration);\n\n            this.pointerIsDown = true;\n\n            // Check if the down event hits the current inertia target\n            if (this.inertiaStatus.active && this.target.selector) {\n                // climb up the DOM tree from the event target\n                while (isElement(element)) {\n\n                    // if this element is the current inertia target element\n                    if (element === this.element\n                        // and the prospective action is the same as the ongoing one\n                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n                        // stop inertia so that the next move will be a normal one\n                        cancelFrame(this.inertiaStatus.i);\n                        this.inertiaStatus.active = false;\n\n                        this.collectEventTargets(pointer, event, eventTarget, 'down');\n                        return;\n                    }\n                    element = parentElement(element);\n                }\n            }\n\n            // do nothing if interacting\n            if (this.interacting()) {\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n                return;\n            }\n\n            function pushMatches (interactable, selector, context) {\n                var elements = ie8MatchesSelector\n                    ? context.querySelectorAll(selector)\n                    : undefined;\n\n                if (inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, elements)) {\n\n                    that.matches.push(interactable);\n                    that.matchElements.push(element);\n                }\n            }\n\n            // update pointer coords for defaultActionChecker to use\n            this.setEventXY(this.curCoords, [pointer]);\n            this.downEvent = event;\n\n            while (isElement(element) && !action) {\n                this.matches = [];\n                this.matchElements = [];\n\n                interactables.forEachSelector(pushMatches);\n\n                action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n                element = parentElement(element);\n            }\n\n            if (action) {\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\n                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n            }\n            else {\n                // do these now since pointerDown isn't being called from here\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.curCoords);\n                this.pointerWasMoved = false;\n            }\n\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n        },\n\n        // Determine action to be performed on next pointerMove and add appropriate\n        // style and event Listeners\n        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n\n                return;\n            }\n\n            this.pointerIsDown = true;\n            this.downEvent = event;\n\n            var pointerIndex = this.addPointer(pointer),\n                action;\n\n            // If it is the second touch of a multi-touch gesture, keep the\n            // target the same and get a new action if a target was set by the\n            // first touch\n            if (this.pointerIds.length > 1 && this.target._element === this.element) {\n                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n                if (withinInteractionLimit(this.target, this.element, newAction)) {\n                    action = newAction;\n                }\n\n                this.prepared.name = null;\n            }\n            // Otherwise, set the target if there is no action prepared\n            else if (!this.prepared.name) {\n                var interactable = interactables.get(curEventTarget);\n\n                if (interactable\n                    && !testIgnore(interactable, curEventTarget, eventTarget)\n                    && testAllow(interactable, curEventTarget, eventTarget)\n                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n                    && withinInteractionLimit(interactable, curEventTarget, action)) {\n                    this.target = interactable;\n                    this.element = curEventTarget;\n                }\n            }\n\n            var target = this.target,\n                options = target && target.options;\n\n            if (target && (forceAction || !this.prepared.name)) {\n                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n                this.setEventXY(this.startCoords, this.pointers);\n\n                if (!action) { return; }\n\n                if (options.styleCursor) {\n                    target._doc.documentElement.style.cursor = getActionCursor(action);\n                }\n\n                this.resizeAxes = action.name === 'resize'? action.axis : null;\n\n                if (action === 'gesture' && this.pointerIds.length < 2) {\n                    action = null;\n                }\n\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.snapStatus.snappedX = this.snapStatus.snappedY =\n                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.startCoords);\n                this.pointerWasMoved = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n            // if inertia is active try to resume action\n            else if (this.inertiaStatus.active\n                && curEventTarget === this.element\n                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n                cancelFrame(this.inertiaStatus.i);\n                this.inertiaStatus.active = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        setModifications: function (coords, preEnd) {\n            var target         = this.target,\n                shouldMove     = true,\n                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\n            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n            }\n            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n                shouldMove = false;\n            }\n\n            return shouldMove;\n        },\n\n        setStartOffsets: function (action, interactable, element) {\n            var rect = interactable.getRect(element),\n                origin = getOriginXY(interactable, element),\n                snap = interactable.options[this.prepared.name].snap,\n                restrict = interactable.options[this.prepared.name].restrict,\n                width, height;\n\n            if (rect) {\n                this.startOffset.left = this.startCoords.page.x - rect.left;\n                this.startOffset.top  = this.startCoords.page.y - rect.top;\n\n                this.startOffset.right  = rect.right  - this.startCoords.page.x;\n                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n                if ('width' in rect) { width = rect.width; }\n                else { width = rect.right - rect.left; }\n                if ('height' in rect) { height = rect.height; }\n                else { height = rect.bottom - rect.top; }\n            }\n            else {\n                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n            }\n\n            this.snapOffsets.splice(0);\n\n            var snapOffset = snap && snap.offset === 'startCoords'\n                                ? {\n                                    x: this.startCoords.page.x - origin.x,\n                                    y: this.startCoords.page.y - origin.y\n                                }\n                                : snap && snap.offset || { x: 0, y: 0 };\n\n            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n                for (var i = 0; i < snap.relativePoints.length; i++) {\n                    this.snapOffsets.push({\n                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n                    });\n                }\n            }\n            else {\n                this.snapOffsets.push(snapOffset);\n            }\n\n            if (rect && restrict.elementRect) {\n                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\n                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n            }\n            else {\n                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n            }\n        },\n\n        /*\\\n         * Interaction.start\n         [ method ]\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate number\n         * of pointers must be held down  1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         - action       (object)  The action to be performed - drag, resize, etc.\n         - interactable (Interactable) The Interactable to target\n         - element      (Element) The DOM Element to target\n         = (object) interact\n         **\n         | interact(target)\n         |   .draggable({\n         |     // disable the default drag start by down->move\n         |     manualStart: true\n         |   })\n         |   // start dragging after the user holds the pointer down\n         |   .on('hold', function (event) {\n         |     var interaction = event.interaction;\n         |\n         |     if (!interaction.interacting()) {\n         |       interaction.start({ name: 'drag' },\n         |                         event.interactable,\n         |                         event.currentTarget);\n         |     }\n         | });\n        \\*/\n        start: function (action, interactable, element) {\n            if (this.interacting()\n                || !this.pointerIsDown\n                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n                return;\n            }\n\n            // if this interaction had been removed after stopping\n            // add it back\n            if (indexOf(interactions, this) === -1) {\n                interactions.push(this);\n            }\n\n            // set the startCoords if there was no prepared action\n            if (!this.prepared.name) {\n                this.setEventXY(this.startCoords);\n            }\n\n            this.prepared.name  = action.name;\n            this.prepared.axis  = action.axis;\n            this.prepared.edges = action.edges;\n            this.target         = interactable;\n            this.element        = element;\n\n            this.setStartOffsets(action.name, interactable, element);\n            this.setModifications(this.startCoords.page);\n\n            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n        },\n\n        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n            if (this.inertiaStatus.active) {\n                var pageUp   = this.inertiaStatus.upCoords.page;\n                var clientUp = this.inertiaStatus.upCoords.client;\n\n                var inertiaPosition = {\n                    pageX  : pageUp.x   + this.inertiaStatus.sx,\n                    pageY  : pageUp.y   + this.inertiaStatus.sy,\n                    clientX: clientUp.x + this.inertiaStatus.sx,\n                    clientY: clientUp.y + this.inertiaStatus.sy\n                };\n\n                this.setEventXY(this.curCoords, [inertiaPosition]);\n            }\n            else {\n                this.recordPointer(pointer);\n                this.setEventXY(this.curCoords, this.pointers);\n            }\n\n            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                                 && this.curCoords.page.y === this.prevCoords.page.y\n                                 && this.curCoords.client.x === this.prevCoords.client.x\n                                 && this.curCoords.client.y === this.prevCoords.client.y);\n\n            var dx, dy,\n                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // register movement greater than pointerMoveTolerance\n            if (this.pointerIsDown && !this.pointerWasMoved) {\n                dx = this.curCoords.client.x - this.startCoords.client.x;\n                dy = this.curCoords.client.y - this.startCoords.client.y;\n\n                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n            }\n\n            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n                if (this.pointerIsDown) {\n                    clearTimeout(this.holdTimers[pointerIndex]);\n                }\n\n                this.collectEventTargets(pointer, event, eventTarget, 'move');\n            }\n\n            if (!this.pointerIsDown) { return; }\n\n            if (duplicateMove && this.pointerWasMoved && !preEnd) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n                return;\n            }\n\n            // set pointer coordinate, time changes and speeds\n            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n            if (!this.prepared.name) { return; }\n\n            if (this.pointerWasMoved\n                // ignore movement while inertia is active\n                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\n                // if just starting an action, calculate the pointer speed now\n                if (!this.interacting()) {\n                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n                    // check if a drag is in the correct axis\n                    if (this.prepared.name === 'drag') {\n                        var absX = Math.abs(dx),\n                            absY = Math.abs(dy),\n                            targetAxis = this.target.options.drag.axis,\n                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n                        // if the movement isn't in the axis of the interactable\n                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n                            // cancel the prepared action\n                            this.prepared.name = null;\n\n                            // then try to get a drag from another ineractable\n\n                            var element = eventTarget;\n\n                            // check element interactables\n                            while (isElement(element)) {\n                                var elementInteractable = interactables.get(element);\n\n                                if (elementInteractable\n                                    && elementInteractable !== this.target\n                                    && !elementInteractable.options.drag.manualStart\n                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n                                    && checkAxis(axis, elementInteractable)) {\n\n                                    this.prepared.name = 'drag';\n                                    this.target = elementInteractable;\n                                    this.element = element;\n                                    break;\n                                }\n\n                                element = parentElement(element);\n                            }\n\n                            // if there's no drag from element interactables,\n                            // check the selector interactables\n                            if (!this.prepared.name) {\n                                var thisInteraction = this;\n\n                                var getDraggable = function (interactable, selector, context) {\n                                    var elements = ie8MatchesSelector\n                                        ? context.querySelectorAll(selector)\n                                        : undefined;\n\n                                    if (interactable === thisInteraction.target) { return; }\n\n                                    if (inContext(interactable, eventTarget)\n                                        && !interactable.options.drag.manualStart\n                                        && !testIgnore(interactable, element, eventTarget)\n                                        && testAllow(interactable, element, eventTarget)\n                                        && matchesSelector(element, selector, elements)\n                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n                                        && checkAxis(axis, interactable)\n                                        && withinInteractionLimit(interactable, element, 'drag')) {\n\n                                        return interactable;\n                                    }\n                                };\n\n                                element = eventTarget;\n\n                                while (isElement(element)) {\n                                    var selectorInteractable = interactables.forEachSelector(getDraggable);\n\n                                    if (selectorInteractable) {\n                                        this.prepared.name = 'drag';\n                                        this.target = selectorInteractable;\n                                        this.element = element;\n                                        break;\n                                    }\n\n                                    element = parentElement(element);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                var starting = !!this.prepared.name && !this.interacting();\n\n                if (starting\n                    && (this.target.options[this.prepared.name].manualStart\n                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n                    this.stop(event);\n                    return;\n                }\n\n                if (this.prepared.name && this.target) {\n                    if (starting) {\n                        this.start(this.prepared, this.target, this.element);\n                    }\n\n                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\n                    // move if snapping or restriction doesn't prevent it\n                    if (shouldMove || starting) {\n                        this.prevEvent = this[this.prepared.name + 'Move'](event);\n                    }\n\n                    this.checkAndPreventDefault(event, this.target, this.element);\n                }\n            }\n\n            copyCoords(this.prevCoords, this.curCoords);\n\n            if (this.dragging || this.resizing) {\n                this.autoScrollMove(pointer);\n            }\n        },\n\n        dragStart: function (event) {\n            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\n            this.dragging = true;\n            this.target.fire(dragEvent);\n\n            // reset active dropzones\n            this.activeDrops.dropzones = [];\n            this.activeDrops.elements  = [];\n            this.activeDrops.rects     = [];\n\n            if (!this.dynamicDrop) {\n                this.setActiveDrops(this.element);\n            }\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            if (dropEvents.activate) {\n                this.fireActiveDrops(dropEvents.activate);\n            }\n\n            return dragEvent;\n        },\n\n        dragMove: function (event) {\n            var target = this.target,\n                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n                draggableElement = this.element,\n                drop = this.getDrop(dragEvent, event, draggableElement);\n\n            this.dropTarget = drop.dropzone;\n            this.dropElement = drop.element;\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            target.fire(dragEvent);\n\n            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\n            this.prevDropTarget  = this.dropTarget;\n            this.prevDropElement = this.dropElement;\n\n            return dragEvent;\n        },\n\n        resizeStart: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\n            if (this.prepared.edges) {\n                var startRect = this.target.getRect(this.element);\n\n                /*\n                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n                 * on the active edges and the edge being interacted with.\n                 */\n                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n                    var linkedEdges = extend({}, this.prepared.edges);\n\n                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n                    this.prepared._linkedEdges = linkedEdges;\n                }\n                else {\n                    this.prepared._linkedEdges = null;\n                }\n\n                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n                if (this.target.options.resize.preserveAspectRatio) {\n                    this.resizeStartAspectRatio = startRect.width / startRect.height;\n                }\n\n                this.resizeRects = {\n                    start     : startRect,\n                    current   : extend({}, startRect),\n                    restricted: extend({}, startRect),\n                    previous  : extend({}, startRect),\n                    delta     : {\n                        left: 0, right : 0, width : 0,\n                        top : 0, bottom: 0, height: 0\n                    }\n                };\n\n                resizeEvent.rect = this.resizeRects.restricted;\n                resizeEvent.deltaRect = this.resizeRects.delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            this.resizing = true;\n\n            return resizeEvent;\n        },\n\n        resizeMove: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\n            var edges = this.prepared.edges,\n                invert = this.target.options.resize.invert,\n                invertible = invert === 'reposition' || invert === 'negate';\n\n            if (edges) {\n                var dx = resizeEvent.dx,\n                    dy = resizeEvent.dy,\n\n                    start      = this.resizeRects.start,\n                    current    = this.resizeRects.current,\n                    restricted = this.resizeRects.restricted,\n                    delta      = this.resizeRects.delta,\n                    previous   = extend(this.resizeRects.previous, restricted),\n\n                    originalEdges = edges;\n\n                // `resize.preserveAspectRatio` takes precedence over `resize.square`\n                if (this.target.options.resize.preserveAspectRatio) {\n                    var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx / resizeStartAspectRatio;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n                }\n                else if (this.target.options.resize.square) {\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n                }\n\n                // update the 'current' rect without modifications\n                if (edges.top   ) { current.top    += dy; }\n                if (edges.bottom) { current.bottom += dy; }\n                if (edges.left  ) { current.left   += dx; }\n                if (edges.right ) { current.right  += dx; }\n\n                if (invertible) {\n                    // if invertible, copy the current rect\n                    extend(restricted, current);\n\n                    if (invert === 'reposition') {\n                        // swap edge values if necessary to keep width/height positive\n                        var swap;\n\n                        if (restricted.top > restricted.bottom) {\n                            swap = restricted.top;\n\n                            restricted.top = restricted.bottom;\n                            restricted.bottom = swap;\n                        }\n                        if (restricted.left > restricted.right) {\n                            swap = restricted.left;\n\n                            restricted.left = restricted.right;\n                            restricted.right = swap;\n                        }\n                    }\n                }\n                else {\n                    // if not invertible, restrict to minimum of 0x0 rect\n                    restricted.top    = Math.min(current.top, start.bottom);\n                    restricted.bottom = Math.max(current.bottom, start.top);\n                    restricted.left   = Math.min(current.left, start.right);\n                    restricted.right  = Math.max(current.right, start.left);\n                }\n\n                restricted.width  = restricted.right  - restricted.left;\n                restricted.height = restricted.bottom - restricted.top ;\n\n                for (var edge in restricted) {\n                    delta[edge] = restricted[edge] - previous[edge];\n                }\n\n                resizeEvent.edges = this.prepared.edges;\n                resizeEvent.rect = restricted;\n                resizeEvent.deltaRect = delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            return resizeEvent;\n        },\n\n        gestureStart: function (event) {\n            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\n            gestureEvent.ds = 0;\n\n            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.scale = 1;\n\n            this.gesturing = true;\n\n            this.target.fire(gestureEvent);\n\n            return gestureEvent;\n        },\n\n        gestureMove: function (event) {\n            if (!this.pointerIds.length) {\n                return this.prevEvent;\n            }\n\n            var gestureEvent;\n\n            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\n            this.target.fire(gestureEvent);\n\n            this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.prevDistance = gestureEvent.distance;\n\n            if (gestureEvent.scale !== Infinity &&\n                gestureEvent.scale !== null &&\n                gestureEvent.scale !== undefined  &&\n                !isNaN(gestureEvent.scale)) {\n\n                this.gesture.scale = gestureEvent.scale;\n            }\n\n            return gestureEvent;\n        },\n\n        pointerHold: function (pointer, event, eventTarget) {\n            this.collectEventTargets(pointer, event, eventTarget, 'hold');\n        },\n\n        pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'up' );\n            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        // http://www.quirksmode.org/dom/events/click.html\n        // >Events leading to dblclick\n        //\n        // IE8 doesn't fire down event before dblclick.\n        // This workaround tries to fire a tap and doubletap after dblclick\n        ie8Dblclick: function (pointer, event, eventTarget) {\n            if (this.prevTap\n                && event.clientX === this.prevTap.clientX\n                && event.clientY === this.prevTap.clientY\n                && eventTarget   === this.prevTap.target) {\n\n                this.downTargets[0] = eventTarget;\n                this.downTimes[0] = new Date().getTime();\n                this.collectEventTargets(pointer, event, eventTarget, 'tap');\n            }\n        },\n\n        // End interact move events and stop auto-scroll unless inertia is enabled\n        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n            var endEvent,\n                target = this.target,\n                options = target && target.options,\n                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n                inertiaStatus = this.inertiaStatus;\n\n            if (this.interacting()) {\n\n                if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\n                var pointerSpeed,\n                    now = new Date().getTime(),\n                    inertiaPossible = false,\n                    inertia = false,\n                    smoothEnd = false,\n                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n                    dx = 0,\n                    dy = 0,\n                    startEvent;\n\n                if (this.dragging) {\n                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n                }\n                else {\n                    pointerSpeed = this.pointerDelta.client.speed;\n                }\n\n                // check if inertia should be started\n                inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                                   && this.prepared.name !== 'gesture'\n                                   && event !== inertiaStatus.startEvent);\n\n                inertia = (inertiaPossible\n                           && (now - this.curCoords.timeStamp) < 50\n                           && pointerSpeed > inertiaOptions.minSpeed\n                           && pointerSpeed > inertiaOptions.endSpeed);\n\n                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\n                    var snapRestrict = {};\n\n                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n                    if (endSnap) {\n                        this.setSnapping(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.locked) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (endRestrict) {\n                        this.setRestriction(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.restricted) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (dx || dy) {\n                        smoothEnd = true;\n                    }\n                }\n\n                if (inertia || smoothEnd) {\n                    copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n                    this.pointers[0] = inertiaStatus.startEvent = startEvent =\n                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n                    inertiaStatus.t0 = now;\n\n                    target.fire(inertiaStatus.startEvent);\n\n                    if (inertia) {\n                        inertiaStatus.vx0 = this.pointerDelta.client.vx;\n                        inertiaStatus.vy0 = this.pointerDelta.client.vy;\n                        inertiaStatus.v0 = pointerSpeed;\n\n                        this.calcInertia(inertiaStatus);\n\n                        var page = extend({}, this.curCoords.page),\n                            origin = getOriginXY(target, this.element),\n                            statusObject;\n\n                        page.x = page.x + inertiaStatus.xe - origin.x;\n                        page.y = page.y + inertiaStatus.ye - origin.y;\n\n                        statusObject = {\n                            useStatusXY: true,\n                            x: page.x,\n                            y: page.y,\n                            dx: 0,\n                            dy: 0,\n                            snap: null\n                        };\n\n                        statusObject.snap = statusObject;\n\n                        dx = dy = 0;\n\n                        if (endSnap) {\n                            var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n                            if (snap.locked) {\n                                dx += snap.dx;\n                                dy += snap.dy;\n                            }\n                        }\n\n                        if (endRestrict) {\n                            var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\n                            if (restrict.restricted) {\n                                dx += restrict.dx;\n                                dy += restrict.dy;\n                            }\n                        }\n\n                        inertiaStatus.modifiedXe += dx;\n                        inertiaStatus.modifiedYe += dy;\n\n                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n                    }\n                    else {\n                        inertiaStatus.smoothEnd = true;\n                        inertiaStatus.xe = dx;\n                        inertiaStatus.ye = dy;\n\n                        inertiaStatus.sx = inertiaStatus.sy = 0;\n\n                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n                    }\n\n                    inertiaStatus.active = true;\n                    return;\n                }\n\n                if (endSnap || endRestrict) {\n                    // fire a move event at the snapped coordinates\n                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n                }\n            }\n\n            if (this.dragging) {\n                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\n                var draggableElement = this.element,\n                    drop = this.getDrop(endEvent, event, draggableElement);\n\n                this.dropTarget = drop.dropzone;\n                this.dropElement = drop.element;\n\n                var dropEvents = this.getDropEvents(event, endEvent);\n\n                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n                if (dropEvents.deactivate) {\n                    this.fireActiveDrops(dropEvents.deactivate);\n                }\n\n                target.fire(endEvent);\n            }\n            else if (this.resizing) {\n                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n                target.fire(endEvent);\n            }\n            else if (this.gesturing) {\n                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n                target.fire(endEvent);\n            }\n\n            this.stop(event);\n        },\n\n        collectDrops: function (element) {\n            var drops = [],\n                elements = [],\n                i;\n\n            element = element || this.element;\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (i = 0; i < interactables.length; i++) {\n                if (!interactables[i].options.drop.enabled) { continue; }\n\n                var current = interactables[i],\n                    accept = current.options.drop.accept;\n\n                // test the draggable element against the dropzone's accept setting\n                if ((isElement(accept) && accept !== element)\n                    || (isString(accept)\n                        && !matchesSelector(element, accept))) {\n\n                    continue;\n                }\n\n                // query for new elements if necessary\n                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\n                for (var j = 0, len = dropElements.length; j < len; j++) {\n                    var currentElement = dropElements[j];\n\n                    if (currentElement === element) {\n                        continue;\n                    }\n\n                    drops.push(current);\n                    elements.push(currentElement);\n                }\n            }\n\n            return {\n                dropzones: drops,\n                elements: elements\n            };\n        },\n\n        fireActiveDrops: function (event) {\n            var i,\n                current,\n                currentElement,\n                prevElement;\n\n            // loop through all active dropzones and trigger event\n            for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n                current = this.activeDrops.dropzones[i];\n                currentElement = this.activeDrops.elements [i];\n\n                // prevent trigger of duplicate events on same element\n                if (currentElement !== prevElement) {\n                    // set current element as event target\n                    event.target = currentElement;\n                    current.fire(event);\n                }\n                prevElement = currentElement;\n            }\n        },\n\n        // Collect a new set of possible drops and save them in activeDrops.\n        // setActiveDrops should always be called when a drag has just started or a\n        // drag event happens while dynamicDrop is true\n        setActiveDrops: function (dragElement) {\n            // get dropzones and their elements that could receive the draggable\n            var possibleDrops = this.collectDrops(dragElement, true);\n\n            this.activeDrops.dropzones = possibleDrops.dropzones;\n            this.activeDrops.elements  = possibleDrops.elements;\n            this.activeDrops.rects     = [];\n\n            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n            }\n        },\n\n        getDrop: function (dragEvent, event, dragElement) {\n            var validDrops = [];\n\n            if (dynamicDrop) {\n                this.setActiveDrops(dragElement);\n            }\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n                var current        = this.activeDrops.dropzones[j],\n                    currentElement = this.activeDrops.elements [j],\n                    rect           = this.activeDrops.rects    [j];\n\n                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n                                ? currentElement\n                                : null);\n            }\n\n            // get the most appropriate dropzone based on DOM depth and order\n            var dropIndex = indexOfDeepestElement(validDrops),\n                dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n                element   = this.activeDrops.elements [dropIndex] || null;\n\n            return {\n                dropzone: dropzone,\n                element: element\n            };\n        },\n\n        getDropEvents: function (pointerEvent, dragEvent) {\n            var dropEvents = {\n                enter     : null,\n                leave     : null,\n                activate  : null,\n                deactivate: null,\n                move      : null,\n                drop      : null\n            };\n\n            if (this.dropElement !== this.prevDropElement) {\n                // if there was a prevDropTarget, create a dragleave event\n                if (this.prevDropTarget) {\n                    dropEvents.leave = {\n                        target       : this.prevDropElement,\n                        dropzone     : this.prevDropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragleave'\n                    };\n\n                    dragEvent.dragLeave = this.prevDropElement;\n                    dragEvent.prevDropzone = this.prevDropTarget;\n                }\n                // if the dropTarget is not null, create a dragenter event\n                if (this.dropTarget) {\n                    dropEvents.enter = {\n                        target       : this.dropElement,\n                        dropzone     : this.dropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragenter'\n                    };\n\n                    dragEvent.dragEnter = this.dropElement;\n                    dragEvent.dropzone = this.dropTarget;\n                }\n            }\n\n            if (dragEvent.type === 'dragend' && this.dropTarget) {\n                dropEvents.drop = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'drop'\n                };\n\n                dragEvent.dropzone = this.dropTarget;\n            }\n            if (dragEvent.type === 'dragstart') {\n                dropEvents.activate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropactivate'\n                };\n            }\n            if (dragEvent.type === 'dragend') {\n                dropEvents.deactivate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropdeactivate'\n                };\n            }\n            if (dragEvent.type === 'dragmove' && this.dropTarget) {\n                dropEvents.move = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    dragmove     : dragEvent,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropmove'\n                };\n                dragEvent.dropzone = this.dropTarget;\n            }\n\n            return dropEvents;\n        },\n\n        currentAction: function () {\n            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n        },\n\n        interacting: function () {\n            return this.dragging || this.resizing || this.gesturing;\n        },\n\n        clearTargets: function () {\n            this.target = this.element = null;\n\n            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n        },\n\n        stop: function (event) {\n            if (this.interacting()) {\n                autoScroll.stop();\n                this.matches = [];\n                this.matchElements = [];\n\n                var target = this.target;\n\n                if (target.options.styleCursor) {\n                    target._doc.documentElement.style.cursor = '';\n                }\n\n                // prevent Default only if were previously interacting\n                if (event && isFunction(event.preventDefault)) {\n                    this.checkAndPreventDefault(event, target, this.element);\n                }\n\n                if (this.dragging) {\n                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n                }\n            }\n\n            this.clearTargets();\n\n            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n            this.prepared.name = this.prevEvent = null;\n            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n            // remove pointers if their ID isn't in this.pointerIds\n            for (var i = 0; i < this.pointers.length; i++) {\n                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n                    this.pointers.splice(i, 1);\n                }\n            }\n        },\n\n        inertiaFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                options = this.target.options[this.prepared.name].inertia,\n                lambda = options.resistance,\n                t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n            if (t < inertiaStatus.te) {\n\n                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n                    inertiaStatus.sx = inertiaStatus.xe * progress;\n                    inertiaStatus.sy = inertiaStatus.ye * progress;\n                }\n                else {\n                    var quadPoint = getQuadraticCurvePoint(\n                            0, 0,\n                            inertiaStatus.xe, inertiaStatus.ye,\n                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n                            progress);\n\n                    inertiaStatus.sx = quadPoint.x;\n                    inertiaStatus.sy = quadPoint.y;\n                }\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.modifiedXe;\n                inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        smoothEndFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                t = new Date().getTime() - inertiaStatus.t0,\n                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n            if (t < duration) {\n                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.xe;\n                inertiaStatus.sy = inertiaStatus.ye;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.smoothEnd =\n                  inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        addPointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) {\n                index = this.pointerIds.length;\n            }\n\n            this.pointerIds[index] = id;\n            this.pointers[index] = pointer;\n\n            return index;\n        },\n\n        removePointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) { return; }\n\n            this.pointers   .splice(index, 1);\n            this.pointerIds .splice(index, 1);\n            this.downTargets.splice(index, 1);\n            this.downTimes  .splice(index, 1);\n            this.holdTimers .splice(index, 1);\n        },\n\n        recordPointer: function (pointer) {\n            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\n            if (index === -1) { return; }\n\n            this.pointers[index] = pointer;\n        },\n\n        collectEventTargets: function (pointer, event, eventTarget, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // do not fire a tap event if the pointer was moved before being lifted\n            if (eventType === 'tap' && (this.pointerWasMoved\n                // or if the pointerup target is different to the pointerdown target\n                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n                return;\n            }\n\n            var targets = [],\n                elements = [],\n                element = eventTarget;\n\n            function collectSelectors (interactable, selector, context) {\n                var els = ie8MatchesSelector\n                        ? context.querySelectorAll(selector)\n                        : undefined;\n\n                if (interactable._iEvents[eventType]\n                    && isElement(element)\n                    && inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, els)) {\n\n                    targets.push(interactable);\n                    elements.push(element);\n                }\n            }\n\n            while (element) {\n                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n                    targets.push(interact(element));\n                    elements.push(element);\n                }\n\n                interactables.forEachSelector(collectSelectors);\n\n                element = parentElement(element);\n            }\n\n            // create the tap event even if there are no listeners so that\n            // doubletap can still be created and fired\n            if (targets.length || eventType === 'tap') {\n                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n            }\n        },\n\n        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n                pointerEvent = {},\n                i,\n                // for tap events\n                interval, createNewDoubleTap;\n\n            // if it's a doubletap then the event properties would have been\n            // copied from the tap event and provided as the pointer argument\n            if (eventType === 'doubletap') {\n                pointerEvent = pointer;\n            }\n            else {\n                pointerExtend(pointerEvent, event);\n                if (event !== pointer) {\n                    pointerExtend(pointerEvent, pointer);\n                }\n\n                pointerEvent.preventDefault           = preventOriginalDefault;\n                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n                pointerEvent.interaction              = this;\n\n                pointerEvent.timeStamp       = new Date().getTime();\n                pointerEvent.originalEvent   = event;\n                pointerEvent.originalPointer = pointer;\n                pointerEvent.type            = eventType;\n                pointerEvent.pointerId       = getPointerId(pointer);\n                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n                                                    : isString(pointer.pointerType)\n                                                        ? pointer.pointerType\n                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n            }\n\n            if (eventType === 'tap') {\n                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\n                interval = pointerEvent.timeStamp - this.tapTime;\n                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n                       && this.prevTap.target === pointerEvent.target\n                       && interval < 500);\n\n                pointerEvent.double = createNewDoubleTap;\n\n                this.tapTime = pointerEvent.timeStamp;\n            }\n\n            for (i = 0; i < targets.length; i++) {\n                pointerEvent.currentTarget = elements[i];\n                pointerEvent.interactable = targets[i];\n                targets[i].fire(pointerEvent);\n\n                if (pointerEvent.immediatePropagationStopped\n                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n                    break;\n                }\n            }\n\n            if (createNewDoubleTap) {\n                var doubleTap = {};\n\n                extend(doubleTap, pointerEvent);\n\n                doubleTap.dt   = interval;\n                doubleTap.type = 'doubletap';\n\n                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\n                this.prevTap = doubleTap;\n            }\n            else if (eventType === 'tap') {\n                this.prevTap = pointerEvent;\n            }\n        },\n\n        validateSelector: function (pointer, event, matches, matchElements) {\n            for (var i = 0, len = matches.length; i < len; i++) {\n                var match = matches[i],\n                    matchElement = matchElements[i],\n                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n                if (action && withinInteractionLimit(match, matchElement, action)) {\n                    this.target = match;\n                    this.element = matchElement;\n\n                    return action;\n                }\n            }\n        },\n\n        setSnapping: function (pageCoords, status) {\n            var snap = this.target.options[this.prepared.name].snap,\n                targets = [],\n                target,\n                page,\n                i;\n\n            status = status || this.snapStatus;\n\n            if (status.useStatusXY) {\n                page = { x: status.x, y: status.y };\n            }\n            else {\n                var origin = getOriginXY(this.target, this.element);\n\n                page = extend({}, pageCoords);\n\n                page.x -= origin.x;\n                page.y -= origin.y;\n            }\n\n            status.realX = page.x;\n            status.realY = page.y;\n\n            page.x = page.x - this.inertiaStatus.resumeDx;\n            page.y = page.y - this.inertiaStatus.resumeDy;\n\n            var len = snap.targets? snap.targets.length : 0;\n\n            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n                var relative = {\n                    x: page.x - this.snapOffsets[relIndex].x,\n                    y: page.y - this.snapOffsets[relIndex].y\n                };\n\n                for (i = 0; i < len; i++) {\n                    if (isFunction(snap.targets[i])) {\n                        target = snap.targets[i](relative.x, relative.y, this);\n                    }\n                    else {\n                        target = snap.targets[i];\n                    }\n\n                    if (!target) { continue; }\n\n                    targets.push({\n                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\n                        range: isNumber(target.range)? target.range: snap.range\n                    });\n                }\n            }\n\n            var closest = {\n                    target: null,\n                    inRange: false,\n                    distance: 0,\n                    range: 0,\n                    dx: 0,\n                    dy: 0\n                };\n\n            for (i = 0, len = targets.length; i < len; i++) {\n                target = targets[i];\n\n                var range = target.range,\n                    dx = target.x - page.x,\n                    dy = target.y - page.y,\n                    distance = hypot(dx, dy),\n                    inRange = distance <= range;\n\n                // Infinite targets count as being out of range\n                // compared to non infinite ones that are in range\n                if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n                    inRange = false;\n                }\n\n                if (!closest.target || (inRange\n                    // is the closest target in range?\n                    ? (closest.inRange && range !== Infinity\n                        // the pointer is relatively deeper in this target\n                        ? distance / range < closest.distance / closest.range\n                        // this target has Infinite range and the closest doesn't\n                        : (range === Infinity && closest.range !== Infinity)\n                            // OR this target is closer that the previous closest\n                            || distance < closest.distance)\n                    // The other is not in range and the pointer is closer to this target\n                    : (!closest.inRange && distance < closest.distance))) {\n\n                    if (range === Infinity) {\n                        inRange = true;\n                    }\n\n                    closest.target = target;\n                    closest.distance = distance;\n                    closest.range = range;\n                    closest.inRange = inRange;\n                    closest.dx = dx;\n                    closest.dy = dy;\n\n                    status.range = range;\n                }\n            }\n\n            var snapChanged;\n\n            if (closest.target) {\n                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n                status.snappedX = closest.target.x;\n                status.snappedY = closest.target.y;\n            }\n            else {\n                snapChanged = true;\n\n                status.snappedX = NaN;\n                status.snappedY = NaN;\n            }\n\n            status.dx = closest.dx;\n            status.dy = closest.dy;\n\n            status.changed = (snapChanged || (closest.inRange && !status.locked));\n            status.locked = closest.inRange;\n\n            return status;\n        },\n\n        setRestriction: function (pageCoords, status) {\n            var target = this.target,\n                restrict = target && target.options[this.prepared.name].restrict,\n                restriction = restrict && restrict.restriction,\n                page;\n\n            if (!restriction) {\n                return status;\n            }\n\n            status = status || this.restrictStatus;\n\n            page = status.useStatusXY\n                    ? page = { x: status.x, y: status.y }\n                    : page = extend({}, pageCoords);\n\n            if (status.snap && status.snap.locked) {\n                page.x += status.snap.dx || 0;\n                page.y += status.snap.dy || 0;\n            }\n\n            page.x -= this.inertiaStatus.resumeDx;\n            page.y -= this.inertiaStatus.resumeDy;\n\n            status.dx = 0;\n            status.dy = 0;\n            status.restricted = false;\n\n            var rect, restrictedX, restrictedY;\n\n            if (isString(restriction)) {\n                if (restriction === 'parent') {\n                    restriction = parentElement(this.element);\n                }\n                else if (restriction === 'self') {\n                    restriction = target.getRect(this.element);\n                }\n                else {\n                    restriction = closest(this.element, restriction);\n                }\n\n                if (!restriction) { return status; }\n            }\n\n            if (isFunction(restriction)) {\n                restriction = restriction(page.x, page.y, this.element);\n            }\n\n            if (isElement(restriction)) {\n                restriction = getElementRect(restriction);\n            }\n\n            rect = restriction;\n\n            if (!restriction) {\n                restrictedX = page.x;\n                restrictedY = page.y;\n            }\n            // object is assumed to have\n            // x, y, width, height or\n            // left, top, right, bottom\n            else if ('x' in restriction && 'y' in restriction) {\n                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n            }\n            else {\n                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n            }\n\n            status.dx = restrictedX - page.x;\n            status.dy = restrictedY - page.y;\n\n            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n            status.restricted = !!(status.dx || status.dy);\n\n            status.restrictedX = restrictedX;\n            status.restrictedY = restrictedY;\n\n            return status;\n        },\n\n        checkAndPreventDefault: function (event, interactable, element) {\n            if (!(interactable = interactable || this.target)) { return; }\n\n            var options = interactable.options,\n                prevent = options.preventDefault;\n\n            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n                // do not preventDefault on pointerdown if the prepared action is a drag\n                // and dragging can only start from a certain direction - this allows\n                // a touch to pan the viewport if a drag isn't in the right direction\n                if (/down|start/i.test(event.type)\n                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n                    return;\n                }\n\n                // with manualStart, only preventDefault while interacting\n                if (options[this.prepared.name] && options[this.prepared.name].manualStart\n                    && !this.interacting()) {\n                    return;\n                }\n\n                event.preventDefault();\n                return;\n            }\n\n            if (prevent === 'always') {\n                event.preventDefault();\n                return;\n            }\n        },\n\n        calcInertia: function (status) {\n            var inertiaOptions = this.target.options[this.prepared.name].inertia,\n                lambda = inertiaOptions.resistance,\n                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n            status.x0 = this.prevEvent.pageX;\n            status.y0 = this.prevEvent.pageY;\n            status.t0 = status.startEvent.timeStamp / 1000;\n            status.sx = status.sy = 0;\n\n            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n            status.te = inertiaDur;\n\n            status.lambda_v0 = lambda / status.v0;\n            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n        },\n\n        autoScrollMove: function (pointer) {\n            if (!(this.interacting()\n                && checkAutoScroll(this.target, this.prepared.name))) {\n                return;\n            }\n\n            if (this.inertiaStatus.active) {\n                autoScroll.x = autoScroll.y = 0;\n                return;\n            }\n\n            var top,\n                right,\n                bottom,\n                left,\n                options = this.target.options[this.prepared.name].autoScroll,\n                container = options.container || getWindow(this.element);\n\n            if (isWindow(container)) {\n                left   = pointer.clientX < autoScroll.margin;\n                top    = pointer.clientY < autoScroll.margin;\n                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n            }\n            else {\n                var rect = getElementClientRect(container);\n\n                left   = pointer.clientX < rect.left   + autoScroll.margin;\n                top    = pointer.clientY < rect.top    + autoScroll.margin;\n                right  = pointer.clientX > rect.right  - autoScroll.margin;\n                bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n            }\n\n            autoScroll.x = (right ? 1: left? -1: 0);\n            autoScroll.y = (bottom? 1:  top? -1: 0);\n\n            if (!autoScroll.isScrolling) {\n                // set the autoScroll properties to those of the target\n                autoScroll.margin = options.margin;\n                autoScroll.speed  = options.speed;\n\n                autoScroll.start(this);\n            }\n        },\n\n        _updateEventTargets: function (target, currentTarget) {\n            this._eventTarget    = target;\n            this._curEventTarget = currentTarget;\n        }\n\n    };\n\n    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n        var i = 0, len = interactions.length,\n            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                          || pointer.pointerType === 4),\n            interaction;\n\n        var id = getPointerId(pointer);\n\n        // try to resume inertia with a new pointer\n        if (/down|start/i.test(eventType)) {\n            for (i = 0; i < len; i++) {\n                interaction = interactions[i];\n\n                var element = eventTarget;\n\n                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n                    && (interaction.mouse === mouseEvent)) {\n                    while (element) {\n                        // if the element is the interaction element\n                        if (element === interaction.element) {\n                            return interaction;\n                        }\n                        element = parentElement(element);\n                    }\n                }\n            }\n        }\n\n        // if it's a mouse interaction\n        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\n            // find a mouse interaction that's not in inertia phase\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n                    return interactions[i];\n                }\n            }\n\n            // find any interaction specifically for mouse.\n            // if the eventType is a mousedown, and inertia is active\n            // ignore the interaction\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n                    return interaction;\n                }\n            }\n\n            // create a new interaction for mouse\n            interaction = new Interaction();\n            interaction.mouse = true;\n\n            return interaction;\n        }\n\n        // get interaction that has this pointer\n        for (i = 0; i < len; i++) {\n            if (contains(interactions[i].pointerIds, id)) {\n                return interactions[i];\n            }\n        }\n\n        // at this stage, a pointerUp should not return an interaction\n        if (/up|end|out/i.test(eventType)) {\n            return null;\n        }\n\n        // get first idle interaction\n        for (i = 0; i < len; i++) {\n            interaction = interactions[i];\n\n            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n                && !interaction.interacting()\n                && !(!mouseEvent && interaction.mouse)) {\n\n                return interaction;\n            }\n        }\n\n        return new Interaction();\n    }\n\n    function doOnInteractions (method) {\n        return (function (event) {\n            var interaction,\n                eventTarget = getActualElement(event.path\n                                               ? event.path[0]\n                                               : event.target),\n                curEventTarget = getActualElement(event.currentTarget),\n                i;\n\n            if (supportsTouch && /touch/.test(event.type)) {\n                prevTouchTime = new Date().getTime();\n\n                for (i = 0; i < event.changedTouches.length; i++) {\n                    var pointer = event.changedTouches[i];\n\n                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\n                    if (!interaction) { continue; }\n\n                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                    interaction[method](pointer, event, eventTarget, curEventTarget);\n                }\n            }\n            else {\n                if (!supportsPointerEvent && /mouse/.test(event.type)) {\n                    // ignore mouse events while touch interactions are active\n                    for (i = 0; i < interactions.length; i++) {\n                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n                            return;\n                        }\n                    }\n\n                    // try to ignore mouse events that are simulated by the browser\n                    // after a touch event\n                    if (new Date().getTime() - prevTouchTime < 500) {\n                        return;\n                    }\n                }\n\n                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n                if (!interaction) { return; }\n\n                interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                interaction[method](event, event, eventTarget, curEventTarget);\n            }\n        });\n    }\n\n    function InteractEvent (interaction, event, action, phase, element, related) {\n        var client,\n            page,\n            target      = interaction.target,\n            snapStatus  = interaction.snapStatus,\n            restrictStatus  = interaction.restrictStatus,\n            pointers    = interaction.pointers,\n            deltaSource = (target && target.options || defaultOptions).deltaSource,\n            sourceX     = deltaSource + 'X',\n            sourceY     = deltaSource + 'Y',\n            options     = target? target.options: defaultOptions,\n            origin      = getOriginXY(target, element),\n            starting    = phase === 'start',\n            ending      = phase === 'end',\n            coords      = starting? interaction.startCoords : interaction.curCoords;\n\n        element = element || interaction.element;\n\n        page   = extend({}, coords.page);\n        client = extend({}, coords.client);\n\n        page.x -= origin.x;\n        page.y -= origin.y;\n\n        client.x -= origin.x;\n        client.y -= origin.y;\n\n        var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\n        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n            this.snap = {\n                range  : snapStatus.range,\n                locked : snapStatus.locked,\n                x      : snapStatus.snappedX,\n                y      : snapStatus.snappedY,\n                realX  : snapStatus.realX,\n                realY  : snapStatus.realY,\n                dx     : snapStatus.dx,\n                dy     : snapStatus.dy\n            };\n\n            if (snapStatus.locked) {\n                page.x += snapStatus.dx;\n                page.y += snapStatus.dy;\n                client.x += snapStatus.dx;\n                client.y += snapStatus.dy;\n            }\n        }\n\n        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n            page.x += restrictStatus.dx;\n            page.y += restrictStatus.dy;\n            client.x += restrictStatus.dx;\n            client.y += restrictStatus.dy;\n\n            this.restrict = {\n                dx: restrictStatus.dx,\n                dy: restrictStatus.dy\n            };\n        }\n\n        this.pageX     = page.x;\n        this.pageY     = page.y;\n        this.clientX   = client.x;\n        this.clientY   = client.y;\n\n        this.x0        = interaction.startCoords.page.x - origin.x;\n        this.y0        = interaction.startCoords.page.y - origin.y;\n        this.clientX0  = interaction.startCoords.client.x - origin.x;\n        this.clientY0  = interaction.startCoords.client.y - origin.y;\n        this.ctrlKey   = event.ctrlKey;\n        this.altKey    = event.altKey;\n        this.shiftKey  = event.shiftKey;\n        this.metaKey   = event.metaKey;\n        this.button    = event.button;\n        this.buttons   = event.buttons;\n        this.target    = element;\n        this.t0        = interaction.downTimes[0];\n        this.type      = action + (phase || '');\n\n        this.interaction = interaction;\n        this.interactable = target;\n\n        var inertiaStatus = interaction.inertiaStatus;\n\n        if (inertiaStatus.active) {\n            this.detail = 'inertia';\n        }\n\n        if (related) {\n            this.relatedTarget = related;\n        }\n\n        // end event dx, dy is difference between start and end points\n        if (ending) {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.startCoords.client.x;\n                this.dy = client.y - interaction.startCoords.client.y;\n            }\n            else {\n                this.dx = page.x - interaction.startCoords.page.x;\n                this.dy = page.y - interaction.startCoords.page.y;\n            }\n        }\n        else if (starting) {\n            this.dx = 0;\n            this.dy = 0;\n        }\n        // copy properties from previousmove if starting inertia\n        else if (phase === 'inertiastart') {\n            this.dx = interaction.prevEvent.dx;\n            this.dy = interaction.prevEvent.dy;\n        }\n        else {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.prevEvent.clientX;\n                this.dy = client.y - interaction.prevEvent.clientY;\n            }\n            else {\n                this.dx = page.x - interaction.prevEvent.pageX;\n                this.dy = page.y - interaction.prevEvent.pageY;\n            }\n        }\n        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n            && !inertiaStatus.active\n            && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n            inertiaStatus.resumeDx += this.dx;\n            inertiaStatus.resumeDy += this.dy;\n\n            this.dx = this.dy = 0;\n        }\n\n        if (action === 'resize' && interaction.resizeAxes) {\n            if (options.resize.square) {\n                if (interaction.resizeAxes === 'y') {\n                    this.dx = this.dy;\n                }\n                else {\n                    this.dy = this.dx;\n                }\n                this.axes = 'xy';\n            }\n            else {\n                this.axes = interaction.resizeAxes;\n\n                if (interaction.resizeAxes === 'x') {\n                    this.dy = 0;\n                }\n                else if (interaction.resizeAxes === 'y') {\n                    this.dx = 0;\n                }\n            }\n        }\n        else if (action === 'gesture') {\n            this.touches = [pointers[0], pointers[1]];\n\n            if (starting) {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = 1;\n                this.ds       = 0;\n                this.angle    = touchAngle(pointers, undefined, deltaSource);\n                this.da       = 0;\n            }\n            else if (ending || event instanceof InteractEvent) {\n                this.distance = interaction.prevEvent.distance;\n                this.box      = interaction.prevEvent.box;\n                this.scale    = interaction.prevEvent.scale;\n                this.ds       = this.scale - 1;\n                this.angle    = interaction.prevEvent.angle;\n                this.da       = this.angle - interaction.gesture.startAngle;\n            }\n            else {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = this.distance / interaction.gesture.startDistance;\n                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n                this.ds = this.scale - interaction.gesture.prevScale;\n                this.da = this.angle - interaction.gesture.prevAngle;\n            }\n        }\n\n        if (starting) {\n            this.timeStamp = interaction.downTimes[0];\n            this.dt        = 0;\n            this.duration  = 0;\n            this.speed     = 0;\n            this.velocityX = 0;\n            this.velocityY = 0;\n        }\n        else if (phase === 'inertiastart') {\n            this.timeStamp = interaction.prevEvent.timeStamp;\n            this.dt        = interaction.prevEvent.dt;\n            this.duration  = interaction.prevEvent.duration;\n            this.speed     = interaction.prevEvent.speed;\n            this.velocityX = interaction.prevEvent.velocityX;\n            this.velocityY = interaction.prevEvent.velocityY;\n        }\n        else {\n            this.timeStamp = new Date().getTime();\n            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n            this.duration  = this.timeStamp - interaction.downTimes[0];\n\n            if (event instanceof InteractEvent) {\n                var dx = this[sourceX] - interaction.prevEvent[sourceX],\n                    dy = this[sourceY] - interaction.prevEvent[sourceY],\n                    dt = this.dt / 1000;\n\n                this.speed = hypot(dx, dy) / dt;\n                this.velocityX = dx / dt;\n                this.velocityY = dy / dt;\n            }\n            // if normal move or end event, use previous user event coords\n            else {\n                // speed and velocity in pixels per second\n                this.speed = interaction.pointerDelta[deltaSource].speed;\n                this.velocityX = interaction.pointerDelta[deltaSource].vx;\n                this.velocityY = interaction.pointerDelta[deltaSource].vy;\n            }\n        }\n\n        if ((ending || phase === 'inertiastart')\n            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n                overlap = 22.5;\n\n            if (angle < 0) {\n                angle += 360;\n            }\n\n            var left = 135 - overlap <= angle && angle < 225 + overlap,\n                up   = 225 - overlap <= angle && angle < 315 + overlap,\n\n                right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n            this.swipe = {\n                up   : up,\n                down : down,\n                left : left,\n                right: right,\n                angle: angle,\n                speed: interaction.prevEvent.speed,\n                velocity: {\n                    x: interaction.prevEvent.velocityX,\n                    y: interaction.prevEvent.velocityY\n                }\n            };\n        }\n    }\n\n    InteractEvent.prototype = {\n        preventDefault: blank,\n        stopImmediatePropagation: function () {\n            this.immediatePropagationStopped = this.propagationStopped = true;\n        },\n        stopPropagation: function () {\n            this.propagationStopped = true;\n        }\n    };\n\n    function preventOriginalDefault () {\n        this.originalEvent.preventDefault();\n    }\n\n    function getActionCursor (action) {\n        var cursor = '';\n\n        if (action.name === 'drag') {\n            cursor =  actionCursors.drag;\n        }\n        if (action.name === 'resize') {\n            if (action.axis) {\n                cursor =  actionCursors[action.name + action.axis];\n            }\n            else if (action.edges) {\n                var cursorKey = 'resize',\n                    edgeNames = ['top', 'bottom', 'left', 'right'];\n\n                for (var i = 0; i < 4; i++) {\n                    if (action.edges[edgeNames[i]]) {\n                        cursorKey += edgeNames[i];\n                    }\n                }\n\n                cursor = actionCursors[cursorKey];\n            }\n        }\n\n        return cursor;\n    }\n\n    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n        // false, '', undefined, null\n        if (!value) { return false; }\n\n        // true value, use pointer coords and element rect\n        if (value === true) {\n            // if dimensions are negative, \"switch\" edges\n            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\n            if (width < 0) {\n                if      (name === 'left' ) { name = 'right'; }\n                else if (name === 'right') { name = 'left' ; }\n            }\n            if (height < 0) {\n                if      (name === 'top'   ) { name = 'bottom'; }\n                else if (name === 'bottom') { name = 'top'   ; }\n            }\n\n            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n        }\n\n        // the remaining checks require an element\n        if (!isElement(element)) { return false; }\n\n        return isElement(value)\n                    // the value is an element to use as a resize handle\n                    ? value === element\n                    // otherwise check if element matches value as selector\n                    : matchesUpTo(element, value, interactableElement);\n    }\n\n    function defaultActionChecker (pointer, interaction, element) {\n        var rect = this.getRect(element),\n            shouldResize = false,\n            action = null,\n            resizeAxes = null,\n            resizeEdges,\n            page = extend({}, interaction.curCoords.page),\n            options = this.options;\n\n        if (!rect) { return null; }\n\n        if (actionIsEnabled.resize && options.resize.enabled) {\n            var resizeOptions = options.resize;\n\n            resizeEdges = {\n                left: false, right: false, top: false, bottom: false\n            };\n\n            // if using resize.edges\n            if (isObject(resizeOptions.edges)) {\n                for (var edge in resizeEdges) {\n                    resizeEdges[edge] = checkResizeEdge(edge,\n                                                        resizeOptions.edges[edge],\n                                                        page,\n                                                        interaction._eventTarget,\n                                                        element,\n                                                        rect,\n                                                        resizeOptions.margin || margin);\n                }\n\n                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n            }\n            else {\n                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\n                shouldResize = right || bottom;\n                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n            }\n        }\n\n        action = shouldResize\n            ? 'resize'\n            : actionIsEnabled.drag && options.drag.enabled\n                ? 'drag'\n                : null;\n\n        if (actionIsEnabled.gesture\n            && interaction.pointerIds.length >=2\n            && !(interaction.dragging || interaction.resizing)) {\n            action = 'gesture';\n        }\n\n        if (action) {\n            return {\n                name: action,\n                axis: resizeAxes,\n                edges: resizeEdges\n            };\n        }\n\n        return null;\n    }\n\n    // Check if action is enabled globally and the current target supports it\n    // If so, return the validated action. Otherwise, return null\n    function validateAction (action, interactable) {\n        if (!isObject(action)) { return null; }\n\n        var actionName = action.name,\n            options = interactable.options;\n\n        if ((  (actionName  === 'resize'   && options.resize.enabled )\n            || (actionName      === 'drag'     && options.drag.enabled  )\n            || (actionName      === 'gesture'  && options.gesture.enabled))\n            && actionIsEnabled[actionName]) {\n\n            if (actionName === 'resize' || actionName === 'resizeyx') {\n                actionName = 'resizexy';\n            }\n\n            return action;\n        }\n        return null;\n    }\n\n    var listeners = {},\n        interactionListeners = [\n            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n        ];\n\n    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n        var name = interactionListeners[i];\n\n        listeners[name] = doOnInteractions(name);\n    }\n\n    // bound to the interactable context when a DOM event\n    // listener is added to a selector interactable\n    function delegateListener (event, useCapture) {\n        var fakeEvent = {},\n            delegated = delegatedEvents[event.type],\n            eventTarget = getActualElement(event.path\n                                           ? event.path[0]\n                                           : event.target),\n            element = eventTarget;\n\n        useCapture = useCapture? true: false;\n\n        // duplicate the event so that currentTarget can be changed\n        for (var prop in event) {\n            fakeEvent[prop] = event[prop];\n        }\n\n        fakeEvent.originalEvent = event;\n        fakeEvent.preventDefault = preventOriginalDefault;\n\n        // climb up document tree looking for selector matches\n        while (isElement(element)) {\n            for (var i = 0; i < delegated.selectors.length; i++) {\n                var selector = delegated.selectors[i],\n                    context = delegated.contexts[i];\n\n                if (matchesSelector(element, selector)\n                    && nodeContains(context, eventTarget)\n                    && nodeContains(context, element)) {\n\n                    var listeners = delegated.listeners[i];\n\n                    fakeEvent.currentTarget = element;\n\n                    for (var j = 0; j < listeners.length; j++) {\n                        if (listeners[j][1] === useCapture) {\n                            listeners[j][0](fakeEvent);\n                        }\n                    }\n                }\n            }\n\n            element = parentElement(element);\n        }\n    }\n\n    function delegateUseCapture (event) {\n        return delegateListener.call(this, event, true);\n    }\n\n    interactables.indexOfElement = function indexOfElement (element, context) {\n        context = context || document;\n\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if ((interactable.selector === element\n                && (interactable._context === context))\n                || (!interactable.selector && interactable._element === element)) {\n\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    interactables.get = function interactableGet (element, options) {\n        return this[this.indexOfElement(element, options && options.context)];\n    };\n\n    interactables.forEachSelector = function (callback) {\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if (!interactable.selector) {\n                continue;\n            }\n\n            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n    };\n\n    /*\\\n     * interact\n     [ method ]\n     *\n     * The methods of this variable can be used to set elements as\n     * interactables and also to change various default settings.\n     *\n     * Calling it as a function and passing an element or a valid CSS selector\n     * string returns an Interactable object which has various methods to\n     * configure it.\n     *\n     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n     = (object) An @Interactable\n     *\n     > Usage\n     | interact(document.getElementById('draggable')).draggable(true);\n     |\n     | var rectables = interact('rect');\n     | rectables\n     |     .gesturable(true)\n     |     .on('gesturemove', function (event) {\n     |         // something cool...\n     |     })\n     |     .autoScroll(true);\n    \\*/\n    function interact (element, options) {\n        return interactables.get(element, options) || new Interactable(element, options);\n    }\n\n    /*\\\n     * Interactable\n     [ property ]\n     **\n     * Object type returned by @interact\n    \\*/\n    function Interactable (element, options) {\n        this._element = element;\n        this._iEvents = this._iEvents || {};\n\n        var _window;\n\n        if (trySelector(element)) {\n            this.selector = element;\n\n            var context = options && options.context;\n\n            _window = context? getWindow(context) : window;\n\n            if (context && (_window.Node\n                    ? context instanceof _window.Node\n                    : (isElement(context) || context === _window.document))) {\n\n                this._context = context;\n            }\n        }\n        else {\n            _window = getWindow(element);\n\n            if (isElement(element, _window)) {\n\n                if (PointerEvent) {\n                    events.add(this._element, pEventTypes.down, listeners.pointerDown );\n                    events.add(this._element, pEventTypes.move, listeners.pointerHover);\n                }\n                else {\n                    events.add(this._element, 'mousedown' , listeners.pointerDown );\n                    events.add(this._element, 'mousemove' , listeners.pointerHover);\n                    events.add(this._element, 'touchstart', listeners.pointerDown );\n                    events.add(this._element, 'touchmove' , listeners.pointerHover);\n                }\n            }\n        }\n\n        this._doc = _window.document;\n\n        if (!contains(documents, this._doc)) {\n            listenToDocument(this._doc);\n        }\n\n        interactables.push(this);\n\n        this.set(options);\n    }\n\n    Interactable.prototype = {\n        setOnEvents: function (action, phases) {\n            if (action === 'drop') {\n                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n            }\n            else {\n                action = 'on' + action;\n\n                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.draggable\n         [ method ]\n         *\n         * Gets or sets whether drag actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of drag events\n         | var isDraggable = interact('ul li').draggable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n         = (object) This Interactable\n         | interact(element).draggable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // the axis in which the first movement must be\n         |     // for the drag sequence to start\n         |     // 'xy' by default - any direction\n         |     axis: 'x' || 'y' || 'xy',\n         |\n         |     // max number of drags that can happen concurrently\n         |     // with elements of this Interactable. Infinity by default\n         |     max: Infinity,\n         |\n         |     // max number of drags that can target the same element+Interactable\n         |     // 1 by default\n         |     maxPerElement: 2\n         | });\n        \\*/\n        draggable: function (options) {\n            if (isObject(options)) {\n                this.options.drag.enabled = options.enabled === false? false: true;\n                this.setPerAction('drag', options);\n                this.setOnEvents('drag', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.drag.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    delete this.options.drag.axis;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drag.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drag;\n        },\n\n        setPerAction: function (action, options) {\n            // for all the default per-action options\n            for (var option in options) {\n                // if this option exists for this action\n                if (option in defaultOptions[action]) {\n                    // if the option in the options arg is an object value\n                    if (isObject(options[option])) {\n                        // duplicate the object\n                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n                        }\n                    }\n                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n                        this.options[action][option].enabled = options[option];\n                    }\n                    else if (options[option] !== undefined) {\n                        // or if it's not undefined, do a plain assignment\n                        this.options[action][option] = options[option];\n                    }\n                }\n            }\n        },\n\n        /*\\\n         * Interactable.dropzone\n         [ method ]\n         *\n         * Returns or sets whether elements can be dropped onto this\n         * Interactable to trigger drop events\n         *\n         * Dropzones can receive the following events:\n         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n         *  - `dragmove` when a draggable that has entered the dropzone is moved\n         *  - `drop` when a draggable is dropped into this dropzone\n         *\n         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n         *\n         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n         *   - `'pointer'`, the pointer must be over the dropzone (default)\n         *   - `'center'`, the draggable element's center must be over the dropzone\n         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n         *       e.g. `0.5` for drop to happen when half of the area of the\n         *       draggable is over the dropzone\n         *\n         - options (boolean | object | null) #optional The new value to be set.\n         | interact('.drop').dropzone({\n         |   accept: '.can-drop' || document.getElementById('single-drop'),\n         |   overlap: 'pointer' || 'center' || zeroToOne\n         | }\n         = (boolean | object) The current setting or this Interactable\n        \\*/\n        dropzone: function (options) {\n            if (isObject(options)) {\n                this.options.drop.enabled = options.enabled === false? false: true;\n                this.setOnEvents('drop', options);\n\n                if (/^(pointer|center)$/.test(options.overlap)) {\n                    this.options.drop.overlap = options.overlap;\n                }\n                else if (isNumber(options.overlap)) {\n                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n                }\n                if ('accept' in options) {\n                  this.options.drop.accept = options.accept;\n                }\n                if ('checker' in options) {\n                  this.options.drop.checker = options.checker;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drop.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drop;\n        },\n\n        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n            var dropped = false;\n\n            // if the dropzone has no rect (eg. display: none)\n            // call the custom dropChecker or just return false\n            if (!(rect = rect || this.getRect(dropElement))) {\n                return (this.options.drop.checker\n                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n                    : false);\n            }\n\n            var dropOverlap = this.options.drop.overlap;\n\n            if (dropOverlap === 'pointer') {\n                var page = getPageXY(dragEvent),\n                    origin = getOriginXY(draggable, draggableElement),\n                    horizontal,\n                    vertical;\n\n                page.x += origin.x;\n                page.y += origin.y;\n\n                horizontal = (page.x > rect.left) && (page.x < rect.right);\n                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n                dropped = horizontal && vertical;\n            }\n\n            var dragRect = draggable.getRect(draggableElement);\n\n            if (dropOverlap === 'center') {\n                var cx = dragRect.left + dragRect.width  / 2,\n                    cy = dragRect.top  + dragRect.height / 2;\n\n                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n            }\n\n            if (isNumber(dropOverlap)) {\n                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n                dropped = overlapRatio >= dropOverlap;\n            }\n\n            if (this.options.drop.checker) {\n                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n            }\n\n            return dropped;\n        },\n\n        /*\\\n         * Interactable.dropChecker\n         [ method ]\n         *\n         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n         *\n         * Gets or sets the function used to check if a dragged element is\n         * over this Interactable.\n         *\n         - checker (function) #optional The function that will be called when checking for a drop\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         * The checker function takes the following arguments:\n         *\n         - dragEvent (InteractEvent) The related dragmove or dragend event\n         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n         - dropped (boolean) The value from the default drop checker\n         - dropzone (Interactable) The dropzone interactable\n         - dropElement (Element) The dropzone element\n         - draggable (Interactable) The Interactable being dragged\n         - draggableElement (Element) The actual element that's being dragged\n         *\n         > Usage:\n         | interact(target)\n         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n         |                       dropped,           // bool result of the default checker\n         |                       dropzone,          // dropzone Interactable\n         |                       dropElement,       // dropzone elemnt\n         |                       draggable,         // draggable Interactable\n         |                       draggableElement) {// draggable element\n         |\n         |   return dropped && event.target.hasAttribute('allow-drop');\n         | }\n        \\*/\n        dropChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.drop.checker = checker;\n\n                return this;\n            }\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.options.drop.checker;\n        },\n\n        /*\\\n         * Interactable.accept\n         [ method ]\n         *\n         * Deprecated. add an `accept` property to the options object passed to\n         * @Interactable.dropzone instead.\n         *\n         * Gets or sets the Element or CSS selector match that this\n         * Interactable accepts if it is a dropzone.\n         *\n         - newValue (Element | string | null) #optional\n         * If it is an Element, then only that element can be dropped into this dropzone.\n         * If it is a string, the element being dragged must match it as a selector.\n         * If it is null, the accept options is cleared - it accepts any element.\n         *\n         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n        \\*/\n        accept: function (newValue) {\n            if (isElement(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            // test if it is a valid CSS selector\n            if (trySelector(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.drop.accept;\n\n                return this;\n            }\n\n            return this.options.drop.accept;\n        },\n\n        /*\\\n         * Interactable.resizable\n         [ method ]\n         *\n         * Gets or sets whether resize actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of resize elements\n         | var isResizeable = interact('input[type=text]').resizable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n         = (object) This Interactable\n         | interact(element).resizable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     edges: {\n         |       top   : true,       // Use pointer coords to check for resize.\n         |       left  : false,      // Disable resizing from left edge.\n         |       bottom: '.resize-s',// Resize if pointer target matches selector\n         |       right : handleEl    // Resize if pointer target is the given Element\n         |     },\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height are adjusted at a 1:1 ratio.\n         |     square: false,\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height maintain the aspect ratio they had when resizing started.\n         |     preserveAspectRatio: false,\n         |\n         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n         |     // 'negate' will allow the rect to have negative width/height\n         |     // 'reposition' will keep the width/height positive by swapping\n         |     // the top and bottom edges and/or swapping the left and right edges\n         |     invert: 'none' || 'negate' || 'reposition'\n         |\n         |     // limit multiple resizes.\n         |     // See the explanation in the @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        resizable: function (options) {\n            if (isObject(options)) {\n                this.options.resize.enabled = options.enabled === false? false: true;\n                this.setPerAction('resize', options);\n                this.setOnEvents('resize', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.resize.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    this.options.resize.axis = defaultOptions.resize.axis;\n                }\n\n                if (isBool(options.preserveAspectRatio)) {\n                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n                }\n                else if (isBool(options.square)) {\n                    this.options.resize.square = options.square;\n                }\n\n                return this;\n            }\n            if (isBool(options)) {\n                this.options.resize.enabled = options;\n\n                return this;\n            }\n            return this.options.resize;\n        },\n\n        /*\\\n         * Interactable.squareResize\n         [ method ]\n         *\n         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n         *\n         * Gets or sets whether resizing is forced 1:1 aspect\n         *\n         = (boolean) Current setting\n         *\n         * or\n         *\n         - newValue (boolean) #optional\n         = (object) this Interactable\n        \\*/\n        squareResize: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.resize.square = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.resize.square;\n\n                return this;\n            }\n\n            return this.options.resize.square;\n        },\n\n        /*\\\n         * Interactable.gesturable\n         [ method ]\n         *\n         * Gets or sets whether multitouch gestures can be performed on the\n         * Interactable's element\n         *\n         = (boolean) Indicates if this can be the target of gesture events\n         | var isGestureable = interact(element).gesturable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n         = (object) this Interactable\n         | interact(element).gesturable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // limit multiple gestures.\n         |     // See the explanation in @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        gesturable: function (options) {\n            if (isObject(options)) {\n                this.options.gesture.enabled = options.enabled === false? false: true;\n                this.setPerAction('gesture', options);\n                this.setOnEvents('gesture', options);\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.gesture.enabled = options;\n\n                return this;\n            }\n\n            return this.options.gesture;\n        },\n\n        /*\\\n         * Interactable.autoScroll\n         [ method ]\n         **\n         * Deprecated. Add an `autoscroll` property to the options object\n         * passed to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets whether dragging and resizing near the edges of the\n         * window/container trigger autoScroll for this Interactable\n         *\n         = (object) Object with autoScroll properties\n         *\n         * or\n         *\n         - options (object | boolean) #optional\n         * options can be:\n         * - an object with margin, distance and interval properties,\n         * - true or false to enable or disable autoScroll or\n         = (Interactable) this Interactable\n        \\*/\n        autoScroll: function (options) {\n            if (isObject(options)) {\n                options = extend({ actions: ['drag', 'resize']}, options);\n            }\n            else if (isBool(options)) {\n                options = { actions: ['drag', 'resize'], enabled: options };\n            }\n\n            return this.setOptions('autoScroll', options);\n        },\n\n        /*\\\n         * Interactable.snap\n         [ method ]\n         **\n         * Deprecated. Add a `snap` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how action coordinates are snapped. By\n         * default, snapping is relative to the pointer coordinates. You can\n         * change this by setting the\n         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n         **\n         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | interact(document.querySelector('#thing')).snap({\n         |     targets: [\n         |         // snap to this specific point\n         |         {\n         |             x: 100,\n         |             y: 100,\n         |             range: 25\n         |         },\n         |         // give this function the x and y page coords and snap to the object returned\n         |         function (x, y) {\n         |             return {\n         |                 x: x,\n         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n         |                 range: 40\n         |             };\n         |         },\n         |         // create a function that snaps to a grid\n         |         interact.createSnapGrid({\n         |             x: 50,\n         |             y: 50,\n         |             range: 10,              // optional\n         |             offset: { x: 5, y: 10 } // optional\n         |         })\n         |     ],\n         |     // do not snap during normal movement.\n         |     // Instead, trigger only one snapped move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     relativePoints: [\n         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n         |         { x: 1, y: 1 },  // and also to the bottom right\n         |     ],  \n         |\n         |     // offset the snap target coordinates\n         |     // can be an object with x/y or 'startCoords'\n         |     offset: { x: 50, y: 50 }\n         |   }\n         | });\n        \\*/\n        snap: function (options) {\n            var ret = this.setOptions('snap', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        setOptions: function (option, options) {\n            var actions = options && isArray(options.actions)\n                    ? options.actions\n                    : ['drag'];\n\n            var i;\n\n            if (isObject(options) || isBool(options)) {\n                for (i = 0; i < actions.length; i++) {\n                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\n                    if (!isObject(this.options[action])) { continue; }\n\n                    var thisOption = this.options[action][option];\n\n                    if (isObject(options)) {\n                        extend(thisOption, options);\n                        thisOption.enabled = options.enabled === false? false: true;\n\n                        if (option === 'snap') {\n                            if (thisOption.mode === 'grid') {\n                                thisOption.targets = [\n                                    interact.createSnapGrid(extend({\n                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n                                    }, thisOption.grid || {}))\n                                ];\n                            }\n                            else if (thisOption.mode === 'anchor') {\n                                thisOption.targets = thisOption.anchors;\n                            }\n                            else if (thisOption.mode === 'path') {\n                                thisOption.targets = thisOption.paths;\n                            }\n\n                            if ('elementOrigin' in options) {\n                                thisOption.relativePoints = [options.elementOrigin];\n                            }\n                        }\n                    }\n                    else if (isBool(options)) {\n                        thisOption.enabled = options;\n                    }\n                }\n\n                return this;\n            }\n\n            var ret = {},\n                allActions = ['drag', 'resize', 'gesture'];\n\n            for (i = 0; i < allActions.length; i++) {\n                if (option in defaultOptions[allActions[i]]) {\n                    ret[allActions[i]] = this.options[allActions[i]][option];\n                }\n            }\n\n            return ret;\n        },\n\n\n        /*\\\n         * Interactable.inertia\n         [ method ]\n         **\n         * Deprecated. Add an `inertia` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how events continue to run after the pointer is released\n         **\n         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | // enable and use default settings\n         | interact(element).inertia(true);\n         |\n         | // enable and use custom settings\n         | interact(element).inertia({\n         |     // value greater than 0\n         |     // high values slow the object down more quickly\n         |     resistance     : 16,\n         |\n         |     // the minimum launch speed (pixels per second) that results in inertia start\n         |     minSpeed       : 200,\n         |\n         |     // inertia will stop when the object slows down to this speed\n         |     endSpeed       : 20,\n         |\n         |     // boolean; should actions be resumed when the pointer goes down during inertia\n         |     allowResume    : true,\n         |\n         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n         |     zeroResumeDelta: false,\n         |\n         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n         |     // the pointer without triggering inertia will animate from the release\n         |     // point to the snaped/restricted point in the given amount of time (ms)\n         |     smoothEndDuration: 300,\n         |\n         |     // an array of action types that can have inertia (no gesture)\n         |     actions        : ['drag', 'resize']\n         | });\n         |\n         | // reset custom settings and use all defaults\n         | interact(element).inertia(null);\n        \\*/\n        inertia: function (options) {\n            var ret = this.setOptions('inertia', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        getAction: function (pointer, event, interaction, element) {\n            var action = this.defaultActionChecker(pointer, interaction, element);\n\n            if (this.options.actionChecker) {\n                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n            }\n\n            return action;\n        },\n\n        defaultActionChecker: defaultActionChecker,\n\n        /*\\\n         * Interactable.actionChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check action to be performed on\n         * pointerDown\n         *\n         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         | interact('.resize-drag')\n         |   .resizable(true)\n         |   .draggable(true)\n         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n         |\n         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n         |     // force drag with handle target\n         |     action.name = drag;\n         |   }\n         |   else {\n         |     // resize from the top and right edges\n         |     action.name  = 'resize';\n         |     action.edges = { top: true, right: true };\n         |   }\n         |\n         |   return action;\n         | });\n        \\*/\n        actionChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.actionChecker = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.actionChecker;\n\n                return this;\n            }\n\n            return this.options.actionChecker;\n        },\n\n        /*\\\n         * Interactable.getRect\n         [ method ]\n         *\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using @Interactable.rectChecker.\n         *\n         - element (Element) #optional The element to measure.\n         = (object) The object's bounding rectangle.\n         o {\n         o     top   : 0,\n         o     left  : 0,\n         o     bottom: 0,\n         o     right : 0,\n         o     width : 0,\n         o     height: 0\n         o }\n        \\*/\n        getRect: function rectCheck (element) {\n            element = element || this._element;\n\n            if (this.selector && !(isElement(element))) {\n                element = this._context.querySelector(this.selector);\n            }\n\n            return getElementRect(element);\n        },\n\n        /*\\\n         * Interactable.rectChecker\n         [ method ]\n         *\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n         = (function | object) The checker function or this Interactable\n        \\*/\n        rectChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.getRect = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.getRect;\n        },\n\n        /*\\\n         * Interactable.styleCursor\n         [ method ]\n         *\n         * Returns or sets whether the action that would be performed when the\n         * mouse on the element are checked on `mousemove` so that the cursor\n         * may be styled appropriately\n         *\n         - newValue (boolean) #optional\n         = (boolean | Interactable) The current setting or this Interactable\n        \\*/\n        styleCursor: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.styleCursor = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.styleCursor;\n\n                return this;\n            }\n\n            return this.options.styleCursor;\n        },\n\n        /*\\\n         * Interactable.preventDefault\n         [ method ]\n         *\n         * Returns or sets whether to prevent the browser's default behaviour\n         * in response to pointer events. Can be set to:\n         *  - `'always'` to always prevent\n         *  - `'never'` to never prevent\n         *  - `'auto'` to let interact.js try to determine what would be best\n         *\n         - newValue (string) #optional `true`, `false` or `'auto'`\n         = (string | Interactable) The current setting or this Interactable\n        \\*/\n        preventDefault: function (newValue) {\n            if (/^(always|never|auto)$/.test(newValue)) {\n                this.options.preventDefault = newValue;\n                return this;\n            }\n\n            if (isBool(newValue)) {\n                this.options.preventDefault = newValue? 'always' : 'never';\n                return this;\n            }\n\n            return this.options.preventDefault;\n        },\n\n        /*\\\n         * Interactable.origin\n         [ method ]\n         *\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n         * OR\n         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n         **\n         = (object) The current origin or this Interactable\n        \\*/\n        origin: function (newValue) {\n            if (trySelector(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n            else if (isObject(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n\n            return this.options.origin;\n        },\n\n        /*\\\n         * Interactable.deltaSource\n         [ method ]\n         *\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n         = (string | object) The current deltaSource or this Interactable\n        \\*/\n        deltaSource: function (newValue) {\n            if (newValue === 'page' || newValue === 'client') {\n                this.options.deltaSource = newValue;\n\n                return this;\n            }\n\n            return this.options.deltaSource;\n        },\n\n        /*\\\n         * Interactable.restrict\n         [ method ]\n         **\n         * Deprecated. Add a `restrict` property to the options object passed to\n         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n         *\n         * Returns or sets the rectangles within which actions on this\n         * interactable (after snap calculations) are restricted. By default,\n         * restricting is relative to the pointer coordinates. You can change\n         * this by setting the\n         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n         **\n         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n         = (object) The current restrictions object or this Interactable\n         **\n         | interact(element).restrict({\n         |     // the rect will be `interact.getElementRect(element.parentNode)`\n         |     drag: element.parentNode,\n         |\n         |     // x and y are relative to the the interactable's origin\n         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n         | })\n         |\n         | interact('.draggable').restrict({\n         |     // the rect will be the selected element's parent\n         |     drag: 'parent',\n         |\n         |     // do not restrict during normal movement.\n         |     // Instead, trigger only one restricted move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n         | });\n        \\*/\n        restrict: function (options) {\n            if (!isObject(options)) {\n                return this.setOptions('restrict', options);\n            }\n\n            var actions = ['drag', 'resize', 'gesture'],\n                ret;\n\n            for (var i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                if (action in options) {\n                    var perAction = extend({\n                            actions: [action],\n                            restriction: options[action]\n                        }, options);\n\n                    ret = this.setOptions('restrict', perAction);\n                }\n            }\n\n            return ret;\n        },\n\n        /*\\\n         * Interactable.context\n         [ method ]\n         *\n         * Gets the selector context Node of the Interactable. The default is `window.document`.\n         *\n         = (Node) The context Node of this Interactable\n         **\n        \\*/\n        context: function () {\n            return this._context;\n        },\n\n        _context: document,\n\n        /*\\\n         * Interactable.ignoreFrom\n         [ method ]\n         *\n         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n         * event or any of it's parents match the given CSS selector or\n         * Element, no drag/resize/gesture is started.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n         = (string | Element | object) The current ignoreFrom value or this Interactable\n         **\n         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n         | // or\n         | interact(element).ignoreFrom('input, textarea, a');\n        \\*/\n        ignoreFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            return this.options.ignoreFrom;\n        },\n\n        /*\\\n         * Interactable.allowFrom\n         [ method ]\n         *\n         * A drag/resize/gesture is started only If the target of the\n         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n         * parents match the given CSS selector or Element.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n         = (string | Element | object) The current allowFrom value or this Interactable\n         **\n         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n         | // or\n         | interact(element).allowFrom('.handle');\n        \\*/\n        allowFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            return this.options.allowFrom;\n        },\n\n        /*\\\n         * Interactable.element\n         [ method ]\n         *\n         * If this is not a selector Interactable, it returns the element this\n         * interactable represents\n         *\n         = (Element) HTML / SVG Element\n        \\*/\n        element: function () {\n            return this._element;\n        },\n\n        /*\\\n         * Interactable.fire\n         [ method ]\n         *\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n         = (Interactable) this Interactable\n        \\*/\n        fire: function (iEvent) {\n            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n                return this;\n            }\n\n            var listeners,\n                i,\n                len,\n                onEvent = 'on' + iEvent.type,\n                funcName = '';\n\n            // Interactable#on() listeners\n            if (iEvent.type in this._iEvents) {\n                listeners = this._iEvents[iEvent.type];\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            // interactable.onevent listener\n            if (isFunction(this[onEvent])) {\n                funcName = this[onEvent].name;\n                this[onEvent](iEvent);\n            }\n\n            // interact.on() listeners\n            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.on\n         [ method ]\n         *\n         * Binds a listener for an InteractEvent or DOM event.\n         *\n         - eventType  (string | array | object) The types of events to listen for\n         - listener   (function) The function to be called on the given event(s)\n         - useCapture (boolean) #optional useCapture flag for addEventListener\n         = (object) This Interactable\n        \\*/\n        on: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.on(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.on(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (contains(eventTypes, eventType)) {\n                // if this type of event was never bound to this Interactable\n                if (!(eventType in this._iEvents)) {\n                    this._iEvents[eventType] = [listener];\n                }\n                else {\n                    this._iEvents[eventType].push(listener);\n                }\n            }\n            // delegated event for selector\n            else if (this.selector) {\n                if (!delegatedEvents[eventType]) {\n                    delegatedEvents[eventType] = {\n                        selectors: [],\n                        contexts : [],\n                        listeners: []\n                    };\n\n                    // add delegate listener functions\n                    for (i = 0; i < documents.length; i++) {\n                        events.add(documents[i], eventType, delegateListener);\n                        events.add(documents[i], eventType, delegateUseCapture, true);\n                    }\n                }\n\n                var delegated = delegatedEvents[eventType],\n                    index;\n\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n                        break;\n                    }\n                }\n\n                if (index === -1) {\n                    index = delegated.selectors.length;\n\n                    delegated.selectors.push(this.selector);\n                    delegated.contexts .push(this._context);\n                    delegated.listeners.push([]);\n                }\n\n                // keep listener and useCapture flag\n                delegated.listeners[index].push([listener, useCapture]);\n            }\n            else {\n                events.add(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.off\n         [ method ]\n         *\n         * Removes an InteractEvent or DOM event listener\n         *\n         - eventType  (string | array | object) The types of events that were listened for\n         - listener   (function) The listener function to be removed\n         - useCapture (boolean) #optional useCapture flag for removeEventListener\n         = (object) This Interactable\n        \\*/\n        off: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.off(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.off(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            var eventList,\n                index = -1;\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // if it is an action event type\n            if (contains(eventTypes, eventType)) {\n                eventList = this._iEvents[eventType];\n\n                if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n                    this._iEvents[eventType].splice(index, 1);\n                }\n            }\n            // delegated event\n            else if (this.selector) {\n                var delegated = delegatedEvents[eventType],\n                    matchFound = false;\n\n                if (!delegated) { return this; }\n\n                // count from last index of delegated to 0\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    // look for matching selector and context Node\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n\n                        var listeners = delegated.listeners[index];\n\n                        // each item of the listeners array is an array: [function, useCaptureFlag]\n                        for (i = listeners.length - 1; i >= 0; i--) {\n                            var fn = listeners[i][0],\n                                useCap = listeners[i][1];\n\n                            // check if the listener functions and useCapture flags match\n                            if (fn === listener && useCap === useCapture) {\n                                // remove the listener from the array of listeners\n                                listeners.splice(i, 1);\n\n                                // if all listeners for this interactable have been removed\n                                // remove the interactable from the delegated arrays\n                                if (!listeners.length) {\n                                    delegated.selectors.splice(index, 1);\n                                    delegated.contexts .splice(index, 1);\n                                    delegated.listeners.splice(index, 1);\n\n                                    // remove delegate function from context\n                                    events.remove(this._context, eventType, delegateListener);\n                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\n                                    // remove the arrays if they are empty\n                                    if (!delegated.selectors.length) {\n                                        delegatedEvents[eventType] = null;\n                                    }\n                                }\n\n                                // only remove one listener\n                                matchFound = true;\n                                break;\n                            }\n                        }\n\n                        if (matchFound) { break; }\n                    }\n                }\n            }\n            // remove listener from this Interatable's element\n            else {\n                events.remove(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.set\n         [ method ]\n         *\n         * Reset the options of this Interactable\n         - options (object) The new settings to apply\n         = (object) This Interactable\n        \\*/\n        set: function (options) {\n            if (!isObject(options)) {\n                options = {};\n            }\n\n            this.options = extend({}, defaultOptions.base);\n\n            var i,\n                actions = ['drag', 'drop', 'resize', 'gesture'],\n                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\n            for (i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                this.options[action] = extend({}, defaultOptions[action]);\n\n                this.setPerAction(action, perActions);\n\n                this[methods[i]](options[action]);\n            }\n\n            var settings = [\n                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n                    'rectChecker', 'styleCursor'\n                ];\n\n            for (i = 0, len = settings.length; i < len; i++) {\n                var setting = settings[i];\n\n                this.options[setting] = defaultOptions.base[setting];\n\n                if (setting in options) {\n                    this[setting](options[setting]);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.unset\n         [ method ]\n         *\n         * Remove this interactable from the list of interactables and remove\n         * it's drag, drop, resize and gesture capabilities\n         *\n         = (object) @interact\n        \\*/\n        unset: function () {\n            events.remove(this._element, 'all');\n\n            if (!isString(this.selector)) {\n                events.remove(this, 'all');\n                if (this.options.styleCursor) {\n                    this._element.style.cursor = '';\n                }\n            }\n            else {\n                // remove delegated events\n                for (var type in delegatedEvents) {\n                    var delegated = delegatedEvents[type];\n\n                    for (var i = 0; i < delegated.selectors.length; i++) {\n                        if (delegated.selectors[i] === this.selector\n                            && delegated.contexts[i] === this._context) {\n\n                            delegated.selectors.splice(i, 1);\n                            delegated.contexts .splice(i, 1);\n                            delegated.listeners.splice(i, 1);\n\n                            // remove the arrays if they are empty\n                            if (!delegated.selectors.length) {\n                                delegatedEvents[type] = null;\n                            }\n                        }\n\n                        events.remove(this._context, type, delegateListener);\n                        events.remove(this._context, type, delegateUseCapture, true);\n\n                        break;\n                    }\n                }\n            }\n\n            this.dropzone(false);\n\n            interactables.splice(indexOf(interactables, this), 1);\n\n            return interact;\n        }\n    };\n\n    function warnOnce (method, message) {\n        var warned = false;\n\n        return function () {\n            if (!warned) {\n                window.console.warn(message);\n                warned = true;\n            }\n\n            return method.apply(this, arguments);\n        };\n    }\n\n    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\n    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n    Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\n    /*\\\n     * interact.isSet\n     [ method ]\n     *\n     * Check if an element has been set\n     - element (Element) The Element being searched for\n     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n    \\*/\n    interact.isSet = function(element, options) {\n        return interactables.indexOfElement(element, options && options.context) !== -1;\n    };\n\n    /*\\\n     * interact.on\n     [ method ]\n     *\n     * Adds a global listener for an InteractEvent or adds a DOM event to\n     * `document`\n     *\n     - type       (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) interact\n    \\*/\n    interact.on = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.on(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.on(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        // if it is an InteractEvent type, add listener to globalEvents\n        if (contains(eventTypes, type)) {\n            // if this type of event was never bound\n            if (!globalEvents[type]) {\n                globalEvents[type] = [listener];\n            }\n            else {\n                globalEvents[type].push(listener);\n            }\n        }\n        // If non InteractEvent type, addEventListener to document\n        else {\n            events.add(document, type, listener, useCapture);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.off\n     [ method ]\n     *\n     * Removes a global InteractEvent listener or DOM event from `document`\n     *\n     - type       (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) interact\n     \\*/\n    interact.off = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.off(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.off(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        if (!contains(eventTypes, type)) {\n            events.remove(document, type, listener, useCapture);\n        }\n        else {\n            var index;\n\n            if (type in globalEvents\n                && (index = indexOf(globalEvents[type], listener)) !== -1) {\n                globalEvents[type].splice(index, 1);\n            }\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.enableDragging\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether dragging is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableDragging = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.drag = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.drag;\n    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableResizing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether resizing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableResizing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.resize = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.resize;\n    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableGesturing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether gesturing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableGesturing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.gesture = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.gesture;\n    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\n    interact.eventTypes = eventTypes;\n\n    /*\\\n     * interact.debug\n     [ method ]\n     *\n     * Returns debugging data\n     = (object) An object with properties that outline the current state and expose internal functions and variables\n    \\*/\n    interact.debug = function () {\n        var interaction = interactions[0] || new Interaction();\n\n        return {\n            interactions          : interactions,\n            target                : interaction.target,\n            dragging              : interaction.dragging,\n            resizing              : interaction.resizing,\n            gesturing             : interaction.gesturing,\n            prepared              : interaction.prepared,\n            matches               : interaction.matches,\n            matchElements         : interaction.matchElements,\n\n            prevCoords            : interaction.prevCoords,\n            startCoords           : interaction.startCoords,\n\n            pointerIds            : interaction.pointerIds,\n            pointers              : interaction.pointers,\n            addPointer            : listeners.addPointer,\n            removePointer         : listeners.removePointer,\n            recordPointer        : listeners.recordPointer,\n\n            snap                  : interaction.snapStatus,\n            restrict              : interaction.restrictStatus,\n            inertia               : interaction.inertiaStatus,\n\n            downTime              : interaction.downTimes[0],\n            downEvent             : interaction.downEvent,\n            downPointer           : interaction.downPointer,\n            prevEvent             : interaction.prevEvent,\n\n            Interactable          : Interactable,\n            interactables         : interactables,\n            pointerIsDown         : interaction.pointerIsDown,\n            defaultOptions        : defaultOptions,\n            defaultActionChecker  : defaultActionChecker,\n\n            actionCursors         : actionCursors,\n            dragMove              : listeners.dragMove,\n            resizeMove            : listeners.resizeMove,\n            gestureMove           : listeners.gestureMove,\n            pointerUp             : listeners.pointerUp,\n            pointerDown           : listeners.pointerDown,\n            pointerMove           : listeners.pointerMove,\n            pointerHover          : listeners.pointerHover,\n\n            eventTypes            : eventTypes,\n\n            events                : events,\n            globalEvents          : globalEvents,\n            delegatedEvents       : delegatedEvents,\n\n            prefixedPropREs       : prefixedPropREs\n        };\n    };\n\n    // expose the functions used to calculate multi-touch properties\n    interact.getPointerAverage = pointerAverage;\n    interact.getTouchBBox     = touchBBox;\n    interact.getTouchDistance = touchDistance;\n    interact.getTouchAngle    = touchAngle;\n\n    interact.getElementRect         = getElementRect;\n    interact.getElementClientRect   = getElementClientRect;\n    interact.matchesSelector        = matchesSelector;\n    interact.closest                = closest;\n\n    /*\\\n     * interact.margin\n     [ method ]\n     *\n     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n     * Returns or sets the margin for autocheck resizing used in\n     * @Interactable.getAction. That is the distance from the bottom and right\n     * edges of an element clicking in which will start resizing\n     *\n     - newValue (number) #optional\n     = (number | interact) The current margin value or interact\n    \\*/\n    interact.margin = warnOnce(function (newvalue) {\n        if (isNumber(newvalue)) {\n            margin = newvalue;\n\n            return interact;\n        }\n        return margin;\n    },\n    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\n    /*\\\n     * interact.supportsTouch\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports touch input\n    \\*/\n    interact.supportsTouch = function () {\n        return supportsTouch;\n    };\n\n    /*\\\n     * interact.supportsPointerEvent\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports PointerEvents\n    \\*/\n    interact.supportsPointerEvent = function () {\n        return supportsPointerEvent;\n    };\n\n    /*\\\n     * interact.stop\n     [ method ]\n     *\n     * Cancels all interactions (end events are not fired)\n     *\n     - event (Event) An event on which to call preventDefault()\n     = (object) interact\n    \\*/\n    interact.stop = function (event) {\n        for (var i = interactions.length - 1; i >= 0; i--) {\n            interactions[i].stop(event);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.dynamicDrop\n     [ method ]\n     *\n     * Returns or sets whether the dimensions of dropzone elements are\n     * calculated on every dragmove or only on dragstart for the default\n     * dropChecker\n     *\n     - newValue (boolean) #optional True to check on each move. False to check only before start\n     = (boolean | interact) The current setting or interact\n    \\*/\n    interact.dynamicDrop = function (newValue) {\n        if (isBool(newValue)) {\n            //if (dragging && dynamicDrop !== newValue && !newValue) {\n                //calcRects(dropzones);\n            //}\n\n            dynamicDrop = newValue;\n\n            return interact;\n        }\n        return dynamicDrop;\n    };\n\n    /*\\\n     * interact.pointerMoveTolerance\n     [ method ]\n     * Returns or sets the distance the pointer must be moved before an action\n     * sequence occurs. This also affects tolerance for tap events.\n     *\n     - newValue (number) #optional The movement from the start position must be greater than this value\n     = (number | Interactable) The current setting or interact\n    \\*/\n    interact.pointerMoveTolerance = function (newValue) {\n        if (isNumber(newValue)) {\n            pointerMoveTolerance = newValue;\n\n            return this;\n        }\n\n        return pointerMoveTolerance;\n    };\n\n    /*\\\n     * interact.maxInteractions\n     [ method ]\n     **\n     * Returns or sets the maximum number of concurrent interactions allowed.\n     * By default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables\n     * and elements, you need to enable it in the draggable, resizable and\n     * gesturable `'max'` and `'maxPerElement'` options.\n     **\n     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n    \\*/\n    interact.maxInteractions = function (newValue) {\n        if (isNumber(newValue)) {\n            maxInteractions = newValue;\n\n            return this;\n        }\n\n        return maxInteractions;\n    };\n\n    interact.createSnapGrid = function (grid) {\n        return function (x, y) {\n            var offsetX = 0,\n                offsetY = 0;\n\n            if (isObject(grid.offset)) {\n                offsetX = grid.offset.x;\n                offsetY = grid.offset.y;\n            }\n\n            var gridx = Math.round((x - offsetX) / grid.x),\n                gridy = Math.round((y - offsetY) / grid.y),\n\n                newX = gridx * grid.x + offsetX,\n                newY = gridy * grid.y + offsetY;\n\n            return {\n                x: newX,\n                y: newY,\n                range: grid.range\n            };\n        };\n    };\n\n    function endAllInteractions (event) {\n        for (var i = 0; i < interactions.length; i++) {\n            interactions[i].pointerEnd(event, event);\n        }\n    }\n\n    function listenToDocument (doc) {\n        if (contains(documents, doc)) { return; }\n\n        var win = doc.defaultView || doc.parentWindow;\n\n        // add delegate event listener\n        for (var eventType in delegatedEvents) {\n            events.add(doc, eventType, delegateListener);\n            events.add(doc, eventType, delegateUseCapture, true);\n        }\n\n        if (PointerEvent) {\n            if (PointerEvent === win.MSPointerEvent) {\n                pEventTypes = {\n                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n            }\n            else {\n                pEventTypes = {\n                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n            }\n\n            events.add(doc, pEventTypes.down  , listeners.selectorDown );\n            events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n            events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n            events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n            events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n        }\n        else {\n            events.add(doc, 'mousedown', listeners.selectorDown);\n            events.add(doc, 'mousemove', listeners.pointerMove );\n            events.add(doc, 'mouseup'  , listeners.pointerUp   );\n            events.add(doc, 'mouseover', listeners.pointerOver );\n            events.add(doc, 'mouseout' , listeners.pointerOut  );\n\n            events.add(doc, 'touchstart' , listeners.selectorDown );\n            events.add(doc, 'touchmove'  , listeners.pointerMove  );\n            events.add(doc, 'touchend'   , listeners.pointerUp    );\n            events.add(doc, 'touchcancel', listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, 'mousemove', listeners.autoScrollMove);\n            events.add(doc, 'touchmove', listeners.autoScrollMove);\n        }\n\n        events.add(win, 'blur', endAllInteractions);\n\n        try {\n            if (win.frameElement) {\n                var parentDoc = win.frameElement.ownerDocument,\n                    parentWindow = parentDoc.defaultView;\n\n                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n                events.add(parentWindow, 'blur'         , endAllInteractions );\n            }\n        }\n        catch (error) {\n            interact.windowParentError = error;\n        }\n\n        // prevent native HTML5 drag on interact.js target elements\n        events.add(doc, 'dragstart', function (event) {\n            for (var i = 0; i < interactions.length; i++) {\n                var interaction = interactions[i];\n\n                if (interaction.element\n                    && (interaction.element === event.target\n                        || nodeContains(interaction.element, event.target))) {\n\n                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n                    return;\n                }\n            }\n        });\n\n        if (events.useAttachEvent) {\n            // For IE's lack of Event#preventDefault\n            events.add(doc, 'selectstart', function (event) {\n                var interaction = interactions[0];\n\n                if (interaction.currentAction()) {\n                    interaction.checkAndPreventDefault(event);\n                }\n            });\n\n            // For IE's bad dblclick event sequence\n            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n        }\n\n        documents.push(doc);\n    }\n\n    listenToDocument(document);\n\n    function indexOf (array, target) {\n        for (var i = 0, len = array.length; i < len; i++) {\n            if (array[i] === target) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    function contains (array, target) {\n        return indexOf(array, target) !== -1;\n    }\n\n    function matchesSelector (element, selector, nodeList) {\n        if (ie8MatchesSelector) {\n            return ie8MatchesSelector(element, selector, nodeList);\n        }\n\n        // remove /deep/ from selectors if shadowDOM polyfill is used\n        if (window !== realWindow) {\n            selector = selector.replace(/\\/deep\\//g, ' ');\n        }\n\n        return element[prefixedMatchesSelector](selector);\n    }\n\n    function matchesUpTo (element, selector, limit) {\n        while (isElement(element)) {\n            if (matchesSelector(element, selector)) {\n                return true;\n            }\n\n            element = parentElement(element);\n\n            if (element === limit) {\n                return matchesSelector(element, selector);\n            }\n        }\n\n        return false;\n    }\n\n    // For IE8's lack of an Element#matchesSelector\n    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n        ie8MatchesSelector = function (element, selector, elems) {\n            elems = elems || element.parentNode.querySelectorAll(selector);\n\n            for (var i = 0, len = elems.length; i < len; i++) {\n                if (elems[i] === element) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    // requestAnimationFrame polyfill\n    (function() {\n        var lastTime = 0,\n            vendors = ['ms', 'moz', 'webkit', 'o'];\n\n        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n        }\n\n        if (!reqFrame) {\n            reqFrame = function(callback) {\n                var currTime = new Date().getTime(),\n                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n                    id = setTimeout(function() { callback(currTime + timeToCall); },\n                  timeToCall);\n                lastTime = currTime + timeToCall;\n                return id;\n            };\n        }\n\n        if (!cancelFrame) {\n            cancelFrame = function(id) {\n                clearTimeout(id);\n            };\n        }\n    }());\n\n    /* global exports: true, module, define */\n\n    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = interact;\n        }\n        exports.interact = interact;\n    }\n    // AMD\n    else if (typeof define === 'function' && define.amd) {\n        define('interact', function() {\n            return interact;\n        });\n    }\n    else {\n        realWindow.interact = interact;\n    }\n\n} (typeof window === 'undefined'? undefined : window));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/interact.js/interact.js\n ** module id = 30\n ** module chunks = 0 1 2 3 4 5\n **/","module.exports = \" <div class=\\\"w-app card\\\" v-bind:class=\\\"[loading ? 'isLoading': '', isDeleted ? 'animated zoomOutDown': '', isMax ? 'is-fullwidth' : '']\\\" @click=bringToFront @mousedown=bringToFront @animationend=makeMe draggable=true tabindex=0 _v-ca6846e8=\\\"\\\"> <header class=card-header _v-ca6846e8=\\\"\\\"> <p class=card-header-title _v-ca6846e8=\\\"\\\"> {{title}} </p> <a class=card-header-icon _v-ca6846e8=\\\"\\\"> <i class=\\\"fa fa-minus\\\" _v-ca6846e8=\\\"\\\"></i> </a> <a class=card-header-icon @click=maxApp _v-ca6846e8=\\\"\\\"> <i class=fa v-bind:class=\\\"[isMax ? 'fa-compress': 'fa-expand']\\\" _v-ca6846e8=\\\"\\\"></i> </a> <a class=card-header-icon @click=closeApp _v-ca6846e8=\\\"\\\"> <i class=\\\"fa fa-times\\\" _v-ca6846e8=\\\"\\\"></i> </a> </header> <header v-if=hasSubNav class=\\\"card-header card-header--subnav\\\" _v-ca6846e8=\\\"\\\"> <slot name=header _v-ca6846e8=\\\"\\\"></slot> </header> <div class=card-content _v-ca6846e8=\\\"\\\"> <div class=content _v-ca6846e8=\\\"\\\"> <slot _v-ca6846e8=\\\"\\\"></slot> </div> </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/template-rewriter.js?id=_v-ca6846e8!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/wApp.vue\n ** module id = 33\n ** module chunks = 0 1 2 3 4 5\n **/","var __vue_script__, __vue_template__\nrequire(\"!!./../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\")\nrequire(\"!!./../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/vue-loader/lib/selector.js?type=script&index=0!./wApp.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/vue-loader/lib/template-rewriter.js?id=_v-ca6846e8!./../../node_modules/vue-loader/lib/selector.js?type=template&index=0!./wApp.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/wApp.vue\n ** module id = 34\n ** module chunks = 0 1 2 3 4 5\n **/","module.exports = {};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iterators.js\n ** module id = 42\n ** module chunks = 2 3\n **/","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_set-to-string-tag.js\n ** module id = 58\n ** module chunks = 2 3\n **/","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-define.js\n ** module id = 70\n ** module chunks = 2 3\n **/","module.exports = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_library.js\n ** module id = 71\n ** module chunks = 2 3\n **/","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-create.js\n ** module id = 87\n ** module chunks = 2 3\n **/","module.exports = require('./_hide');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_redefine.js\n ** module id = 89\n ** module chunks = 2 3\n **/","module.exports = function(){ /* empty */ };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_add-to-unscopables.js\n ** module id = 105\n ** module chunks = 2 3\n **/","module.exports = require('./_global').document && document.documentElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_html.js\n ** module id = 108\n ** module chunks = 2 3\n **/","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-create.js\n ** module id = 109\n ** module chunks = 2 3\n **/","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-step.js\n ** module id = 110\n ** module chunks = 2 3\n **/","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-dps.js\n ** module id = 111\n ** module chunks = 2 3\n **/","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gpo.js\n ** module id = 113\n ** module chunks = 2 3\n **/","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_string-at.js\n ** module id = 114\n ** module chunks = 2 3\n **/","var global         = require('./_global')\n  , core           = require('./_core')\n  , LIBRARY        = require('./_library')\n  , wksExt         = require('./_wks-ext')\n  , defineProperty = require('./_object-dp').f;\nmodule.exports = function(name){\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks-define.js\n ** module id = 116\n ** module chunks = 2\n **/","exports.f = require('./_wks');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks-ext.js\n ** module id = 117\n ** module chunks = 2\n **/","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.array.iterator.js\n ** module id = 118\n ** module chunks = 2 3\n **/","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.string.iterator.js\n ** module id = 119\n ** module chunks = 2 3\n **/","require('./es6.array.iterator');\nvar global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , TO_STRING_TAG = require('./_wks')('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/web.dom.iterable.js\n ** module id = 120\n ** module chunks = 2 3\n **/","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys      = require('./_object-keys-internal')\n  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return $keys(O, hiddenKeys);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopn.js\n ** module id = 144\n ** module chunks = 2\n **/","import * as apps from '../../Applications.vue'\nlet localforage = require('localforage')\nexport default {\n  data () {\n    console.log('apps:', apps.comps)\n    return {\n      // apps: Object.keys(apps.comps)\n    }\n  },\n  cmd (vue, command) {\n    let myCmd = command.split(' ')\n    switch (myCmd[0]) {\n      case 'test':\n        return {type: 'string', data: 'success'}\n      case 'touch':\n        if (myCmd.length > 1) {\n          localforage.setItem(myCmd[1], '')\n          .then(() => {\n            vue.results.push({dataType: 'string', data: myCmd[1], command: command})\n          })\n          .catch(function (e) {\n            vue.results.push({dataType: 'string', data: e, command: command})\n          })\n        } else {\n          // vue.results.push({dataType: 'string', data: 'Requires at least 1 argument', command: command})\n          return {dataType: 'string', data: 'Requires at least 1 argument'}\n        }\n        break\n      case 'cat':\n        if (myCmd.length > 1) {\n          localforage.getItem(myCmd[1])\n          .then((data) => {\n            vue.results.push({dataType: 'string', data: data, command: command})\n          })\n          .catch(function (e) {\n            vue.results.push({dataType: 'string', data: e, command: command})\n          })\n        } else {\n          return {dataType: 'string', data: 'Requires at least 1 argument'}\n        }\n        break\n      case 'ls':\n        let result = []\n        localforage.iterate((value, key, iterationNumber) => {\n          result.push(key)\n        }).then(() => {\n          // console.log('files', result)\n          vue.results.push({dataType: 'list', data: result, command: command})\n          // return {type: 'list', data: result}\n        })\n        break\n      case 'help':\n        return {type: 'string', data: 'Try help, ls, cat, touch, or any app name.'}\n      default:\n        // console.log('apps:', apps)\n        // console.log('dispatch open:', command)\n        vue.$dispatch('openApp', command)\n        return true\n    }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/apps/terminal/commands.js\n **/","<template>\n  <w-app title='Terminal' class='app--terminal animated fadeInDown' \n  :has-sub-nav=true\n  @keyup.up=\"monitorKeys('up')\"\n  @keyup.down=\"monitorKeys('down')\"\n  @click='giveFocus'>\n    <nav slot='header'>\n      <p class=\"panel-tabs\">\n        <a @click=\"openNew('terminal')\" class=\"\" href=\"#\">New</a>\n      </p>\n    </nav>\n    <div class='terminal--output'>\n      <div class='terminal--result' v-if='results.length > 0' v-for=\"(idx, result) in results\" track-by='$index'>\n          <span>$ {{ result.command }}</span>\n          <ul v-if=\"result.dataType === 'list'\">\n            <li v-for='(x, item) in result.data' track-by='$index'>{{item}}</li>\n          </ul>\n          <span v-else><br/>{{result.data}}</span>\n      </div>\n    </div>\n    <form @submit.prevent='runCommand' class='terminal--input'>\n      <p class=\"control has-icon\">\n        <input class=\"input\" type=\"text\" v-model='command' placeholder=\"\" autofocus>\n        <i class=\"fa fa-dollar\"></i>\n      </p>\n    </form>\n  </w-app>\n</template>\n\n<script>\nimport wApp from '../../wApp'\nimport shell from './commands.js'\nexport default {\n  data () {\n    return {\n      commandPosition: 1,\n      command: '',\n      results: [{command: 'welcome', dataType: 'string', data: 'Welcome to w-os'}]\n    }\n  },\n  components: {\n    wApp\n  },\n  watch: {\n    results: (e) => {\n      let results = document.querySelectorAll('.terminal--result')\n      results[results.length - 1].scrollIntoView({block: 'end', behavior: 'smooth'})\n    }\n  },\n  methods: {\n    openNew (app) {\n      this.$dispatch('openApp', app)\n    },\n    giveFocus (shell) {\n      shell.currentTarget.querySelector('input').focus()\n    },\n    monitorKeys (e) {\n      console.log('key monitor:', e)\n      console.log('commandPosition:', this.commandPosition)\n      if (e === 'up' && this.results[this.commandPosition - 1]) {\n        this.$set('commandPosition', this.$get('commandPosition') - 1)\n      } else if (e === 'down') {\n        this.$set('commandPosition', this.$get('commandPosition') + 1)\n      }\n      if (this.$get('commandPosition') >= this.results.length) {\n        this.$set('command', '')\n        this.$set('commandPosition', this.results.length)\n      } else {\n        this.$set('command', this.results[this.$get('commandPosition')].command)\n      }\n      console.log('commandPosition:', this.commandPosition)\n    },\n    runCommand (e) {\n      // let result = cash(this.$get('command'))\n      let command = this.$get('command')\n      let result = shell.cmd(this, command)\n      // console.log('reuslt:', result)\n      if (result) {\n        this.results.push({...result, command: command})\n      }\n      this.$set('command', '')\n      if (this.commandPosition < this.results.length) {\n        this.$set('commandPosition', this.results.length)\n      } else {\n        this.$set('commandPosition', this.commandPosition + 1)\n      }\n      console.log('results:', this.$get('results'))\n    }\n  }\n}\n</script>\n\n<style lang='sass'>\n.card.app--terminal\n  background: transparent\n  .card-header\n    background-color: #fff\n  .card-content\n    background-color: rgba(0, 0, 0, 0.75)\n    min-height: 15em\n    max-height: 20em\n    overflow-y: auto\n  .terminal--output\n    overflow-y: auto\n    ul\n      list-style: none\n      margin-top: 0em\n  .terminal--input\n    .control.has-icon .input:focus + .fa, .control.has-icon .textarea:focus + .fa\n      color: #1fc8db\n    input\n      background-color: unset\n      color: #1fc8db\n      border: unset\n.card.app--terminal.is-fullwidth\n  .card-content\n    height: 90%\n    overflow-y: auto\n    min-height: unset\n    max-height: unset\n  .content\n    height: 90%\n  .terminal--output\n    min-height: unset\n</style>\n\n\n\n/** WEBPACK FOOTER **\n ** terminal.vue?daf98bfc\n **/","module.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/symbol.js\n ** module id = 334\n ** module chunks = 2\n **/","module.exports = { \"default\": require(\"core-js/library/fn/symbol/iterator\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/symbol/iterator.js\n ** module id = 335\n ** module chunks = 2\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _iterator = require(\"../core-js/symbol/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = require(\"../core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/typeof.js\n ** module id = 336\n ** module chunks = 2\n **/","require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/symbol/index.js\n ** module id = 341\n ** module chunks = 2\n **/","require('../../modules/es6.string.iterator');\nrequire('../../modules/web.dom.iterable');\nmodule.exports = require('../../modules/_wks-ext').f('iterator');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/symbol/iterator.js\n ** module id = 342\n ** module chunks = 2\n **/","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys')\n  , gOPS    = require('./_object-gops')\n  , pIE     = require('./_object-pie');\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_enum-keys.js\n ** module id = 347\n ** module chunks = 2\n **/","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_is-array.js\n ** module id = 348\n ** module chunks = 2\n **/","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_keyof.js\n ** module id = 349\n ** module chunks = 2\n **/","var META     = require('./_uid')('meta')\n  , isObject = require('./_is-object')\n  , has      = require('./_has')\n  , setDesc  = require('./_object-dp').f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !require('./_fails')(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_meta.js\n ** module id = 350\n ** module chunks = 2\n **/","var pIE            = require('./_object-pie')\n  , createDesc     = require('./_property-desc')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , has            = require('./_has')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopd.js\n ** module id = 352\n ** module chunks = 2\n **/","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject')\n  , gOPN      = require('./_object-gopn').f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopn-ext.js\n ** module id = 353\n ** module chunks = 2\n **/","'use strict';\n// ECMAScript 6 symbols shim\nvar global         = require('./_global')\n  , has            = require('./_has')\n  , DESCRIPTORS    = require('./_descriptors')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , META           = require('./_meta').KEY\n  , $fails         = require('./_fails')\n  , shared         = require('./_shared')\n  , setToStringTag = require('./_set-to-string-tag')\n  , uid            = require('./_uid')\n  , wks            = require('./_wks')\n  , wksExt         = require('./_wks-ext')\n  , wksDefine      = require('./_wks-define')\n  , keyOf          = require('./_keyof')\n  , enumKeys       = require('./_enum-keys')\n  , isArray        = require('./_is-array')\n  , anObject       = require('./_an-object')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , createDesc     = require('./_property-desc')\n  , _create        = require('./_object-create')\n  , gOPNExt        = require('./_object-gopn-ext')\n  , $GOPD          = require('./_object-gopd')\n  , $DP            = require('./_object-dp')\n  , $keys          = require('./_object-keys')\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f  = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./_library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.symbol.js\n ** module id = 362\n ** module chunks = 2\n **/","require('./_wks-define')('asyncIterator');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es7.symbol.async-iterator.js\n ** module id = 363\n ** module chunks = 2\n **/","require('./_wks-define')('observable');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es7.symbol.observable.js\n ** module id = 364\n ** module chunks = 2\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".card.app--terminal{background:transparent}.card.app--terminal .card-header{background-color:#fff}.card.app--terminal .card-content{background-color:rgba(0,0,0,.75);min-height:15em;max-height:20em;overflow-y:auto}.card.app--terminal .terminal--output{overflow-y:auto}.card.app--terminal .terminal--output ul{list-style:none;margin-top:0}.card.app--terminal .terminal--input .control.has-icon .input:focus+.fa,.card.app--terminal .terminal--input .control.has-icon .textarea:focus+.fa{color:#1fc8db}.card.app--terminal .terminal--input input{background-color:unset;color:#1fc8db;border:unset}.card.app--terminal.is-fullwidth .card-content{height:90%;overflow-y:auto;min-height:unset;max-height:unset}.card.app--terminal.is-fullwidth .content{height:90%}.card.app--terminal.is-fullwidth .terminal--output{min-height:unset}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/apps/terminal/terminal.vue\"],\"names\":[],\"mappings\":\"AAAA,oBAAoB,sBAAsB,CAAC,iCAAiC,qBAAqB,CAAC,kCAAkC,iCAAkC,gBAAgB,gBAAgB,eAAe,CAAC,sCAAsC,eAAe,CAAC,yCAAyC,gBAAgB,YAAc,CAAC,mJAAmJ,aAAa,CAAC,2CAA2C,uBAAuB,cAAc,YAAY,CAAC,+CAA+C,WAAW,gBAAgB,iBAAiB,gBAAgB,CAAC,0CAA0C,UAAU,CAAC,mDAAmD,gBAAgB,CAAC\",\"file\":\"terminal.vue\",\"sourcesContent\":[\".card.app--terminal{background:transparent}.card.app--terminal .card-header{background-color:#fff}.card.app--terminal .card-content{background-color:rgba(0,0,0,0.75);min-height:15em;max-height:20em;overflow-y:auto}.card.app--terminal .terminal--output{overflow-y:auto}.card.app--terminal .terminal--output ul{list-style:none;margin-top:0em}.card.app--terminal .terminal--input .control.has-icon .input:focus+.fa,.card.app--terminal .terminal--input .control.has-icon .textarea:focus+.fa{color:#1fc8db}.card.app--terminal .terminal--input input{background-color:unset;color:#1fc8db;border:unset}.card.app--terminal.is-fullwidth .card-content{height:90%;overflow-y:auto;min-height:unset;max-height:unset}.card.app--terminal.is-fullwidth .content{height:90%}.card.app--terminal.is-fullwidth .terminal--output{min-height:unset}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js!./~/sass-loader?indentedSyntax&sourceMap!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/apps/terminal/terminal.vue\n ** module id = 367\n ** module chunks = 2\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js?sourceMap!./../../../../node_modules/vue-loader/lib/style-rewriter.js!./../../../../node_modules/sass-loader/index.js?indentedSyntax&sourceMap!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./terminal.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js?sourceMap!./../../../../node_modules/vue-loader/lib/style-rewriter.js!./../../../../node_modules/sass-loader/index.js?indentedSyntax&sourceMap!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./terminal.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js?sourceMap!./../../../../node_modules/vue-loader/lib/style-rewriter.js!./../../../../node_modules/sass-loader/index.js?indentedSyntax&sourceMap!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./terminal.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js!./~/sass-loader?indentedSyntax&sourceMap!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/apps/terminal/terminal.vue\n ** module id = 378\n ** module chunks = 2\n **/","module.exports = \" <w-app title=Terminal class=\\\"app--terminal animated fadeInDown\\\" :has-sub-nav=true @keyup.up=\\\"monitorKeys('up')\\\" @keyup.down=\\\"monitorKeys('down')\\\" @click=giveFocus> <nav slot=header> <p class=panel-tabs> <a @click=\\\"openNew('terminal')\\\" class=\\\"\\\" href=#>New</a> </p> </nav> <div class=terminal--output> <div class=terminal--result v-if=\\\"results.length > 0\\\" v-for=\\\"(idx, result) in results\\\" track-by=$index> <span>$ {{ result.command }}</span> <ul v-if=\\\"result.dataType === 'list'\\\"> <li v-for=\\\"(x, item) in result.data\\\" track-by=$index>{{item}}</li> </ul> <span v-else><br/>{{result.data}}</span> </div> </div> <form @submit.prevent=runCommand class=terminal--input> <p class=\\\"control has-icon\\\"> <input class=input type=text v-model=command placeholder=\\\"\\\" autofocus> <i class=\\\"fa fa-dollar\\\"></i> </p> </form> </w-app> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/apps/terminal/terminal.vue\n ** module id = 751\n ** module chunks = 2\n **/","var __vue_script__, __vue_template__\nrequire(\"!!./../../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!./../../../../node_modules/vue-loader/lib/style-rewriter.js!sass-loader?indentedSyntax&sourceMap!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./terminal.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../../../node_modules/vue-loader/lib/selector.js?type=script&index=0!./terminal.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../../../node_modules/vue-loader/lib/selector.js?type=template&index=0!./terminal.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/apps/terminal/terminal.vue\n ** module id = 764\n ** module chunks = 2\n **/"],"sourceRoot":""}