{"version":3,"sources":["webpack:///static/js/4.12068b5f31e0746c35b2.js","webpack:///wApp.vue?2abb***","webpack:///./src/components/wApp.vue?9140****","webpack:///./src/components/wApp.vue?cf76****","webpack:///./src/components/wApp.vue?2155****","webpack:///./src/components/wApp.vue?a07d****","webpack:///./~/interact.js/interact.js?3c23***","webpack:///./src/components/wApp.vue?ad9e****","webpack:///./src/components/wApp.vue?fe08****","webpack:///textEditor.vue","webpack:///./src/components/apps/textEditor.vue?0f58","webpack:///./src/components/apps/textEditor.vue?31c3","webpack:///./src/components/apps/textEditor.vue?66f0","webpack:///./src/components/apps/textEditor.vue"],"names":["webpackJsonp","24","module","exports","__webpack_require__","dragMoveListener","event","target","parentNode","x","parseFloat","getAttribute","dx","y","dy","style","webkitTransform","transform","setAttribute","Object","defineProperty","value","interact","draggable","inertia","restrict","restriction","endOnly","elementRect","top","left","bottom","right","autoScroll","onmove","onend","data","hasFocus","isMax","isDeleted","methods","bringToFront","e","this","$dispatch","currentTarget","$set","closeApp","maxApp","makeMe","removeChild","classList","remove","events","loseFocus","props","title","type","String","required","loading","Boolean","hasSubNav","default","26","push","id","version","sources","names","mappings","file","sourcesContent","sourceRoot","27","28","content","locals","29","30","realWindow","blank","isElement","o","_window","getWindow","window","test","Element","nodeType","nodeName","isWindow","thing","Window","isDocFrag","DocumentFragment","isArray","isObject","undefined","length","isFunction","splice","isNumber","isBool","isString","trySelector","document","querySelector","extend","dest","source","prop","pointerExtend","deprecated","vendor","prefixedPropREs","indexOf","copyCoords","src","page","client","timeStamp","setEventXY","targetObj","pointers","interaction","pointer","pointerAverage","getPageXY","tmpXY","getClientXY","Date","getTime","setEventDeltas","prev","cur","dt","Math","max","speed","hypot","vx","vy","isNativePointer","Event","supportsTouch","Touch","getXY","xy","isOperaMobile","scrollX","scrollY","getScrollXY","win","documentElement","scrollLeft","scrollTop","getPointerId","pointerId","identifier","getActualElement","element","SVGElementInstance","correspondingUseElement","node","rootNode","ownerDocument","defaultView","parentWindow","getElementClientRect","clientRect","SVGElement","getBoundingClientRect","getClientRects","width","height","getElementRect","isIOS7","scroll","getTouchPair","touches","changedTouches","average","pageX","pageY","clientX","clientY","screenX","screenY","i","touchBBox","minX","min","minY","maxX","maxY","touchDistance","deltaSource","defaultOptions","sourceX","sourceY","touchAngle","prevAngle","angle","atan","PI","dr","drClamped","getOriginXY","interactable","origin","options","parentElement","getRect","closest","_getQBezierValue","t","p1","p2","p3","iT","getQuadraticCurvePoint","startX","startY","cpX","cpY","endX","endY","position","easeOutQuad","b","c","d","nodeContains","parent","child","selector","matchesSelector","host","inContext","_context","testIgnore","interactableElement","ignoreFrom","matchesUpTo","testAllow","allowFrom","checkAxis","axis","thisAxis","drag","checkSnap","action","snap","enabled","checkRestrict","checkAutoScroll","withinInteractionLimit","maxActions","name","maxPerElement","activeInteractions","targetCount","targetElementCount","len","interactions","otherAction","prepared","active","interacting","maxInteractions","indexOfDeepestElement","elements","dropzone","n","deepestZone","index","deepestZoneParents","dropzoneParents","unshift","HTMLElement","SVGSVGElement","ownerSVGElement","parents","lastChild","previousSibling","Interaction","dropTarget","dropElement","prevDropTarget","prevDropElement","edges","matches","matchElements","inertiaStatus","smoothEnd","ending","startEvent","upCoords","xe","ye","sx","sy","t0","vx0","vys","duration","resumeDx","resumeDy","lambda_v0","one_ve_v0","Function","prototype","bind","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","that","activeDrops","dropzones","rects","pointerIds","downTargets","downTimes","holdTimers","prevCoords","curCoords","startCoords","pointerDelta","downEvent","downPointer","_eventTarget","_curEventTarget","prevEvent","tapTime","prevTap","startOffset","restrictOffset","snapOffsets","gesture","start","startDistance","prevDistance","distance","scale","startAngle","snapStatus","realX","realY","snappedX","snappedY","targets","locked","changed","restrictStatus","restrictedX","restrictedY","restricted","pointerIsDown","pointerWasMoved","gesturing","dragging","resizing","resizeAxes","mouse","getInteractionFromPointer","eventType","eventTarget","mouseEvent","pointerType","allowResume","supportsPointerEvent","contains","doOnInteractions","method","path","curEventTarget","prevTouchTime","_updateEventTargets","InteractEvent","phase","related","starting","coords","relativePoints","range","x0","y0","clientX0","clientY0","ctrlKey","altKey","shiftKey","metaKey","button","buttons","detail","relatedTarget","zeroResumeDelta","resize","square","axes","box","ds","da","prevScale","velocityX","velocityY","atan2","overlap","up","down","swipe","velocity","preventOriginalDefault","originalEvent","preventDefault","getActionCursor","cursor","actionCursors","cursorKey","edgeNames","checkResizeEdge","rect","margin","defaultActionChecker","resizeEdges","shouldResize","actionIsEnabled","resizeOptions","edge","validateAction","actionName","delegateListener","useCapture","fakeEvent","delegated","delegatedEvents","selectors","context","contexts","listeners","j","delegateUseCapture","call","interactables","get","Interactable","_element","_iEvents","Node","PointerEvent","add","pEventTypes","pointerDown","move","pointerHover","_doc","documents","listenToDocument","set","warnOnce","message","warned","console","warn","apply","arguments","endAllInteractions","pointerEnd","doc","MSPointerEvent","over","out","cancel","selectorDown","pointerMove","pointerOver","pointerOut","pointerUp","pointerCancel","autoScrollMove","frameElement","parentDoc","error","windowParentError","checkAndPreventDefault","useAttachEvent","currentAction","array","nodeList","ie8MatchesSelector","replace","prefixedMatchesSelector","limit","el","createTextNode","wrap","sqrt","dynamicDrop","base","accept","actionChecker","styleCursor","dropChecker","manualStart","Infinity","drop","preserveAspectRatio","NaN","invert","perAction","offsets","container","resistance","minSpeed","endSpeed","smoothEndDuration","_holdDuration","now","dtx","prevTimeX","dty","prevTimeY","scrollBy","isScrolling","cancelFrame","reqFrame","stop","DocumentTouch","pointerMoveTolerance","all","atob","resizex","resizey","resizexy","resizetop","resizeleft","resizebottom","resizeright","resizetopleft","resizebottomright","resizetopright","resizebottomleft","wheelEvent","eventTypes","globalEvents","navigator","appName","userAgent","match","platform","appVersion","requestAnimationFrame","cancelAnimationFrame","listener","elementIndex","typeCount","attachedListeners","supplied","wrapped","useCount","ret","listenerIndex","immediatePropagationStopped","srcElement","preventDef","stopPropagation","stopProp","stopImmediatePropagation","stopImmProp","addEvent","on","removeEvent","hasOwnProperty","returnValue","cancelBubble","_elements","_targets","_attachedListeners","webkit","ptr","pushCurMatches","curMatches","curMatchElements","prevTargetElement","addPointer","elementInteractable","elementAction","getAction","forEachSelector","validateSelector","pushMatches","querySelectorAll","eventCopy","pointerIndex","setTimeout","pointerHold","collectEventTargets","forceAction","newAction","setModifications","preEnd","shouldMove","shouldSnap","shouldRestrict","setSnapping","setRestriction","setStartOffsets","snapOffset","offset","pageUp","clientUp","inertiaPosition","recordPointer","duplicateMove","clearTimeout","absX","abs","absY","targetAxis","thisInteraction","getDraggable","selectorInteractable","dragStart","dragEvent","fire","setActiveDrops","dropEvents","getDropEvents","activate","fireActiveDrops","dragMove","draggableElement","getDrop","leave","enter","resizeStart","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","current","previous","delta","deltaRect","resizeMove","invertible","originalEdges","swap","gestureStart","gestureEvent","gestureMove","isNaN","removePointer","ie8Dblclick","endEvent","inertiaOptions","pointerSpeed","inertiaPossible","endSnap","endRestrict","snapRestrict","vy0","v0","calcInertia","statusObject","useStatusXY","modifiedXe","modifiedYe","deactivate","collectDrops","drops","dropElements","currentElement","prevElement","dragElement","possibleDrops","validDrops","dropCheck","dropIndex","pointerEvent","dragLeave","prevDropzone","dragEnter","dragmove","clearTargets","lambda","te","progress","exp","quadPoint","collectSelectors","els","isSet","firePointers","interval","createNewDoubleTap","originalPointer","propagationStopped","doubleTap","matchElement","pageCoords","status","relIndex","relative","inRange","snapChanged","prevent","inertiaDur","log","innerWidth","innerHeight","interactionListeners","indexOfElement","callback","setOnEvents","phases","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","onstart","oninertiastart","setPerAction","option","checker","dropped","dropOverlap","horizontal","vertical","dragRect","cx","cy","overlapArea","overlapRatio","newValue","resizable","squareResize","gesturable","actions","setOptions","thisOption","mode","createSnapGrid","gridOffset","grid","anchors","paths","elementOrigin","allActions","rectChecker","iEvent","onEvent","funcName","search","trim","split","off","eventList","matchFound","fn","useCap","perActions","settings","setting","unset","enableDragging","enableResizing","enableGesturing","debug","downTime","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","newvalue","offsetX","offsetY","gridx","round","gridy","newX","newY","elems","lastTime","vendors","currTime","timeToCall","33","34","__vue_script__","__vue_template__","__esModule","template","325","_interopRequireDefault","obj","_wApp","_wApp2","fileName","fileData","components","wApp","saveFile","getFileSystem","openNew","app","369","380","753","765"],"mappings":"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","file":"static/js/4.12068b5f31e0746c35b2.js","sourcesContent":["webpackJsonp([4,6],{\n\n/***/ 24:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar interact = __webpack_require__(30);\n\tinteract('.w-app header').draggable({\n\t  inertia: true,\n\t  restrict: {\n\t    restriction: '.bound',\n\t    endOnly: true,\n\t    elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n\t  },\n\t  autoScroll: true,\n\t  onmove: dragMoveListener,\n\t\n\t  onend: function onend(event) {}\n\t});\n\t\n\tfunction dragMoveListener(event) {\n\t  var target = event.target.parentNode;\n\t\n\t  var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;\n\t  var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;\n\t\n\t  target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';\n\t\n\t  target.setAttribute('data-x', x);\n\t  target.setAttribute('data-y', y);\n\t}\n\texports.default = {\n\t  data: function data() {\n\t    return {\n\t      hasFocus: false,\n\t      isMax: false,\n\t      isDeleted: false\n\t    };\n\t  },\n\t\n\t  methods: {\n\t    bringToFront: function bringToFront(e) {\n\t      this.$dispatch('bringToFront', e.currentTarget);\n\t      this.$dispatch('loseFocus');\n\t      this.$set('hasFocus', true);\n\t    },\n\t    closeApp: function closeApp(e) {\n\t      this.$set('isDeleted', true);\n\t      this.$dispatch('closeApp', e);\n\t    },\n\t    maxApp: function maxApp(e) {\n\t      this.$set('isMax', !this.isMax);\n\t    },\n\t    makeMe: function makeMe(e) {\n\t      var target = e.currentTarget;\n\t      if (this.isDeleted) {\n\t        target.parentNode.removeChild(target);\n\t      } else {\n\t        target.classList.remove('animated');\n\t        target.classList.remove('fadeInDown');\n\t        this.$dispatch('addMe', target);\n\t        this.$dispatch('loseFocus');\n\t        this.$set('hasFocus', true);\n\t      }\n\t    }\n\t  },\n\t  events: {\n\t    loseFocus: function loseFocus() {\n\t      this.$set('hasFocus', false);\n\t    }\n\t  },\n\t  props: {\n\t    title: {\n\t      type: String,\n\t      required: true\n\t    },\n\t    loading: {\n\t      type: Boolean\n\t    },\n\t    hasSubNav: {\n\t      type: Boolean,\n\t      default: false,\n\t      required: true\n\t    }\n\t  }\n\t};\n\n/***/ },\n\n/***/ 26:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".card-header--subnav .panel-tabs a{color:#42afe3}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/wApp.vue\"],\"names\":[],\"mappings\":\"AA0LA,mCACE,aAAe,CAChB\",\"file\":\"wApp.vue\",\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n.card-header--subnav .panel-tabs a {\\n  color: #42afe3;\\n}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 27:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".w-app[_v-ca6846e8]{position:absolute;color:#fff;top:100px;left:100px;box-shadow:0 0 5px #000;z-index:0;.card-header{cursor:move}-webkit-transition:background 1s ease-in-out;transition:background 1s ease-in-out}.card-header .card-header-icon[_v-ca6846e8]{width:24px;color:#42afe3}.card-content[_v-ca6846e8]{width:unset}.is-fullwidth[_v-ca6846e8]{-webkit-transform:translate(-100px,-44px)!important;transform:translate(-100px,-44px)!important;height:93%;.card-content{height:100%;overflow-y:auto}}.isLoading[_v-ca6846e8]{background-color:#c3c3c3}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/wApp.vue\"],\"names\":[],\"mappings\":\"AAyJE,oBACE,kBAAmB,AACpB,WAAY,AACX,UAAW,AACX,WAAY,AACZ,wBAA8B,AAC9B,UAAW,AACX,aACE,WAAa,CACd,AACD,6CAA8C,AAC9C,oCAAsC,CACvC,AACD,4CACE,WAAY,AACZ,aAAe,CAChB,AACD,2BACE,WAAa,CACd,AACD,2BACE,oDAAuD,AAC/C,4CAA+C,AACvD,WAAY,AACZ,cACE,YAAa,AACb,eAAiB,CAClB,CACF,AACD,wBACE,wBAA0B,CAC3B\",\"file\":\"wApp.vue\",\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  .w-app[_v-ca6846e8] {\\n    position: absolute;\\n\\t  color: #FFF;\\n    top: 100px;\\n    left: 100px;\\n    box-shadow: 0px 0px 5px black;\\n    z-index: 0;\\n    .card-header {\\n      cursor: move;\\n    }\\n    -webkit-transition: 1s background ease-in-out;\\n    transition: 1s background ease-in-out;\\n  }\\n  .card-header .card-header-icon[_v-ca6846e8] {\\n    width: 24px;\\n    color: #42afe3;\\n  }\\n  .card-content[_v-ca6846e8] {\\n    width: unset;\\n  }\\n  .is-fullwidth[_v-ca6846e8] {\\n    -webkit-transform: translate(-100px, -44px) !important;\\n            transform: translate(-100px, -44px) !important;\\n    height: 93%;\\n    .card-content {\\n      height: 100%;\\n      overflow-y: auto;\\n    }\\n  }\\n  .isLoading[_v-ca6846e8] {\\n    background-color: #c3c3c3;\\n  }\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 28:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(26);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(14)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 29:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(27);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(14)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 30:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * interact.js v1.2.6\n\t *\n\t * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n\t * Open source under the MIT License.\n\t * https://raw.github.com/taye/interact.js/master/LICENSE\n\t */\n\t(function (realWindow) {\n\t    'use strict';\n\t\n\t    // return early if there's no window to work with (eg. Node.js)\n\t    if (!realWindow) { return; }\n\t\n\t    var // get wrapped window if using Shadow DOM polyfill\n\t        window = (function () {\n\t            // create a TextNode\n\t            var el = realWindow.document.createTextNode('');\n\t\n\t            // check if it's wrapped by a polyfill\n\t            if (el.ownerDocument !== realWindow.document\n\t                && typeof realWindow.wrap === 'function'\n\t                && realWindow.wrap(el) === el) {\n\t                // return wrapped window\n\t                return realWindow.wrap(realWindow);\n\t            }\n\t\n\t            // no Shadow DOM polyfil or native implementation\n\t            return realWindow;\n\t        }()),\n\t\n\t        document           = window.document,\n\t        DocumentFragment   = window.DocumentFragment   || blank,\n\t        SVGElement         = window.SVGElement         || blank,\n\t        SVGSVGElement      = window.SVGSVGElement      || blank,\n\t        SVGElementInstance = window.SVGElementInstance || blank,\n\t        HTMLElement        = window.HTMLElement        || window.Element,\n\t\n\t        PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n\t        pEventTypes,\n\t\n\t        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\t\n\t        tmpXY = {},     // reduce object creation in getXY()\n\t\n\t        documents       = [],   // all documents being listened to\n\t\n\t        interactables   = [],   // all set interactables\n\t        interactions    = [],   // all interactions\n\t\n\t        dynamicDrop     = false,\n\t\n\t        // {\n\t        //      type: {\n\t        //          selectors: ['selector', ...],\n\t        //          contexts : [document, ...],\n\t        //          listeners: [[listener, useCapture], ...]\n\t        //      }\n\t        //  }\n\t        delegatedEvents = {},\n\t\n\t        defaultOptions = {\n\t            base: {\n\t                accept        : null,\n\t                actionChecker : null,\n\t                styleCursor   : true,\n\t                preventDefault: 'auto',\n\t                origin        : { x: 0, y: 0 },\n\t                deltaSource   : 'page',\n\t                allowFrom     : null,\n\t                ignoreFrom    : null,\n\t                _context      : document,\n\t                dropChecker   : null\n\t            },\n\t\n\t            drag: {\n\t                enabled: false,\n\t                manualStart: true,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: null,\n\t                restrict: null,\n\t                inertia: null,\n\t                autoScroll: null,\n\t\n\t                axis: 'xy'\n\t            },\n\t\n\t            drop: {\n\t                enabled: false,\n\t                accept: null,\n\t                overlap: 'pointer'\n\t            },\n\t\n\t            resize: {\n\t                enabled: false,\n\t                manualStart: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: null,\n\t                restrict: null,\n\t                inertia: null,\n\t                autoScroll: null,\n\t\n\t                square: false,\n\t                preserveAspectRatio: false,\n\t                axis: 'xy',\n\t\n\t                // use default margin\n\t                margin: NaN,\n\t\n\t                // object with props left, right, top, bottom which are\n\t                // true/false values to resize when the pointer is over that edge,\n\t                // CSS selectors to match the handles for each direction\n\t                // or the Elements for each handle\n\t                edges: null,\n\t\n\t                // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t                // 'negate' will alow the rect to have negative width/height\n\t                // 'reposition' will keep the width/height positive by swapping\n\t                // the top and bottom edges and/or swapping the left and right edges\n\t                invert: 'none'\n\t            },\n\t\n\t            gesture: {\n\t                manualStart: false,\n\t                enabled: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                restrict: null\n\t            },\n\t\n\t            perAction: {\n\t                manualStart: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: {\n\t                    enabled     : false,\n\t                    endOnly     : false,\n\t                    range       : Infinity,\n\t                    targets     : null,\n\t                    offsets     : null,\n\t\n\t                    relativePoints: null\n\t                },\n\t\n\t                restrict: {\n\t                    enabled: false,\n\t                    endOnly: false\n\t                },\n\t\n\t                autoScroll: {\n\t                    enabled     : false,\n\t                    container   : null,     // the item that is scrolled (Window or HTMLElement)\n\t                    margin      : 60,\n\t                    speed       : 300       // the scroll speed in pixels per second\n\t                },\n\t\n\t                inertia: {\n\t                    enabled          : false,\n\t                    resistance       : 10,    // the lambda in exponential decay\n\t                    minSpeed         : 100,   // target speed must be above this for inertia to start\n\t                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n\t                    allowResume      : true,  // allow resuming an action in inertia phase\n\t                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n\t                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n\t                }\n\t            },\n\t\n\t            _holdDuration: 600\n\t        },\n\t\n\t        // Things related to autoScroll\n\t        autoScroll = {\n\t            interaction: null,\n\t            i: null,    // the handle returned by window.setInterval\n\t            x: 0, y: 0, // Direction each pulse is to scroll in\n\t\n\t            // scroll the window by the values in scroll.x/y\n\t            scroll: function () {\n\t                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n\t                    container = options.container || getWindow(autoScroll.interaction.element),\n\t                    now = new Date().getTime(),\n\t                    // change in time in seconds\n\t                    dtx = (now - autoScroll.prevTimeX) / 1000,\n\t                    dty = (now - autoScroll.prevTimeY) / 1000,\n\t                    vx, vy, sx, sy;\n\t\n\t                // displacement\n\t                if (options.velocity) {\n\t                  vx = options.velocity.x;\n\t                  vy = options.velocity.y;\n\t                }\n\t                else {\n\t                  vx = vy = options.speed\n\t                }\n\t \n\t                sx = vx * dtx;\n\t                sy = vy * dty;\n\t\n\t                if (sx >= 1 || sy >= 1) {\n\t                    if (isWindow(container)) {\n\t                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n\t                    }\n\t                    else if (container) {\n\t                        container.scrollLeft += autoScroll.x * sx;\n\t                        container.scrollTop  += autoScroll.y * sy;\n\t                    }\n\t\n\t                    if (sx >=1) autoScroll.prevTimeX = now;\n\t                    if (sy >= 1) autoScroll.prevTimeY = now;\n\t                }\n\t\n\t                if (autoScroll.isScrolling) {\n\t                    cancelFrame(autoScroll.i);\n\t                    autoScroll.i = reqFrame(autoScroll.scroll);\n\t                }\n\t            },\n\t\n\t            isScrolling: false,\n\t            prevTimeX: 0,\n\t            prevTimeY: 0,\n\t\n\t            start: function (interaction) {\n\t                autoScroll.isScrolling = true;\n\t                cancelFrame(autoScroll.i);\n\t\n\t                autoScroll.interaction = interaction;\n\t                autoScroll.prevTimeX = new Date().getTime();\n\t                autoScroll.prevTimeY = new Date().getTime();\n\t                autoScroll.i = reqFrame(autoScroll.scroll);\n\t            },\n\t\n\t            stop: function () {\n\t                autoScroll.isScrolling = false;\n\t                cancelFrame(autoScroll.i);\n\t            }\n\t        },\n\t\n\t        // Does the browser support touch input?\n\t        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\t\n\t        // Does the browser support PointerEvents\n\t        supportsPointerEvent = !!PointerEvent,\n\t\n\t        // Less Precision with touch input\n\t        margin = supportsTouch || supportsPointerEvent? 20: 10,\n\t\n\t        pointerMoveTolerance = 1,\n\t\n\t        // for ignoring browser's simulated mouse events\n\t        prevTouchTime = 0,\n\t\n\t        // Allow this many interactions to happen simultaneously\n\t        maxInteractions = Infinity,\n\t\n\t        // Check if is IE9 or older\n\t        actionCursors = (document.all && !window.atob) ? {\n\t            drag    : 'move',\n\t            resizex : 'e-resize',\n\t            resizey : 's-resize',\n\t            resizexy: 'se-resize',\n\t\n\t            resizetop        : 'n-resize',\n\t            resizeleft       : 'w-resize',\n\t            resizebottom     : 's-resize',\n\t            resizeright      : 'e-resize',\n\t            resizetopleft    : 'se-resize',\n\t            resizebottomright: 'se-resize',\n\t            resizetopright   : 'ne-resize',\n\t            resizebottomleft : 'ne-resize',\n\t\n\t            gesture : ''\n\t        } : {\n\t            drag    : 'move',\n\t            resizex : 'ew-resize',\n\t            resizey : 'ns-resize',\n\t            resizexy: 'nwse-resize',\n\t\n\t            resizetop        : 'ns-resize',\n\t            resizeleft       : 'ew-resize',\n\t            resizebottom     : 'ns-resize',\n\t            resizeright      : 'ew-resize',\n\t            resizetopleft    : 'nwse-resize',\n\t            resizebottomright: 'nwse-resize',\n\t            resizetopright   : 'nesw-resize',\n\t            resizebottomleft : 'nesw-resize',\n\t\n\t            gesture : ''\n\t        },\n\t\n\t        actionIsEnabled = {\n\t            drag   : true,\n\t            resize : true,\n\t            gesture: true\n\t        },\n\t\n\t        // because Webkit and Opera still use 'mousewheel' event type\n\t        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\t\n\t        eventTypes = [\n\t            'dragstart',\n\t            'dragmove',\n\t            'draginertiastart',\n\t            'dragend',\n\t            'dragenter',\n\t            'dragleave',\n\t            'dropactivate',\n\t            'dropdeactivate',\n\t            'dropmove',\n\t            'drop',\n\t            'resizestart',\n\t            'resizemove',\n\t            'resizeinertiastart',\n\t            'resizeend',\n\t            'gesturestart',\n\t            'gesturemove',\n\t            'gestureinertiastart',\n\t            'gestureend',\n\t\n\t            'down',\n\t            'move',\n\t            'up',\n\t            'cancel',\n\t            'tap',\n\t            'doubletap',\n\t            'hold'\n\t        ],\n\t\n\t        globalEvents = {},\n\t\n\t        // Opera Mobile must be handled differently\n\t        isOperaMobile = navigator.appName == 'Opera' &&\n\t            supportsTouch &&\n\t            navigator.userAgent.match('Presto'),\n\t\n\t        // scrolling doesn't change the result of getClientRects on iOS 7\n\t        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n\t                         && /OS 7[^\\d]/.test(navigator.appVersion)),\n\t\n\t        // prefix matchesSelector\n\t        prefixedMatchesSelector = 'matches' in Element.prototype?\n\t                'matches': 'webkitMatchesSelector' in Element.prototype?\n\t                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n\t                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n\t                            'oMatchesSelector': 'msMatchesSelector',\n\t\n\t        // will be polyfill function if browser is IE8\n\t        ie8MatchesSelector,\n\t\n\t        // native requestAnimationFrame or polyfill\n\t        reqFrame = realWindow.requestAnimationFrame,\n\t        cancelFrame = realWindow.cancelAnimationFrame,\n\t\n\t        // Events wrapper\n\t        events = (function () {\n\t            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n\t                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n\t                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n\t                on             = useAttachEvent? 'on': '',\n\t\n\t                elements          = [],\n\t                targets           = [],\n\t                attachedListeners = [];\n\t\n\t            function add (element, type, listener, useCapture) {\n\t                var elementIndex = indexOf(elements, element),\n\t                    target = targets[elementIndex];\n\t\n\t                if (!target) {\n\t                    target = {\n\t                        events: {},\n\t                        typeCount: 0\n\t                    };\n\t\n\t                    elementIndex = elements.push(element) - 1;\n\t                    targets.push(target);\n\t\n\t                    attachedListeners.push((useAttachEvent ? {\n\t                            supplied: [],\n\t                            wrapped : [],\n\t                            useCount: []\n\t                        } : null));\n\t                }\n\t\n\t                if (!target.events[type]) {\n\t                    target.events[type] = [];\n\t                    target.typeCount++;\n\t                }\n\t\n\t                if (!contains(target.events[type], listener)) {\n\t                    var ret;\n\t\n\t                    if (useAttachEvent) {\n\t                        var listeners = attachedListeners[elementIndex],\n\t                            listenerIndex = indexOf(listeners.supplied, listener);\n\t\n\t                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n\t                            if (!event.immediatePropagationStopped) {\n\t                                event.target = event.srcElement;\n\t                                event.currentTarget = element;\n\t\n\t                                event.preventDefault = event.preventDefault || preventDef;\n\t                                event.stopPropagation = event.stopPropagation || stopProp;\n\t                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\t\n\t                                if (/mouse|click/.test(event.type)) {\n\t                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n\t                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n\t                                }\n\t\n\t                                listener(event);\n\t                            }\n\t                        };\n\t\n\t                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\t\n\t                        if (listenerIndex === -1) {\n\t                            listeners.supplied.push(listener);\n\t                            listeners.wrapped.push(wrapped);\n\t                            listeners.useCount.push(1);\n\t                        }\n\t                        else {\n\t                            listeners.useCount[listenerIndex]++;\n\t                        }\n\t                    }\n\t                    else {\n\t                        ret = element[addEvent](type, listener, useCapture || false);\n\t                    }\n\t                    target.events[type].push(listener);\n\t\n\t                    return ret;\n\t                }\n\t            }\n\t\n\t            function remove (element, type, listener, useCapture) {\n\t                var i,\n\t                    elementIndex = indexOf(elements, element),\n\t                    target = targets[elementIndex],\n\t                    listeners,\n\t                    listenerIndex,\n\t                    wrapped = listener;\n\t\n\t                if (!target || !target.events) {\n\t                    return;\n\t                }\n\t\n\t                if (useAttachEvent) {\n\t                    listeners = attachedListeners[elementIndex];\n\t                    listenerIndex = indexOf(listeners.supplied, listener);\n\t                    wrapped = listeners.wrapped[listenerIndex];\n\t                }\n\t\n\t                if (type === 'all') {\n\t                    for (type in target.events) {\n\t                        if (target.events.hasOwnProperty(type)) {\n\t                            remove(element, type, 'all');\n\t                        }\n\t                    }\n\t                    return;\n\t                }\n\t\n\t                if (target.events[type]) {\n\t                    var len = target.events[type].length;\n\t\n\t                    if (listener === 'all') {\n\t                        for (i = 0; i < len; i++) {\n\t                            remove(element, type, target.events[type][i], Boolean(useCapture));\n\t                        }\n\t                        return;\n\t                    } else {\n\t                        for (i = 0; i < len; i++) {\n\t                            if (target.events[type][i] === listener) {\n\t                                element[removeEvent](on + type, wrapped, useCapture || false);\n\t                                target.events[type].splice(i, 1);\n\t\n\t                                if (useAttachEvent && listeners) {\n\t                                    listeners.useCount[listenerIndex]--;\n\t                                    if (listeners.useCount[listenerIndex] === 0) {\n\t                                        listeners.supplied.splice(listenerIndex, 1);\n\t                                        listeners.wrapped.splice(listenerIndex, 1);\n\t                                        listeners.useCount.splice(listenerIndex, 1);\n\t                                    }\n\t                                }\n\t\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    if (target.events[type] && target.events[type].length === 0) {\n\t                        target.events[type] = null;\n\t                        target.typeCount--;\n\t                    }\n\t                }\n\t\n\t                if (!target.typeCount) {\n\t                    targets.splice(elementIndex, 1);\n\t                    elements.splice(elementIndex, 1);\n\t                    attachedListeners.splice(elementIndex, 1);\n\t                }\n\t            }\n\t\n\t            function preventDef () {\n\t                this.returnValue = false;\n\t            }\n\t\n\t            function stopProp () {\n\t                this.cancelBubble = true;\n\t            }\n\t\n\t            function stopImmProp () {\n\t                this.cancelBubble = true;\n\t                this.immediatePropagationStopped = true;\n\t            }\n\t\n\t            return {\n\t                add: add,\n\t                remove: remove,\n\t                useAttachEvent: useAttachEvent,\n\t\n\t                _elements: elements,\n\t                _targets: targets,\n\t                _attachedListeners: attachedListeners\n\t            };\n\t        }());\n\t\n\t    function blank () {}\n\t\n\t    function isElement (o) {\n\t        if (!o || (typeof o !== 'object')) { return false; }\n\t\n\t        var _window = getWindow(o) || window;\n\t\n\t        return (/object|function/.test(typeof _window.Element)\n\t            ? o instanceof _window.Element //DOM2\n\t            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n\t    }\n\t    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n\t    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n\t    function isArray (thing) {\n\t        return isObject(thing)\n\t                && (typeof thing.length !== undefined)\n\t                && isFunction(thing.splice);\n\t    }\n\t    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n\t    function isFunction (thing) { return typeof thing === 'function'; }\n\t    function isNumber   (thing) { return typeof thing === 'number'  ; }\n\t    function isBool     (thing) { return typeof thing === 'boolean' ; }\n\t    function isString   (thing) { return typeof thing === 'string'  ; }\n\t\n\t    function trySelector (value) {\n\t        if (!isString(value)) { return false; }\n\t\n\t        // an exception will be raised if it is invalid\n\t        document.querySelector(value);\n\t        return true;\n\t    }\n\t\n\t    function extend (dest, source) {\n\t        for (var prop in source) {\n\t            dest[prop] = source[prop];\n\t        }\n\t        return dest;\n\t    }\n\t\n\t    var prefixedPropREs = {\n\t      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n\t    };\n\t\n\t    function pointerExtend (dest, source) {\n\t        for (var prop in source) {\n\t          var deprecated = false;\n\t\n\t          // skip deprecated prefixed properties\n\t          for (var vendor in prefixedPropREs) {\n\t            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n\t              deprecated = true;\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (!deprecated) {\n\t            dest[prop] = source[prop];\n\t          }\n\t        }\n\t        return dest;\n\t    }\n\t\n\t    function copyCoords (dest, src) {\n\t        dest.page = dest.page || {};\n\t        dest.page.x = src.page.x;\n\t        dest.page.y = src.page.y;\n\t\n\t        dest.client = dest.client || {};\n\t        dest.client.x = src.client.x;\n\t        dest.client.y = src.client.y;\n\t\n\t        dest.timeStamp = src.timeStamp;\n\t    }\n\t\n\t    function setEventXY (targetObj, pointers, interaction) {\n\t        var pointer = (pointers.length > 1\n\t                       ? pointerAverage(pointers)\n\t                       : pointers[0]);\n\t\n\t        getPageXY(pointer, tmpXY, interaction);\n\t        targetObj.page.x = tmpXY.x;\n\t        targetObj.page.y = tmpXY.y;\n\t\n\t        getClientXY(pointer, tmpXY, interaction);\n\t        targetObj.client.x = tmpXY.x;\n\t        targetObj.client.y = tmpXY.y;\n\t\n\t        targetObj.timeStamp = new Date().getTime();\n\t    }\n\t\n\t    function setEventDeltas (targetObj, prev, cur) {\n\t        targetObj.page.x     = cur.page.x      - prev.page.x;\n\t        targetObj.page.y     = cur.page.y      - prev.page.y;\n\t        targetObj.client.x   = cur.client.x    - prev.client.x;\n\t        targetObj.client.y   = cur.client.y    - prev.client.y;\n\t        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\t\n\t        // set pointer velocity\n\t        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\t        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n\t        targetObj.page.vx      = targetObj.page.x / dt;\n\t        targetObj.page.vy      = targetObj.page.y / dt;\n\t\n\t        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n\t        targetObj.client.vx    = targetObj.client.x / dt;\n\t        targetObj.client.vy    = targetObj.client.y / dt;\n\t    }\n\t\n\t    function isNativePointer (pointer) {\n\t        return (pointer instanceof window.Event\n\t            || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n\t    }\n\t\n\t    // Get specified X/Y coords for mouse or event.touches[0]\n\t    function getXY (type, pointer, xy) {\n\t        xy = xy || {};\n\t        type = type || 'page';\n\t\n\t        xy.x = pointer[type + 'X'];\n\t        xy.y = pointer[type + 'Y'];\n\t\n\t        return xy;\n\t    }\n\t\n\t    function getPageXY (pointer, page) {\n\t        page = page || {};\n\t\n\t        // Opera Mobile handles the viewport and scrolling oddly\n\t        if (isOperaMobile && isNativePointer(pointer)) {\n\t            getXY('screen', pointer, page);\n\t\n\t            page.x += window.scrollX;\n\t            page.y += window.scrollY;\n\t        }\n\t        else {\n\t            getXY('page', pointer, page);\n\t        }\n\t\n\t        return page;\n\t    }\n\t\n\t    function getClientXY (pointer, client) {\n\t        client = client || {};\n\t\n\t        if (isOperaMobile && isNativePointer(pointer)) {\n\t            // Opera Mobile handles the viewport and scrolling oddly\n\t            getXY('screen', pointer, client);\n\t        }\n\t        else {\n\t          getXY('client', pointer, client);\n\t        }\n\t\n\t        return client;\n\t    }\n\t\n\t    function getScrollXY (win) {\n\t        win = win || window;\n\t        return {\n\t            x: win.scrollX || win.document.documentElement.scrollLeft,\n\t            y: win.scrollY || win.document.documentElement.scrollTop\n\t        };\n\t    }\n\t\n\t    function getPointerId (pointer) {\n\t        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n\t    }\n\t\n\t    function getActualElement (element) {\n\t        return (element instanceof SVGElementInstance\n\t            ? element.correspondingUseElement\n\t            : element);\n\t    }\n\t\n\t    function getWindow (node) {\n\t        if (isWindow(node)) {\n\t            return node;\n\t        }\n\t\n\t        var rootNode = (node.ownerDocument || node);\n\t\n\t        return rootNode.defaultView || rootNode.parentWindow || window;\n\t    }\n\t\n\t    function getElementClientRect (element) {\n\t        var clientRect = (element instanceof SVGElement\n\t                            ? element.getBoundingClientRect()\n\t                            : element.getClientRects()[0]);\n\t\n\t        return clientRect && {\n\t            left  : clientRect.left,\n\t            right : clientRect.right,\n\t            top   : clientRect.top,\n\t            bottom: clientRect.bottom,\n\t            width : clientRect.width || clientRect.right - clientRect.left,\n\t            height: clientRect.height || clientRect.bottom - clientRect.top\n\t        };\n\t    }\n\t\n\t    function getElementRect (element) {\n\t        var clientRect = getElementClientRect(element);\n\t\n\t        if (!isIOS7 && clientRect) {\n\t            var scroll = getScrollXY(getWindow(element));\n\t\n\t            clientRect.left   += scroll.x;\n\t            clientRect.right  += scroll.x;\n\t            clientRect.top    += scroll.y;\n\t            clientRect.bottom += scroll.y;\n\t        }\n\t\n\t        return clientRect;\n\t    }\n\t\n\t    function getTouchPair (event) {\n\t        var touches = [];\n\t\n\t        // array of touches is supplied\n\t        if (isArray(event)) {\n\t            touches[0] = event[0];\n\t            touches[1] = event[1];\n\t        }\n\t        // an event\n\t        else {\n\t            if (event.type === 'touchend') {\n\t                if (event.touches.length === 1) {\n\t                    touches[0] = event.touches[0];\n\t                    touches[1] = event.changedTouches[0];\n\t                }\n\t                else if (event.touches.length === 0) {\n\t                    touches[0] = event.changedTouches[0];\n\t                    touches[1] = event.changedTouches[1];\n\t                }\n\t            }\n\t            else {\n\t                touches[0] = event.touches[0];\n\t                touches[1] = event.touches[1];\n\t            }\n\t        }\n\t\n\t        return touches;\n\t    }\n\t\n\t    function pointerAverage (pointers) {\n\t        var average = {\n\t            pageX  : 0,\n\t            pageY  : 0,\n\t            clientX: 0,\n\t            clientY: 0,\n\t            screenX: 0,\n\t            screenY: 0\n\t        };\n\t        var prop;\n\t\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            for (prop in average) {\n\t                average[prop] += pointers[i][prop];\n\t            }\n\t        }\n\t        for (prop in average) {\n\t            average[prop] /= pointers.length;\n\t        }\n\t\n\t        return average;\n\t    }\n\t\n\t    function touchBBox (event) {\n\t        if (!event.length && !(event.touches && event.touches.length > 1)) {\n\t            return;\n\t        }\n\t\n\t        var touches = getTouchPair(event),\n\t            minX = Math.min(touches[0].pageX, touches[1].pageX),\n\t            minY = Math.min(touches[0].pageY, touches[1].pageY),\n\t            maxX = Math.max(touches[0].pageX, touches[1].pageX),\n\t            maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\t\n\t        return {\n\t            x: minX,\n\t            y: minY,\n\t            left: minX,\n\t            top: minY,\n\t            width: maxX - minX,\n\t            height: maxY - minY\n\t        };\n\t    }\n\t\n\t    function touchDistance (event, deltaSource) {\n\t        deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t        var sourceX = deltaSource + 'X',\n\t            sourceY = deltaSource + 'Y',\n\t            touches = getTouchPair(event);\n\t\n\t\n\t        var dx = touches[0][sourceX] - touches[1][sourceX],\n\t            dy = touches[0][sourceY] - touches[1][sourceY];\n\t\n\t        return hypot(dx, dy);\n\t    }\n\t\n\t    function touchAngle (event, prevAngle, deltaSource) {\n\t        deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t        var sourceX = deltaSource + 'X',\n\t            sourceY = deltaSource + 'Y',\n\t            touches = getTouchPair(event),\n\t            dx = touches[0][sourceX] - touches[1][sourceX],\n\t            dy = touches[0][sourceY] - touches[1][sourceY],\n\t            angle = 180 * Math.atan(dy / dx) / Math.PI;\n\t\n\t        if (isNumber(prevAngle)) {\n\t            var dr = angle - prevAngle,\n\t                drClamped = dr % 360;\n\t\n\t            if (drClamped > 315) {\n\t                angle -= 360 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped > 135) {\n\t                angle -= 180 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped < -315) {\n\t                angle += 360 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped < -135) {\n\t                angle += 180 + (angle / 360)|0 * 360;\n\t            }\n\t        }\n\t\n\t        return  angle;\n\t    }\n\t\n\t    function getOriginXY (interactable, element) {\n\t        var origin = interactable\n\t                ? interactable.options.origin\n\t                : defaultOptions.origin;\n\t\n\t        if (origin === 'parent') {\n\t            origin = parentElement(element);\n\t        }\n\t        else if (origin === 'self') {\n\t            origin = interactable.getRect(element);\n\t        }\n\t        else if (trySelector(origin)) {\n\t            origin = closest(element, origin) || { x: 0, y: 0 };\n\t        }\n\t\n\t        if (isFunction(origin)) {\n\t            origin = origin(interactable && element);\n\t        }\n\t\n\t        if (isElement(origin))  {\n\t            origin = getElementRect(origin);\n\t        }\n\t\n\t        origin.x = ('x' in origin)? origin.x : origin.left;\n\t        origin.y = ('y' in origin)? origin.y : origin.top;\n\t\n\t        return origin;\n\t    }\n\t\n\t    // http://stackoverflow.com/a/5634528/2280888\n\t    function _getQBezierValue(t, p1, p2, p3) {\n\t        var iT = 1 - t;\n\t        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n\t    }\n\t\n\t    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n\t        return {\n\t            x:  _getQBezierValue(position, startX, cpX, endX),\n\t            y:  _getQBezierValue(position, startY, cpY, endY)\n\t        };\n\t    }\n\t\n\t    // http://gizma.com/easing/\n\t    function easeOutQuad (t, b, c, d) {\n\t        t /= d;\n\t        return -c * t*(t-2) + b;\n\t    }\n\t\n\t    function nodeContains (parent, child) {\n\t        while (child) {\n\t            if (child === parent) {\n\t                return true;\n\t            }\n\t\n\t            child = child.parentNode;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function closest (child, selector) {\n\t        var parent = parentElement(child);\n\t\n\t        while (isElement(parent)) {\n\t            if (matchesSelector(parent, selector)) { return parent; }\n\t\n\t            parent = parentElement(parent);\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    function parentElement (node) {\n\t        var parent = node.parentNode;\n\t\n\t        if (isDocFrag(parent)) {\n\t            // skip past #shado-root fragments\n\t            while ((parent = parent.host) && isDocFrag(parent)) {}\n\t\n\t            return parent;\n\t        }\n\t\n\t        return parent;\n\t    }\n\t\n\t    function inContext (interactable, element) {\n\t        return interactable._context === element.ownerDocument\n\t                || nodeContains(interactable._context, element);\n\t    }\n\t\n\t    function testIgnore (interactable, interactableElement, element) {\n\t        var ignoreFrom = interactable.options.ignoreFrom;\n\t\n\t        if (!ignoreFrom || !isElement(element)) { return false; }\n\t\n\t        if (isString(ignoreFrom)) {\n\t            return matchesUpTo(element, ignoreFrom, interactableElement);\n\t        }\n\t        else if (isElement(ignoreFrom)) {\n\t            return nodeContains(ignoreFrom, element);\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function testAllow (interactable, interactableElement, element) {\n\t        var allowFrom = interactable.options.allowFrom;\n\t\n\t        if (!allowFrom) { return true; }\n\t\n\t        if (!isElement(element)) { return false; }\n\t\n\t        if (isString(allowFrom)) {\n\t            return matchesUpTo(element, allowFrom, interactableElement);\n\t        }\n\t        else if (isElement(allowFrom)) {\n\t            return nodeContains(allowFrom, element);\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function checkAxis (axis, interactable) {\n\t        if (!interactable) { return false; }\n\t\n\t        var thisAxis = interactable.options.drag.axis;\n\t\n\t        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n\t    }\n\t\n\t    function checkSnap (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return options[action].snap && options[action].snap.enabled;\n\t    }\n\t\n\t    function checkRestrict (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return  options[action].restrict && options[action].restrict.enabled;\n\t    }\n\t\n\t    function checkAutoScroll (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return  options[action].autoScroll && options[action].autoScroll.enabled;\n\t    }\n\t\n\t    function withinInteractionLimit (interactable, element, action) {\n\t        var options = interactable.options,\n\t            maxActions = options[action.name].max,\n\t            maxPerElement = options[action.name].maxPerElement,\n\t            activeInteractions = 0,\n\t            targetCount = 0,\n\t            targetElementCount = 0;\n\t\n\t        for (var i = 0, len = interactions.length; i < len; i++) {\n\t            var interaction = interactions[i],\n\t                otherAction = interaction.prepared.name,\n\t                active = interaction.interacting();\n\t\n\t            if (!active) { continue; }\n\t\n\t            activeInteractions++;\n\t\n\t            if (activeInteractions >= maxInteractions) {\n\t                return false;\n\t            }\n\t\n\t            if (interaction.target !== interactable) { continue; }\n\t\n\t            targetCount += (otherAction === action.name)|0;\n\t\n\t            if (targetCount >= maxActions) {\n\t                return false;\n\t            }\n\t\n\t            if (interaction.element === element) {\n\t                targetElementCount++;\n\t\n\t                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        return maxInteractions > 0;\n\t    }\n\t\n\t    // Test for the element that's \"above\" all other qualifiers\n\t    function indexOfDeepestElement (elements) {\n\t        var dropzone,\n\t            deepestZone = elements[0],\n\t            index = deepestZone? 0: -1,\n\t            parent,\n\t            deepestZoneParents = [],\n\t            dropzoneParents = [],\n\t            child,\n\t            i,\n\t            n;\n\t\n\t        for (i = 1; i < elements.length; i++) {\n\t            dropzone = elements[i];\n\t\n\t            // an element might belong to multiple selector dropzones\n\t            if (!dropzone || dropzone === deepestZone) {\n\t                continue;\n\t            }\n\t\n\t            if (!deepestZone) {\n\t                deepestZone = dropzone;\n\t                index = i;\n\t                continue;\n\t            }\n\t\n\t            // check if the deepest or current are document.documentElement or document.rootElement\n\t            // - if the current dropzone is, do nothing and continue\n\t            if (dropzone.parentNode === dropzone.ownerDocument) {\n\t                continue;\n\t            }\n\t            // - if deepest is, update with the current dropzone and continue to next\n\t            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n\t                deepestZone = dropzone;\n\t                index = i;\n\t                continue;\n\t            }\n\t\n\t            if (!deepestZoneParents.length) {\n\t                parent = deepestZone;\n\t                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n\t                    deepestZoneParents.unshift(parent);\n\t                    parent = parent.parentNode;\n\t                }\n\t            }\n\t\n\t            // if this element is an svg element and the current deepest is\n\t            // an HTMLElement\n\t            if (deepestZone instanceof HTMLElement\n\t                && dropzone instanceof SVGElement\n\t                && !(dropzone instanceof SVGSVGElement)) {\n\t\n\t                if (dropzone === deepestZone.parentNode) {\n\t                    continue;\n\t                }\n\t\n\t                parent = dropzone.ownerSVGElement;\n\t            }\n\t            else {\n\t                parent = dropzone;\n\t            }\n\t\n\t            dropzoneParents = [];\n\t\n\t            while (parent.parentNode !== parent.ownerDocument) {\n\t                dropzoneParents.unshift(parent);\n\t                parent = parent.parentNode;\n\t            }\n\t\n\t            n = 0;\n\t\n\t            // get (position of last common ancestor) + 1\n\t            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n\t                n++;\n\t            }\n\t\n\t            var parents = [\n\t                dropzoneParents[n - 1],\n\t                dropzoneParents[n],\n\t                deepestZoneParents[n]\n\t            ];\n\t\n\t            child = parents[0].lastChild;\n\t\n\t            while (child) {\n\t                if (child === parents[1]) {\n\t                    deepestZone = dropzone;\n\t                    index = i;\n\t                    deepestZoneParents = [];\n\t\n\t                    break;\n\t                }\n\t                else if (child === parents[2]) {\n\t                    break;\n\t                }\n\t\n\t                child = child.previousSibling;\n\t            }\n\t        }\n\t\n\t        return index;\n\t    }\n\t\n\t    function Interaction () {\n\t        this.target          = null; // current interactable being interacted with\n\t        this.element         = null; // the target element of the interactable\n\t        this.dropTarget      = null; // the dropzone a drag target might be dropped into\n\t        this.dropElement     = null; // the element at the time of checking\n\t        this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n\t        this.prevDropElement = null; // the element at the time of checking\n\t\n\t        this.prepared        = {     // action that's ready to be fired on next move event\n\t            name : null,\n\t            axis : null,\n\t            edges: null\n\t        };\n\t\n\t        this.matches         = [];   // all selectors that are matched by target element\n\t        this.matchElements   = [];   // corresponding elements\n\t\n\t        this.inertiaStatus = {\n\t            active       : false,\n\t            smoothEnd    : false,\n\t            ending       : false,\n\t\n\t            startEvent: null,\n\t            upCoords: {},\n\t\n\t            xe: 0, ye: 0,\n\t            sx: 0, sy: 0,\n\t\n\t            t0: 0,\n\t            vx0: 0, vys: 0,\n\t            duration: 0,\n\t\n\t            resumeDx: 0,\n\t            resumeDy: 0,\n\t\n\t            lambda_v0: 0,\n\t            one_ve_v0: 0,\n\t            i  : null\n\t        };\n\t\n\t        if (isFunction(Function.prototype.bind)) {\n\t            this.boundInertiaFrame = this.inertiaFrame.bind(this);\n\t            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n\t        }\n\t        else {\n\t            var that = this;\n\t\n\t            this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n\t            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n\t        }\n\t\n\t        this.activeDrops = {\n\t            dropzones: [],      // the dropzones that are mentioned below\n\t            elements : [],      // elements of dropzones that accept the target draggable\n\t            rects    : []       // the rects of the elements mentioned above\n\t        };\n\t\n\t        // keep track of added pointers\n\t        this.pointers    = [];\n\t        this.pointerIds  = [];\n\t        this.downTargets = [];\n\t        this.downTimes   = [];\n\t        this.holdTimers  = [];\n\t\n\t        // Previous native pointer move event coordinates\n\t        this.prevCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t        // current native pointer move event coordinates\n\t        this.curCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        // Starting InteractEvent pointer coordinates\n\t        this.startCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        // Change in coordinates and time of the pointer\n\t        this.pointerDelta = {\n\t            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n\t        this.downPointer = {};\n\t\n\t        this._eventTarget    = null;\n\t        this._curEventTarget = null;\n\t\n\t        this.prevEvent = null;      // previous action event\n\t        this.tapTime   = 0;         // time of the most recent tap event\n\t        this.prevTap   = null;\n\t\n\t        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n\t        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n\t        this.snapOffsets    = [];\n\t\n\t        this.gesture = {\n\t            start: { x: 0, y: 0 },\n\t\n\t            startDistance: 0,   // distance between two touches of touchStart\n\t            prevDistance : 0,\n\t            distance     : 0,\n\t\n\t            scale: 1,           // gesture.distance / gesture.startDistance\n\t\n\t            startAngle: 0,      // angle of line joining two touches\n\t            prevAngle : 0       // angle of the previous gesture event\n\t        };\n\t\n\t        this.snapStatus = {\n\t            x       : 0, y       : 0,\n\t            dx      : 0, dy      : 0,\n\t            realX   : 0, realY   : 0,\n\t            snappedX: 0, snappedY: 0,\n\t            targets : [],\n\t            locked  : false,\n\t            changed : false\n\t        };\n\t\n\t        this.restrictStatus = {\n\t            dx         : 0, dy         : 0,\n\t            restrictedX: 0, restrictedY: 0,\n\t            snap       : null,\n\t            restricted : false,\n\t            changed    : false\n\t        };\n\t\n\t        this.restrictStatus.snap = this.snapStatus;\n\t\n\t        this.pointerIsDown   = false;\n\t        this.pointerWasMoved = false;\n\t        this.gesturing       = false;\n\t        this.dragging        = false;\n\t        this.resizing        = false;\n\t        this.resizeAxes      = 'xy';\n\t\n\t        this.mouse = false;\n\t\n\t        interactions.push(this);\n\t    }\n\t\n\t    Interaction.prototype = {\n\t        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n\t        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n\t        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\t\n\t        pointerOver: function (pointer, event, eventTarget) {\n\t            if (this.prepared.name || !this.mouse) { return; }\n\t\n\t            var curMatches = [],\n\t                curMatchElements = [],\n\t                prevTargetElement = this.element;\n\t\n\t            this.addPointer(pointer);\n\t\n\t            if (this.target\n\t                && (testIgnore(this.target, this.element, eventTarget)\n\t                    || !testAllow(this.target, this.element, eventTarget))) {\n\t                // if the eventTarget should be ignored or shouldn't be allowed\n\t                // clear the previous target\n\t                this.target = null;\n\t                this.element = null;\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t            }\n\t\n\t            var elementInteractable = interactables.get(eventTarget),\n\t                elementAction = (elementInteractable\n\t                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)\n\t                                 && testAllow(elementInteractable, eventTarget, eventTarget)\n\t                                 && validateAction(\n\t                                     elementInteractable.getAction(pointer, event, this, eventTarget),\n\t                                     elementInteractable));\n\t\n\t            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n\t                 elementAction = null;\n\t            }\n\t\n\t            function pushCurMatches (interactable, selector) {\n\t                if (interactable\n\t                    && inContext(interactable, eventTarget)\n\t                    && !testIgnore(interactable, eventTarget, eventTarget)\n\t                    && testAllow(interactable, eventTarget, eventTarget)\n\t                    && matchesSelector(eventTarget, selector)) {\n\t\n\t                    curMatches.push(interactable);\n\t                    curMatchElements.push(eventTarget);\n\t                }\n\t            }\n\t\n\t            if (elementAction) {\n\t                this.target = elementInteractable;\n\t                this.element = eventTarget;\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t            }\n\t            else {\n\t                interactables.forEachSelector(pushCurMatches);\n\t\n\t                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n\t                    this.matches = curMatches;\n\t                    this.matchElements = curMatchElements;\n\t\n\t                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t                    events.add(eventTarget,\n\t                                        PointerEvent? pEventTypes.move : 'mousemove',\n\t                                        listeners.pointerHover);\n\t                }\n\t                else if (this.target) {\n\t                    if (nodeContains(prevTargetElement, eventTarget)) {\n\t                        this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t                        events.add(this.element,\n\t                                            PointerEvent? pEventTypes.move : 'mousemove',\n\t                                            listeners.pointerHover);\n\t                    }\n\t                    else {\n\t                        this.target = null;\n\t                        this.element = null;\n\t                        this.matches = [];\n\t                        this.matchElements = [];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        // Check what action would be performed on pointerMove target if a mouse\n\t        // button were pressed and change the cursor accordingly\n\t        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n\t            var target = this.target;\n\t\n\t            if (!this.prepared.name && this.mouse) {\n\t\n\t                var action;\n\t\n\t                // update pointer coords for defaultActionChecker to use\n\t                this.setEventXY(this.curCoords, [pointer]);\n\t\n\t                if (matches) {\n\t                    action = this.validateSelector(pointer, event, matches, matchElements);\n\t                }\n\t                else if (target) {\n\t                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n\t                }\n\t\n\t                if (target && target.options.styleCursor) {\n\t                    if (action) {\n\t                        target._doc.documentElement.style.cursor = getActionCursor(action);\n\t                    }\n\t                    else {\n\t                        target._doc.documentElement.style.cursor = '';\n\t                    }\n\t                }\n\t            }\n\t            else if (this.prepared.name) {\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t        },\n\t\n\t        pointerOut: function (pointer, event, eventTarget) {\n\t            if (this.prepared.name) { return; }\n\t\n\t            // Remove temporary event listeners for selector Interactables\n\t            if (!interactables.get(eventTarget)) {\n\t                events.remove(eventTarget,\n\t                                       PointerEvent? pEventTypes.move : 'mousemove',\n\t                                       listeners.pointerHover);\n\t            }\n\t\n\t            if (this.target && this.target.options.styleCursor && !this.interacting()) {\n\t                this.target._doc.documentElement.style.cursor = '';\n\t            }\n\t        },\n\t\n\t        selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n\t            var that = this,\n\t                // copy event to be used in timeout for IE8\n\t                eventCopy = events.useAttachEvent? extend({}, event) : event,\n\t                element = eventTarget,\n\t                pointerIndex = this.addPointer(pointer),\n\t                action;\n\t\n\t            this.holdTimers[pointerIndex] = setTimeout(function () {\n\t                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n\t            }, defaultOptions._holdDuration);\n\t\n\t            this.pointerIsDown = true;\n\t\n\t            // Check if the down event hits the current inertia target\n\t            if (this.inertiaStatus.active && this.target.selector) {\n\t                // climb up the DOM tree from the event target\n\t                while (isElement(element)) {\n\t\n\t                    // if this element is the current inertia target element\n\t                    if (element === this.element\n\t                        // and the prospective action is the same as the ongoing one\n\t                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\t\n\t                        // stop inertia so that the next move will be a normal one\n\t                        cancelFrame(this.inertiaStatus.i);\n\t                        this.inertiaStatus.active = false;\n\t\n\t                        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t                        return;\n\t                    }\n\t                    element = parentElement(element);\n\t                }\n\t            }\n\t\n\t            // do nothing if interacting\n\t            if (this.interacting()) {\n\t                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t                return;\n\t            }\n\t\n\t            function pushMatches (interactable, selector, context) {\n\t                var elements = ie8MatchesSelector\n\t                    ? context.querySelectorAll(selector)\n\t                    : undefined;\n\t\n\t                if (inContext(interactable, element)\n\t                    && !testIgnore(interactable, element, eventTarget)\n\t                    && testAllow(interactable, element, eventTarget)\n\t                    && matchesSelector(element, selector, elements)) {\n\t\n\t                    that.matches.push(interactable);\n\t                    that.matchElements.push(element);\n\t                }\n\t            }\n\t\n\t            // update pointer coords for defaultActionChecker to use\n\t            this.setEventXY(this.curCoords, [pointer]);\n\t            this.downEvent = event;\n\t\n\t            while (isElement(element) && !action) {\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t\n\t                interactables.forEachSelector(pushMatches);\n\t\n\t                action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n\t                element = parentElement(element);\n\t            }\n\t\n\t            if (action) {\n\t                this.prepared.name  = action.name;\n\t                this.prepared.axis  = action.axis;\n\t                this.prepared.edges = action.edges;\n\t\n\t                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t\n\t                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n\t            }\n\t            else {\n\t                // do these now since pointerDown isn't being called from here\n\t                this.downTimes[pointerIndex] = new Date().getTime();\n\t                this.downTargets[pointerIndex] = eventTarget;\n\t                pointerExtend(this.downPointer, pointer);\n\t\n\t                copyCoords(this.prevCoords, this.curCoords);\n\t                this.pointerWasMoved = false;\n\t            }\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t        },\n\t\n\t        // Determine action to be performed on next pointerMove and add appropriate\n\t        // style and event Listeners\n\t        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n\t            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n\t                this.checkAndPreventDefault(event, this.target, this.element);\n\t\n\t                return;\n\t            }\n\t\n\t            this.pointerIsDown = true;\n\t            this.downEvent = event;\n\t\n\t            var pointerIndex = this.addPointer(pointer),\n\t                action;\n\t\n\t            // If it is the second touch of a multi-touch gesture, keep the\n\t            // target the same and get a new action if a target was set by the\n\t            // first touch\n\t            if (this.pointerIds.length > 1 && this.target._element === this.element) {\n\t                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\t\n\t                if (withinInteractionLimit(this.target, this.element, newAction)) {\n\t                    action = newAction;\n\t                }\n\t\n\t                this.prepared.name = null;\n\t            }\n\t            // Otherwise, set the target if there is no action prepared\n\t            else if (!this.prepared.name) {\n\t                var interactable = interactables.get(curEventTarget);\n\t\n\t                if (interactable\n\t                    && !testIgnore(interactable, curEventTarget, eventTarget)\n\t                    && testAllow(interactable, curEventTarget, eventTarget)\n\t                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n\t                    && withinInteractionLimit(interactable, curEventTarget, action)) {\n\t                    this.target = interactable;\n\t                    this.element = curEventTarget;\n\t                }\n\t            }\n\t\n\t            var target = this.target,\n\t                options = target && target.options;\n\t\n\t            if (target && (forceAction || !this.prepared.name)) {\n\t                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\t\n\t                this.setEventXY(this.startCoords, this.pointers);\n\t\n\t                if (!action) { return; }\n\t\n\t                if (options.styleCursor) {\n\t                    target._doc.documentElement.style.cursor = getActionCursor(action);\n\t                }\n\t\n\t                this.resizeAxes = action.name === 'resize'? action.axis : null;\n\t\n\t                if (action === 'gesture' && this.pointerIds.length < 2) {\n\t                    action = null;\n\t                }\n\t\n\t                this.prepared.name  = action.name;\n\t                this.prepared.axis  = action.axis;\n\t                this.prepared.edges = action.edges;\n\t\n\t                this.snapStatus.snappedX = this.snapStatus.snappedY =\n\t                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\t\n\t                this.downTimes[pointerIndex] = new Date().getTime();\n\t                this.downTargets[pointerIndex] = eventTarget;\n\t                pointerExtend(this.downPointer, pointer);\n\t\n\t                copyCoords(this.prevCoords, this.startCoords);\n\t                this.pointerWasMoved = false;\n\t\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t            // if inertia is active try to resume action\n\t            else if (this.inertiaStatus.active\n\t                && curEventTarget === this.element\n\t                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\t\n\t                cancelFrame(this.inertiaStatus.i);\n\t                this.inertiaStatus.active = false;\n\t\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t        },\n\t\n\t        setModifications: function (coords, preEnd) {\n\t            var target         = this.target,\n\t                shouldMove     = true,\n\t                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n\t                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\t\n\t            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n\t            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\t\n\t            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n\t                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n\t            }\n\t            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n\t                shouldMove = false;\n\t            }\n\t\n\t            return shouldMove;\n\t        },\n\t\n\t        setStartOffsets: function (action, interactable, element) {\n\t            var rect = interactable.getRect(element),\n\t                origin = getOriginXY(interactable, element),\n\t                snap = interactable.options[this.prepared.name].snap,\n\t                restrict = interactable.options[this.prepared.name].restrict,\n\t                width, height;\n\t\n\t            if (rect) {\n\t                this.startOffset.left = this.startCoords.page.x - rect.left;\n\t                this.startOffset.top  = this.startCoords.page.y - rect.top;\n\t\n\t                this.startOffset.right  = rect.right  - this.startCoords.page.x;\n\t                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\t\n\t                if ('width' in rect) { width = rect.width; }\n\t                else { width = rect.right - rect.left; }\n\t                if ('height' in rect) { height = rect.height; }\n\t                else { height = rect.bottom - rect.top; }\n\t            }\n\t            else {\n\t                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n\t            }\n\t\n\t            this.snapOffsets.splice(0);\n\t\n\t            var snapOffset = snap && snap.offset === 'startCoords'\n\t                                ? {\n\t                                    x: this.startCoords.page.x - origin.x,\n\t                                    y: this.startCoords.page.y - origin.y\n\t                                }\n\t                                : snap && snap.offset || { x: 0, y: 0 };\n\t\n\t            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n\t                for (var i = 0; i < snap.relativePoints.length; i++) {\n\t                    this.snapOffsets.push({\n\t                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n\t                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n\t                    });\n\t                }\n\t            }\n\t            else {\n\t                this.snapOffsets.push(snapOffset);\n\t            }\n\t\n\t            if (rect && restrict.elementRect) {\n\t                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n\t                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\t\n\t                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n\t                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n\t            }\n\t            else {\n\t                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n\t            }\n\t        },\n\t\n\t        /*\\\n\t         * Interaction.start\n\t         [ method ]\n\t         *\n\t         * Start an action with the given Interactable and Element as tartgets. The\n\t         * action must be enabled for the target Interactable and an appropriate number\n\t         * of pointers must be held down – 1 for drag/resize, 2 for gesture.\n\t         *\n\t         * Use it with `interactable.<action>able({ manualStart: false })` to always\n\t         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n\t         *\n\t         - action       (object)  The action to be performed - drag, resize, etc.\n\t         - interactable (Interactable) The Interactable to target\n\t         - element      (Element) The DOM Element to target\n\t         = (object) interact\n\t         **\n\t         | interact(target)\n\t         |   .draggable({\n\t         |     // disable the default drag start by down->move\n\t         |     manualStart: true\n\t         |   })\n\t         |   // start dragging after the user holds the pointer down\n\t         |   .on('hold', function (event) {\n\t         |     var interaction = event.interaction;\n\t         |\n\t         |     if (!interaction.interacting()) {\n\t         |       interaction.start({ name: 'drag' },\n\t         |                         event.interactable,\n\t         |                         event.currentTarget);\n\t         |     }\n\t         | });\n\t        \\*/\n\t        start: function (action, interactable, element) {\n\t            if (this.interacting()\n\t                || !this.pointerIsDown\n\t                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n\t                return;\n\t            }\n\t\n\t            // if this interaction had been removed after stopping\n\t            // add it back\n\t            if (indexOf(interactions, this) === -1) {\n\t                interactions.push(this);\n\t            }\n\t\n\t            // set the startCoords if there was no prepared action\n\t            if (!this.prepared.name) {\n\t                this.setEventXY(this.startCoords);\n\t            }\n\t\n\t            this.prepared.name  = action.name;\n\t            this.prepared.axis  = action.axis;\n\t            this.prepared.edges = action.edges;\n\t            this.target         = interactable;\n\t            this.element        = element;\n\t\n\t            this.setStartOffsets(action.name, interactable, element);\n\t            this.setModifications(this.startCoords.page);\n\t\n\t            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n\t        },\n\t\n\t        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n\t            if (this.inertiaStatus.active) {\n\t                var pageUp   = this.inertiaStatus.upCoords.page;\n\t                var clientUp = this.inertiaStatus.upCoords.client;\n\t\n\t                var inertiaPosition = {\n\t                    pageX  : pageUp.x   + this.inertiaStatus.sx,\n\t                    pageY  : pageUp.y   + this.inertiaStatus.sy,\n\t                    clientX: clientUp.x + this.inertiaStatus.sx,\n\t                    clientY: clientUp.y + this.inertiaStatus.sy\n\t                };\n\t\n\t                this.setEventXY(this.curCoords, [inertiaPosition]);\n\t            }\n\t            else {\n\t                this.recordPointer(pointer);\n\t                this.setEventXY(this.curCoords, this.pointers);\n\t            }\n\t\n\t            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n\t                                 && this.curCoords.page.y === this.prevCoords.page.y\n\t                                 && this.curCoords.client.x === this.prevCoords.client.x\n\t                                 && this.curCoords.client.y === this.prevCoords.client.y);\n\t\n\t            var dx, dy,\n\t                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            // register movement greater than pointerMoveTolerance\n\t            if (this.pointerIsDown && !this.pointerWasMoved) {\n\t                dx = this.curCoords.client.x - this.startCoords.client.x;\n\t                dy = this.curCoords.client.y - this.startCoords.client.y;\n\t\n\t                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n\t            }\n\t\n\t            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n\t                if (this.pointerIsDown) {\n\t                    clearTimeout(this.holdTimers[pointerIndex]);\n\t                }\n\t\n\t                this.collectEventTargets(pointer, event, eventTarget, 'move');\n\t            }\n\t\n\t            if (!this.pointerIsDown) { return; }\n\t\n\t            if (duplicateMove && this.pointerWasMoved && !preEnd) {\n\t                this.checkAndPreventDefault(event, this.target, this.element);\n\t                return;\n\t            }\n\t\n\t            // set pointer coordinate, time changes and speeds\n\t            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t            if (!this.prepared.name) { return; }\n\t\n\t            if (this.pointerWasMoved\n\t                // ignore movement while inertia is active\n\t                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\t\n\t                // if just starting an action, calculate the pointer speed now\n\t                if (!this.interacting()) {\n\t                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t                    // check if a drag is in the correct axis\n\t                    if (this.prepared.name === 'drag') {\n\t                        var absX = Math.abs(dx),\n\t                            absY = Math.abs(dy),\n\t                            targetAxis = this.target.options.drag.axis,\n\t                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\t\n\t                        // if the movement isn't in the axis of the interactable\n\t                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n\t                            // cancel the prepared action\n\t                            this.prepared.name = null;\n\t\n\t                            // then try to get a drag from another ineractable\n\t\n\t                            var element = eventTarget;\n\t\n\t                            // check element interactables\n\t                            while (isElement(element)) {\n\t                                var elementInteractable = interactables.get(element);\n\t\n\t                                if (elementInteractable\n\t                                    && elementInteractable !== this.target\n\t                                    && !elementInteractable.options.drag.manualStart\n\t                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n\t                                    && checkAxis(axis, elementInteractable)) {\n\t\n\t                                    this.prepared.name = 'drag';\n\t                                    this.target = elementInteractable;\n\t                                    this.element = element;\n\t                                    break;\n\t                                }\n\t\n\t                                element = parentElement(element);\n\t                            }\n\t\n\t                            // if there's no drag from element interactables,\n\t                            // check the selector interactables\n\t                            if (!this.prepared.name) {\n\t                                var thisInteraction = this;\n\t\n\t                                var getDraggable = function (interactable, selector, context) {\n\t                                    var elements = ie8MatchesSelector\n\t                                        ? context.querySelectorAll(selector)\n\t                                        : undefined;\n\t\n\t                                    if (interactable === thisInteraction.target) { return; }\n\t\n\t                                    if (inContext(interactable, eventTarget)\n\t                                        && !interactable.options.drag.manualStart\n\t                                        && !testIgnore(interactable, element, eventTarget)\n\t                                        && testAllow(interactable, element, eventTarget)\n\t                                        && matchesSelector(element, selector, elements)\n\t                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n\t                                        && checkAxis(axis, interactable)\n\t                                        && withinInteractionLimit(interactable, element, 'drag')) {\n\t\n\t                                        return interactable;\n\t                                    }\n\t                                };\n\t\n\t                                element = eventTarget;\n\t\n\t                                while (isElement(element)) {\n\t                                    var selectorInteractable = interactables.forEachSelector(getDraggable);\n\t\n\t                                    if (selectorInteractable) {\n\t                                        this.prepared.name = 'drag';\n\t                                        this.target = selectorInteractable;\n\t                                        this.element = element;\n\t                                        break;\n\t                                    }\n\t\n\t                                    element = parentElement(element);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var starting = !!this.prepared.name && !this.interacting();\n\t\n\t                if (starting\n\t                    && (this.target.options[this.prepared.name].manualStart\n\t                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n\t                    this.stop(event);\n\t                    return;\n\t                }\n\t\n\t                if (this.prepared.name && this.target) {\n\t                    if (starting) {\n\t                        this.start(this.prepared, this.target, this.element);\n\t                    }\n\t\n\t                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\t\n\t                    // move if snapping or restriction doesn't prevent it\n\t                    if (shouldMove || starting) {\n\t                        this.prevEvent = this[this.prepared.name + 'Move'](event);\n\t                    }\n\t\n\t                    this.checkAndPreventDefault(event, this.target, this.element);\n\t                }\n\t            }\n\t\n\t            copyCoords(this.prevCoords, this.curCoords);\n\t\n\t            if (this.dragging || this.resizing) {\n\t                this.autoScrollMove(pointer);\n\t            }\n\t        },\n\t\n\t        dragStart: function (event) {\n\t            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\t\n\t            this.dragging = true;\n\t            this.target.fire(dragEvent);\n\t\n\t            // reset active dropzones\n\t            this.activeDrops.dropzones = [];\n\t            this.activeDrops.elements  = [];\n\t            this.activeDrops.rects     = [];\n\t\n\t            if (!this.dynamicDrop) {\n\t                this.setActiveDrops(this.element);\n\t            }\n\t\n\t            var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t            if (dropEvents.activate) {\n\t                this.fireActiveDrops(dropEvents.activate);\n\t            }\n\t\n\t            return dragEvent;\n\t        },\n\t\n\t        dragMove: function (event) {\n\t            var target = this.target,\n\t                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n\t                draggableElement = this.element,\n\t                drop = this.getDrop(dragEvent, event, draggableElement);\n\t\n\t            this.dropTarget = drop.dropzone;\n\t            this.dropElement = drop.element;\n\t\n\t            var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t            target.fire(dragEvent);\n\t\n\t            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n\t            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n\t            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\t\n\t            this.prevDropTarget  = this.dropTarget;\n\t            this.prevDropElement = this.dropElement;\n\t\n\t            return dragEvent;\n\t        },\n\t\n\t        resizeStart: function (event) {\n\t            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\t\n\t            if (this.prepared.edges) {\n\t                var startRect = this.target.getRect(this.element);\n\t\n\t                /*\n\t                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n\t                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n\t                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n\t                 * on the active edges and the edge being interacted with.\n\t                 */\n\t                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n\t                    var linkedEdges = extend({}, this.prepared.edges);\n\t\n\t                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n\t                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n\t                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n\t                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\t\n\t                    this.prepared._linkedEdges = linkedEdges;\n\t                }\n\t                else {\n\t                    this.prepared._linkedEdges = null;\n\t                }\n\t\n\t                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n\t                if (this.target.options.resize.preserveAspectRatio) {\n\t                    this.resizeStartAspectRatio = startRect.width / startRect.height;\n\t                }\n\t\n\t                this.resizeRects = {\n\t                    start     : startRect,\n\t                    current   : extend({}, startRect),\n\t                    restricted: extend({}, startRect),\n\t                    previous  : extend({}, startRect),\n\t                    delta     : {\n\t                        left: 0, right : 0, width : 0,\n\t                        top : 0, bottom: 0, height: 0\n\t                    }\n\t                };\n\t\n\t                resizeEvent.rect = this.resizeRects.restricted;\n\t                resizeEvent.deltaRect = this.resizeRects.delta;\n\t            }\n\t\n\t            this.target.fire(resizeEvent);\n\t\n\t            this.resizing = true;\n\t\n\t            return resizeEvent;\n\t        },\n\t\n\t        resizeMove: function (event) {\n\t            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\t\n\t            var edges = this.prepared.edges,\n\t                invert = this.target.options.resize.invert,\n\t                invertible = invert === 'reposition' || invert === 'negate';\n\t\n\t            if (edges) {\n\t                var dx = resizeEvent.dx,\n\t                    dy = resizeEvent.dy,\n\t\n\t                    start      = this.resizeRects.start,\n\t                    current    = this.resizeRects.current,\n\t                    restricted = this.resizeRects.restricted,\n\t                    delta      = this.resizeRects.delta,\n\t                    previous   = extend(this.resizeRects.previous, restricted),\n\t\n\t                    originalEdges = edges;\n\t\n\t                // `resize.preserveAspectRatio` takes precedence over `resize.square`\n\t                if (this.target.options.resize.preserveAspectRatio) {\n\t                    var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\t\n\t                    edges = this.prepared._linkedEdges;\n\t\n\t                    if ((originalEdges.left && originalEdges.bottom)\n\t                        || (originalEdges.right && originalEdges.top)) {\n\t                        dy = -dx / resizeStartAspectRatio;\n\t                    }\n\t                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n\t                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n\t                }\n\t                else if (this.target.options.resize.square) {\n\t                    edges = this.prepared._linkedEdges;\n\t\n\t                    if ((originalEdges.left && originalEdges.bottom)\n\t                        || (originalEdges.right && originalEdges.top)) {\n\t                        dy = -dx;\n\t                    }\n\t                    else if (originalEdges.left || originalEdges.right) { dy = dx; }\n\t                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n\t                }\n\t\n\t                // update the 'current' rect without modifications\n\t                if (edges.top   ) { current.top    += dy; }\n\t                if (edges.bottom) { current.bottom += dy; }\n\t                if (edges.left  ) { current.left   += dx; }\n\t                if (edges.right ) { current.right  += dx; }\n\t\n\t                if (invertible) {\n\t                    // if invertible, copy the current rect\n\t                    extend(restricted, current);\n\t\n\t                    if (invert === 'reposition') {\n\t                        // swap edge values if necessary to keep width/height positive\n\t                        var swap;\n\t\n\t                        if (restricted.top > restricted.bottom) {\n\t                            swap = restricted.top;\n\t\n\t                            restricted.top = restricted.bottom;\n\t                            restricted.bottom = swap;\n\t                        }\n\t                        if (restricted.left > restricted.right) {\n\t                            swap = restricted.left;\n\t\n\t                            restricted.left = restricted.right;\n\t                            restricted.right = swap;\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    // if not invertible, restrict to minimum of 0x0 rect\n\t                    restricted.top    = Math.min(current.top, start.bottom);\n\t                    restricted.bottom = Math.max(current.bottom, start.top);\n\t                    restricted.left   = Math.min(current.left, start.right);\n\t                    restricted.right  = Math.max(current.right, start.left);\n\t                }\n\t\n\t                restricted.width  = restricted.right  - restricted.left;\n\t                restricted.height = restricted.bottom - restricted.top ;\n\t\n\t                for (var edge in restricted) {\n\t                    delta[edge] = restricted[edge] - previous[edge];\n\t                }\n\t\n\t                resizeEvent.edges = this.prepared.edges;\n\t                resizeEvent.rect = restricted;\n\t                resizeEvent.deltaRect = delta;\n\t            }\n\t\n\t            this.target.fire(resizeEvent);\n\t\n\t            return resizeEvent;\n\t        },\n\t\n\t        gestureStart: function (event) {\n\t            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\t\n\t            gestureEvent.ds = 0;\n\t\n\t            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n\t            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n\t            this.gesture.scale = 1;\n\t\n\t            this.gesturing = true;\n\t\n\t            this.target.fire(gestureEvent);\n\t\n\t            return gestureEvent;\n\t        },\n\t\n\t        gestureMove: function (event) {\n\t            if (!this.pointerIds.length) {\n\t                return this.prevEvent;\n\t            }\n\t\n\t            var gestureEvent;\n\t\n\t            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n\t            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\t\n\t            this.target.fire(gestureEvent);\n\t\n\t            this.gesture.prevAngle = gestureEvent.angle;\n\t            this.gesture.prevDistance = gestureEvent.distance;\n\t\n\t            if (gestureEvent.scale !== Infinity &&\n\t                gestureEvent.scale !== null &&\n\t                gestureEvent.scale !== undefined  &&\n\t                !isNaN(gestureEvent.scale)) {\n\t\n\t                this.gesture.scale = gestureEvent.scale;\n\t            }\n\t\n\t            return gestureEvent;\n\t        },\n\t\n\t        pointerHold: function (pointer, event, eventTarget) {\n\t            this.collectEventTargets(pointer, event, eventTarget, 'hold');\n\t        },\n\t\n\t        pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'up' );\n\t            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t\n\t            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t            this.removePointer(pointer);\n\t        },\n\t\n\t        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n\t            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t            this.removePointer(pointer);\n\t        },\n\t\n\t        // http://www.quirksmode.org/dom/events/click.html\n\t        // >Events leading to dblclick\n\t        //\n\t        // IE8 doesn't fire down event before dblclick.\n\t        // This workaround tries to fire a tap and doubletap after dblclick\n\t        ie8Dblclick: function (pointer, event, eventTarget) {\n\t            if (this.prevTap\n\t                && event.clientX === this.prevTap.clientX\n\t                && event.clientY === this.prevTap.clientY\n\t                && eventTarget   === this.prevTap.target) {\n\t\n\t                this.downTargets[0] = eventTarget;\n\t                this.downTimes[0] = new Date().getTime();\n\t                this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t            }\n\t        },\n\t\n\t        // End interact move events and stop auto-scroll unless inertia is enabled\n\t        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n\t            var endEvent,\n\t                target = this.target,\n\t                options = target && target.options,\n\t                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n\t                inertiaStatus = this.inertiaStatus;\n\t\n\t            if (this.interacting()) {\n\t\n\t                if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\t\n\t                var pointerSpeed,\n\t                    now = new Date().getTime(),\n\t                    inertiaPossible = false,\n\t                    inertia = false,\n\t                    smoothEnd = false,\n\t                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n\t                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n\t                    dx = 0,\n\t                    dy = 0,\n\t                    startEvent;\n\t\n\t                if (this.dragging) {\n\t                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n\t                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n\t                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n\t                }\n\t                else {\n\t                    pointerSpeed = this.pointerDelta.client.speed;\n\t                }\n\t\n\t                // check if inertia should be started\n\t                inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n\t                                   && this.prepared.name !== 'gesture'\n\t                                   && event !== inertiaStatus.startEvent);\n\t\n\t                inertia = (inertiaPossible\n\t                           && (now - this.curCoords.timeStamp) < 50\n\t                           && pointerSpeed > inertiaOptions.minSpeed\n\t                           && pointerSpeed > inertiaOptions.endSpeed);\n\t\n\t                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\t\n\t                    var snapRestrict = {};\n\t\n\t                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\t\n\t                    if (endSnap) {\n\t                        this.setSnapping(this.curCoords.page, snapRestrict);\n\t                        if (snapRestrict.locked) {\n\t                            dx += snapRestrict.dx;\n\t                            dy += snapRestrict.dy;\n\t                        }\n\t                    }\n\t\n\t                    if (endRestrict) {\n\t                        this.setRestriction(this.curCoords.page, snapRestrict);\n\t                        if (snapRestrict.restricted) {\n\t                            dx += snapRestrict.dx;\n\t                            dy += snapRestrict.dy;\n\t                        }\n\t                    }\n\t\n\t                    if (dx || dy) {\n\t                        smoothEnd = true;\n\t                    }\n\t                }\n\t\n\t                if (inertia || smoothEnd) {\n\t                    copyCoords(inertiaStatus.upCoords, this.curCoords);\n\t\n\t                    this.pointers[0] = inertiaStatus.startEvent = startEvent =\n\t                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\t\n\t                    inertiaStatus.t0 = now;\n\t\n\t                    target.fire(inertiaStatus.startEvent);\n\t\n\t                    if (inertia) {\n\t                        inertiaStatus.vx0 = this.pointerDelta.client.vx;\n\t                        inertiaStatus.vy0 = this.pointerDelta.client.vy;\n\t                        inertiaStatus.v0 = pointerSpeed;\n\t\n\t                        this.calcInertia(inertiaStatus);\n\t\n\t                        var page = extend({}, this.curCoords.page),\n\t                            origin = getOriginXY(target, this.element),\n\t                            statusObject;\n\t\n\t                        page.x = page.x + inertiaStatus.xe - origin.x;\n\t                        page.y = page.y + inertiaStatus.ye - origin.y;\n\t\n\t                        statusObject = {\n\t                            useStatusXY: true,\n\t                            x: page.x,\n\t                            y: page.y,\n\t                            dx: 0,\n\t                            dy: 0,\n\t                            snap: null\n\t                        };\n\t\n\t                        statusObject.snap = statusObject;\n\t\n\t                        dx = dy = 0;\n\t\n\t                        if (endSnap) {\n\t                            var snap = this.setSnapping(this.curCoords.page, statusObject);\n\t\n\t                            if (snap.locked) {\n\t                                dx += snap.dx;\n\t                                dy += snap.dy;\n\t                            }\n\t                        }\n\t\n\t                        if (endRestrict) {\n\t                            var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\t\n\t                            if (restrict.restricted) {\n\t                                dx += restrict.dx;\n\t                                dy += restrict.dy;\n\t                            }\n\t                        }\n\t\n\t                        inertiaStatus.modifiedXe += dx;\n\t                        inertiaStatus.modifiedYe += dy;\n\t\n\t                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t                    }\n\t                    else {\n\t                        inertiaStatus.smoothEnd = true;\n\t                        inertiaStatus.xe = dx;\n\t                        inertiaStatus.ye = dy;\n\t\n\t                        inertiaStatus.sx = inertiaStatus.sy = 0;\n\t\n\t                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t                    }\n\t\n\t                    inertiaStatus.active = true;\n\t                    return;\n\t                }\n\t\n\t                if (endSnap || endRestrict) {\n\t                    // fire a move event at the snapped coordinates\n\t                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n\t                }\n\t            }\n\t\n\t            if (this.dragging) {\n\t                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\t\n\t                var draggableElement = this.element,\n\t                    drop = this.getDrop(endEvent, event, draggableElement);\n\t\n\t                this.dropTarget = drop.dropzone;\n\t                this.dropElement = drop.element;\n\t\n\t                var dropEvents = this.getDropEvents(event, endEvent);\n\t\n\t                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n\t                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n\t                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n\t                if (dropEvents.deactivate) {\n\t                    this.fireActiveDrops(dropEvents.deactivate);\n\t                }\n\t\n\t                target.fire(endEvent);\n\t            }\n\t            else if (this.resizing) {\n\t                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n\t                target.fire(endEvent);\n\t            }\n\t            else if (this.gesturing) {\n\t                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n\t                target.fire(endEvent);\n\t            }\n\t\n\t            this.stop(event);\n\t        },\n\t\n\t        collectDrops: function (element) {\n\t            var drops = [],\n\t                elements = [],\n\t                i;\n\t\n\t            element = element || this.element;\n\t\n\t            // collect all dropzones and their elements which qualify for a drop\n\t            for (i = 0; i < interactables.length; i++) {\n\t                if (!interactables[i].options.drop.enabled) { continue; }\n\t\n\t                var current = interactables[i],\n\t                    accept = current.options.drop.accept;\n\t\n\t                // test the draggable element against the dropzone's accept setting\n\t                if ((isElement(accept) && accept !== element)\n\t                    || (isString(accept)\n\t                        && !matchesSelector(element, accept))) {\n\t\n\t                    continue;\n\t                }\n\t\n\t                // query for new elements if necessary\n\t                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\t\n\t                for (var j = 0, len = dropElements.length; j < len; j++) {\n\t                    var currentElement = dropElements[j];\n\t\n\t                    if (currentElement === element) {\n\t                        continue;\n\t                    }\n\t\n\t                    drops.push(current);\n\t                    elements.push(currentElement);\n\t                }\n\t            }\n\t\n\t            return {\n\t                dropzones: drops,\n\t                elements: elements\n\t            };\n\t        },\n\t\n\t        fireActiveDrops: function (event) {\n\t            var i,\n\t                current,\n\t                currentElement,\n\t                prevElement;\n\t\n\t            // loop through all active dropzones and trigger event\n\t            for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t                current = this.activeDrops.dropzones[i];\n\t                currentElement = this.activeDrops.elements [i];\n\t\n\t                // prevent trigger of duplicate events on same element\n\t                if (currentElement !== prevElement) {\n\t                    // set current element as event target\n\t                    event.target = currentElement;\n\t                    current.fire(event);\n\t                }\n\t                prevElement = currentElement;\n\t            }\n\t        },\n\t\n\t        // Collect a new set of possible drops and save them in activeDrops.\n\t        // setActiveDrops should always be called when a drag has just started or a\n\t        // drag event happens while dynamicDrop is true\n\t        setActiveDrops: function (dragElement) {\n\t            // get dropzones and their elements that could receive the draggable\n\t            var possibleDrops = this.collectDrops(dragElement, true);\n\t\n\t            this.activeDrops.dropzones = possibleDrops.dropzones;\n\t            this.activeDrops.elements  = possibleDrops.elements;\n\t            this.activeDrops.rects     = [];\n\t\n\t            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n\t            }\n\t        },\n\t\n\t        getDrop: function (dragEvent, event, dragElement) {\n\t            var validDrops = [];\n\t\n\t            if (dynamicDrop) {\n\t                this.setActiveDrops(dragElement);\n\t            }\n\t\n\t            // collect all dropzones and their elements which qualify for a drop\n\t            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n\t                var current        = this.activeDrops.dropzones[j],\n\t                    currentElement = this.activeDrops.elements [j],\n\t                    rect           = this.activeDrops.rects    [j];\n\t\n\t                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n\t                                ? currentElement\n\t                                : null);\n\t            }\n\t\n\t            // get the most appropriate dropzone based on DOM depth and order\n\t            var dropIndex = indexOfDeepestElement(validDrops),\n\t                dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n\t                element   = this.activeDrops.elements [dropIndex] || null;\n\t\n\t            return {\n\t                dropzone: dropzone,\n\t                element: element\n\t            };\n\t        },\n\t\n\t        getDropEvents: function (pointerEvent, dragEvent) {\n\t            var dropEvents = {\n\t                enter     : null,\n\t                leave     : null,\n\t                activate  : null,\n\t                deactivate: null,\n\t                move      : null,\n\t                drop      : null\n\t            };\n\t\n\t            if (this.dropElement !== this.prevDropElement) {\n\t                // if there was a prevDropTarget, create a dragleave event\n\t                if (this.prevDropTarget) {\n\t                    dropEvents.leave = {\n\t                        target       : this.prevDropElement,\n\t                        dropzone     : this.prevDropTarget,\n\t                        relatedTarget: dragEvent.target,\n\t                        draggable    : dragEvent.interactable,\n\t                        dragEvent    : dragEvent,\n\t                        interaction  : this,\n\t                        timeStamp    : dragEvent.timeStamp,\n\t                        type         : 'dragleave'\n\t                    };\n\t\n\t                    dragEvent.dragLeave = this.prevDropElement;\n\t                    dragEvent.prevDropzone = this.prevDropTarget;\n\t                }\n\t                // if the dropTarget is not null, create a dragenter event\n\t                if (this.dropTarget) {\n\t                    dropEvents.enter = {\n\t                        target       : this.dropElement,\n\t                        dropzone     : this.dropTarget,\n\t                        relatedTarget: dragEvent.target,\n\t                        draggable    : dragEvent.interactable,\n\t                        dragEvent    : dragEvent,\n\t                        interaction  : this,\n\t                        timeStamp    : dragEvent.timeStamp,\n\t                        type         : 'dragenter'\n\t                    };\n\t\n\t                    dragEvent.dragEnter = this.dropElement;\n\t                    dragEvent.dropzone = this.dropTarget;\n\t                }\n\t            }\n\t\n\t            if (dragEvent.type === 'dragend' && this.dropTarget) {\n\t                dropEvents.drop = {\n\t                    target       : this.dropElement,\n\t                    dropzone     : this.dropTarget,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'drop'\n\t                };\n\t\n\t                dragEvent.dropzone = this.dropTarget;\n\t            }\n\t            if (dragEvent.type === 'dragstart') {\n\t                dropEvents.activate = {\n\t                    target       : null,\n\t                    dropzone     : null,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropactivate'\n\t                };\n\t            }\n\t            if (dragEvent.type === 'dragend') {\n\t                dropEvents.deactivate = {\n\t                    target       : null,\n\t                    dropzone     : null,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropdeactivate'\n\t                };\n\t            }\n\t            if (dragEvent.type === 'dragmove' && this.dropTarget) {\n\t                dropEvents.move = {\n\t                    target       : this.dropElement,\n\t                    dropzone     : this.dropTarget,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    dragmove     : dragEvent,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropmove'\n\t                };\n\t                dragEvent.dropzone = this.dropTarget;\n\t            }\n\t\n\t            return dropEvents;\n\t        },\n\t\n\t        currentAction: function () {\n\t            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n\t        },\n\t\n\t        interacting: function () {\n\t            return this.dragging || this.resizing || this.gesturing;\n\t        },\n\t\n\t        clearTargets: function () {\n\t            this.target = this.element = null;\n\t\n\t            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n\t        },\n\t\n\t        stop: function (event) {\n\t            if (this.interacting()) {\n\t                autoScroll.stop();\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t\n\t                var target = this.target;\n\t\n\t                if (target.options.styleCursor) {\n\t                    target._doc.documentElement.style.cursor = '';\n\t                }\n\t\n\t                // prevent Default only if were previously interacting\n\t                if (event && isFunction(event.preventDefault)) {\n\t                    this.checkAndPreventDefault(event, target, this.element);\n\t                }\n\t\n\t                if (this.dragging) {\n\t                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n\t                }\n\t            }\n\t\n\t            this.clearTargets();\n\t\n\t            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n\t            this.prepared.name = this.prevEvent = null;\n\t            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\t\n\t            // remove pointers if their ID isn't in this.pointerIds\n\t            for (var i = 0; i < this.pointers.length; i++) {\n\t                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n\t                    this.pointers.splice(i, 1);\n\t                }\n\t            }\n\t        },\n\t\n\t        inertiaFrame: function () {\n\t            var inertiaStatus = this.inertiaStatus,\n\t                options = this.target.options[this.prepared.name].inertia,\n\t                lambda = options.resistance,\n\t                t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\t\n\t            if (t < inertiaStatus.te) {\n\t\n\t                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\t\n\t                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n\t                    inertiaStatus.sx = inertiaStatus.xe * progress;\n\t                    inertiaStatus.sy = inertiaStatus.ye * progress;\n\t                }\n\t                else {\n\t                    var quadPoint = getQuadraticCurvePoint(\n\t                            0, 0,\n\t                            inertiaStatus.xe, inertiaStatus.ye,\n\t                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n\t                            progress);\n\t\n\t                    inertiaStatus.sx = quadPoint.x;\n\t                    inertiaStatus.sy = quadPoint.y;\n\t                }\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t            }\n\t            else {\n\t                inertiaStatus.ending = true;\n\t\n\t                inertiaStatus.sx = inertiaStatus.modifiedXe;\n\t                inertiaStatus.sy = inertiaStatus.modifiedYe;\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.active = inertiaStatus.ending = false;\n\t            }\n\t        },\n\t\n\t        smoothEndFrame: function () {\n\t            var inertiaStatus = this.inertiaStatus,\n\t                t = new Date().getTime() - inertiaStatus.t0,\n\t                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\t\n\t            if (t < duration) {\n\t                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n\t                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t            }\n\t            else {\n\t                inertiaStatus.ending = true;\n\t\n\t                inertiaStatus.sx = inertiaStatus.xe;\n\t                inertiaStatus.sy = inertiaStatus.ye;\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.smoothEnd =\n\t                  inertiaStatus.active = inertiaStatus.ending = false;\n\t            }\n\t        },\n\t\n\t        addPointer: function (pointer) {\n\t            var id = getPointerId(pointer),\n\t                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\t\n\t            if (index === -1) {\n\t                index = this.pointerIds.length;\n\t            }\n\t\n\t            this.pointerIds[index] = id;\n\t            this.pointers[index] = pointer;\n\t\n\t            return index;\n\t        },\n\t\n\t        removePointer: function (pointer) {\n\t            var id = getPointerId(pointer),\n\t                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\t\n\t            if (index === -1) { return; }\n\t\n\t            this.pointers   .splice(index, 1);\n\t            this.pointerIds .splice(index, 1);\n\t            this.downTargets.splice(index, 1);\n\t            this.downTimes  .splice(index, 1);\n\t            this.holdTimers .splice(index, 1);\n\t        },\n\t\n\t        recordPointer: function (pointer) {\n\t            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            if (index === -1) { return; }\n\t\n\t            this.pointers[index] = pointer;\n\t        },\n\t\n\t        collectEventTargets: function (pointer, event, eventTarget, eventType) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            // do not fire a tap event if the pointer was moved before being lifted\n\t            if (eventType === 'tap' && (this.pointerWasMoved\n\t                // or if the pointerup target is different to the pointerdown target\n\t                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n\t                return;\n\t            }\n\t\n\t            var targets = [],\n\t                elements = [],\n\t                element = eventTarget;\n\t\n\t            function collectSelectors (interactable, selector, context) {\n\t                var els = ie8MatchesSelector\n\t                        ? context.querySelectorAll(selector)\n\t                        : undefined;\n\t\n\t                if (interactable._iEvents[eventType]\n\t                    && isElement(element)\n\t                    && inContext(interactable, element)\n\t                    && !testIgnore(interactable, element, eventTarget)\n\t                    && testAllow(interactable, element, eventTarget)\n\t                    && matchesSelector(element, selector, els)) {\n\t\n\t                    targets.push(interactable);\n\t                    elements.push(element);\n\t                }\n\t            }\n\t\n\t            while (element) {\n\t                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n\t                    targets.push(interact(element));\n\t                    elements.push(element);\n\t                }\n\t\n\t                interactables.forEachSelector(collectSelectors);\n\t\n\t                element = parentElement(element);\n\t            }\n\t\n\t            // create the tap event even if there are no listeners so that\n\t            // doubletap can still be created and fired\n\t            if (targets.length || eventType === 'tap') {\n\t                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n\t            }\n\t        },\n\t\n\t        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n\t                pointerEvent = {},\n\t                i,\n\t                // for tap events\n\t                interval, createNewDoubleTap;\n\t\n\t            // if it's a doubletap then the event properties would have been\n\t            // copied from the tap event and provided as the pointer argument\n\t            if (eventType === 'doubletap') {\n\t                pointerEvent = pointer;\n\t            }\n\t            else {\n\t                pointerExtend(pointerEvent, event);\n\t                if (event !== pointer) {\n\t                    pointerExtend(pointerEvent, pointer);\n\t                }\n\t\n\t                pointerEvent.preventDefault           = preventOriginalDefault;\n\t                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n\t                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n\t                pointerEvent.interaction              = this;\n\t\n\t                pointerEvent.timeStamp       = new Date().getTime();\n\t                pointerEvent.originalEvent   = event;\n\t                pointerEvent.originalPointer = pointer;\n\t                pointerEvent.type            = eventType;\n\t                pointerEvent.pointerId       = getPointerId(pointer);\n\t                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n\t                                                    : isString(pointer.pointerType)\n\t                                                        ? pointer.pointerType\n\t                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n\t            }\n\t\n\t            if (eventType === 'tap') {\n\t                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\t\n\t                interval = pointerEvent.timeStamp - this.tapTime;\n\t                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n\t                       && this.prevTap.target === pointerEvent.target\n\t                       && interval < 500);\n\t\n\t                pointerEvent.double = createNewDoubleTap;\n\t\n\t                this.tapTime = pointerEvent.timeStamp;\n\t            }\n\t\n\t            for (i = 0; i < targets.length; i++) {\n\t                pointerEvent.currentTarget = elements[i];\n\t                pointerEvent.interactable = targets[i];\n\t                targets[i].fire(pointerEvent);\n\t\n\t                if (pointerEvent.immediatePropagationStopped\n\t                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (createNewDoubleTap) {\n\t                var doubleTap = {};\n\t\n\t                extend(doubleTap, pointerEvent);\n\t\n\t                doubleTap.dt   = interval;\n\t                doubleTap.type = 'doubletap';\n\t\n\t                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\t\n\t                this.prevTap = doubleTap;\n\t            }\n\t            else if (eventType === 'tap') {\n\t                this.prevTap = pointerEvent;\n\t            }\n\t        },\n\t\n\t        validateSelector: function (pointer, event, matches, matchElements) {\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var match = matches[i],\n\t                    matchElement = matchElements[i],\n\t                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\t\n\t                if (action && withinInteractionLimit(match, matchElement, action)) {\n\t                    this.target = match;\n\t                    this.element = matchElement;\n\t\n\t                    return action;\n\t                }\n\t            }\n\t        },\n\t\n\t        setSnapping: function (pageCoords, status) {\n\t            var snap = this.target.options[this.prepared.name].snap,\n\t                targets = [],\n\t                target,\n\t                page,\n\t                i;\n\t\n\t            status = status || this.snapStatus;\n\t\n\t            if (status.useStatusXY) {\n\t                page = { x: status.x, y: status.y };\n\t            }\n\t            else {\n\t                var origin = getOriginXY(this.target, this.element);\n\t\n\t                page = extend({}, pageCoords);\n\t\n\t                page.x -= origin.x;\n\t                page.y -= origin.y;\n\t            }\n\t\n\t            status.realX = page.x;\n\t            status.realY = page.y;\n\t\n\t            page.x = page.x - this.inertiaStatus.resumeDx;\n\t            page.y = page.y - this.inertiaStatus.resumeDy;\n\t\n\t            var len = snap.targets? snap.targets.length : 0;\n\t\n\t            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n\t                var relative = {\n\t                    x: page.x - this.snapOffsets[relIndex].x,\n\t                    y: page.y - this.snapOffsets[relIndex].y\n\t                };\n\t\n\t                for (i = 0; i < len; i++) {\n\t                    if (isFunction(snap.targets[i])) {\n\t                        target = snap.targets[i](relative.x, relative.y, this);\n\t                    }\n\t                    else {\n\t                        target = snap.targets[i];\n\t                    }\n\t\n\t                    if (!target) { continue; }\n\t\n\t                    targets.push({\n\t                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n\t                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\t\n\t                        range: isNumber(target.range)? target.range: snap.range\n\t                    });\n\t                }\n\t            }\n\t\n\t            var closest = {\n\t                    target: null,\n\t                    inRange: false,\n\t                    distance: 0,\n\t                    range: 0,\n\t                    dx: 0,\n\t                    dy: 0\n\t                };\n\t\n\t            for (i = 0, len = targets.length; i < len; i++) {\n\t                target = targets[i];\n\t\n\t                var range = target.range,\n\t                    dx = target.x - page.x,\n\t                    dy = target.y - page.y,\n\t                    distance = hypot(dx, dy),\n\t                    inRange = distance <= range;\n\t\n\t                // Infinite targets count as being out of range\n\t                // compared to non infinite ones that are in range\n\t                if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n\t                    inRange = false;\n\t                }\n\t\n\t                if (!closest.target || (inRange\n\t                    // is the closest target in range?\n\t                    ? (closest.inRange && range !== Infinity\n\t                        // the pointer is relatively deeper in this target\n\t                        ? distance / range < closest.distance / closest.range\n\t                        // this target has Infinite range and the closest doesn't\n\t                        : (range === Infinity && closest.range !== Infinity)\n\t                            // OR this target is closer that the previous closest\n\t                            || distance < closest.distance)\n\t                    // The other is not in range and the pointer is closer to this target\n\t                    : (!closest.inRange && distance < closest.distance))) {\n\t\n\t                    if (range === Infinity) {\n\t                        inRange = true;\n\t                    }\n\t\n\t                    closest.target = target;\n\t                    closest.distance = distance;\n\t                    closest.range = range;\n\t                    closest.inRange = inRange;\n\t                    closest.dx = dx;\n\t                    closest.dy = dy;\n\t\n\t                    status.range = range;\n\t                }\n\t            }\n\t\n\t            var snapChanged;\n\t\n\t            if (closest.target) {\n\t                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\t\n\t                status.snappedX = closest.target.x;\n\t                status.snappedY = closest.target.y;\n\t            }\n\t            else {\n\t                snapChanged = true;\n\t\n\t                status.snappedX = NaN;\n\t                status.snappedY = NaN;\n\t            }\n\t\n\t            status.dx = closest.dx;\n\t            status.dy = closest.dy;\n\t\n\t            status.changed = (snapChanged || (closest.inRange && !status.locked));\n\t            status.locked = closest.inRange;\n\t\n\t            return status;\n\t        },\n\t\n\t        setRestriction: function (pageCoords, status) {\n\t            var target = this.target,\n\t                restrict = target && target.options[this.prepared.name].restrict,\n\t                restriction = restrict && restrict.restriction,\n\t                page;\n\t\n\t            if (!restriction) {\n\t                return status;\n\t            }\n\t\n\t            status = status || this.restrictStatus;\n\t\n\t            page = status.useStatusXY\n\t                    ? page = { x: status.x, y: status.y }\n\t                    : page = extend({}, pageCoords);\n\t\n\t            if (status.snap && status.snap.locked) {\n\t                page.x += status.snap.dx || 0;\n\t                page.y += status.snap.dy || 0;\n\t            }\n\t\n\t            page.x -= this.inertiaStatus.resumeDx;\n\t            page.y -= this.inertiaStatus.resumeDy;\n\t\n\t            status.dx = 0;\n\t            status.dy = 0;\n\t            status.restricted = false;\n\t\n\t            var rect, restrictedX, restrictedY;\n\t\n\t            if (isString(restriction)) {\n\t                if (restriction === 'parent') {\n\t                    restriction = parentElement(this.element);\n\t                }\n\t                else if (restriction === 'self') {\n\t                    restriction = target.getRect(this.element);\n\t                }\n\t                else {\n\t                    restriction = closest(this.element, restriction);\n\t                }\n\t\n\t                if (!restriction) { return status; }\n\t            }\n\t\n\t            if (isFunction(restriction)) {\n\t                restriction = restriction(page.x, page.y, this.element);\n\t            }\n\t\n\t            if (isElement(restriction)) {\n\t                restriction = getElementRect(restriction);\n\t            }\n\t\n\t            rect = restriction;\n\t\n\t            if (!restriction) {\n\t                restrictedX = page.x;\n\t                restrictedY = page.y;\n\t            }\n\t            // object is assumed to have\n\t            // x, y, width, height or\n\t            // left, top, right, bottom\n\t            else if ('x' in restriction && 'y' in restriction) {\n\t                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n\t                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n\t            }\n\t            else {\n\t                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n\t                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n\t            }\n\t\n\t            status.dx = restrictedX - page.x;\n\t            status.dy = restrictedY - page.y;\n\t\n\t            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n\t            status.restricted = !!(status.dx || status.dy);\n\t\n\t            status.restrictedX = restrictedX;\n\t            status.restrictedY = restrictedY;\n\t\n\t            return status;\n\t        },\n\t\n\t        checkAndPreventDefault: function (event, interactable, element) {\n\t            if (!(interactable = interactable || this.target)) { return; }\n\t\n\t            var options = interactable.options,\n\t                prevent = options.preventDefault;\n\t\n\t            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n\t                // do not preventDefault on pointerdown if the prepared action is a drag\n\t                // and dragging can only start from a certain direction - this allows\n\t                // a touch to pan the viewport if a drag isn't in the right direction\n\t                if (/down|start/i.test(event.type)\n\t                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\t\n\t                    return;\n\t                }\n\t\n\t                // with manualStart, only preventDefault while interacting\n\t                if (options[this.prepared.name] && options[this.prepared.name].manualStart\n\t                    && !this.interacting()) {\n\t                    return;\n\t                }\n\t\n\t                event.preventDefault();\n\t                return;\n\t            }\n\t\n\t            if (prevent === 'always') {\n\t                event.preventDefault();\n\t                return;\n\t            }\n\t        },\n\t\n\t        calcInertia: function (status) {\n\t            var inertiaOptions = this.target.options[this.prepared.name].inertia,\n\t                lambda = inertiaOptions.resistance,\n\t                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\t\n\t            status.x0 = this.prevEvent.pageX;\n\t            status.y0 = this.prevEvent.pageY;\n\t            status.t0 = status.startEvent.timeStamp / 1000;\n\t            status.sx = status.sy = 0;\n\t\n\t            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n\t            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n\t            status.te = inertiaDur;\n\t\n\t            status.lambda_v0 = lambda / status.v0;\n\t            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n\t        },\n\t\n\t        autoScrollMove: function (pointer) {\n\t            if (!(this.interacting()\n\t                && checkAutoScroll(this.target, this.prepared.name))) {\n\t                return;\n\t            }\n\t\n\t            if (this.inertiaStatus.active) {\n\t                autoScroll.x = autoScroll.y = 0;\n\t                return;\n\t            }\n\t\n\t            var top,\n\t                right,\n\t                bottom,\n\t                left,\n\t                options = this.target.options[this.prepared.name].autoScroll,\n\t                container = options.container || getWindow(this.element);\n\t\n\t            if (isWindow(container)) {\n\t                left   = pointer.clientX < autoScroll.margin;\n\t                top    = pointer.clientY < autoScroll.margin;\n\t                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n\t                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n\t            }\n\t            else {\n\t                var rect = getElementClientRect(container);\n\t\n\t                left   = pointer.clientX < rect.left   + autoScroll.margin;\n\t                top    = pointer.clientY < rect.top    + autoScroll.margin;\n\t                right  = pointer.clientX > rect.right  - autoScroll.margin;\n\t                bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n\t            }\n\t\n\t            autoScroll.x = (right ? 1: left? -1: 0);\n\t            autoScroll.y = (bottom? 1:  top? -1: 0);\n\t\n\t            if (!autoScroll.isScrolling) {\n\t                // set the autoScroll properties to those of the target\n\t                autoScroll.margin = options.margin;\n\t                autoScroll.speed  = options.speed;\n\t\n\t                autoScroll.start(this);\n\t            }\n\t        },\n\t\n\t        _updateEventTargets: function (target, currentTarget) {\n\t            this._eventTarget    = target;\n\t            this._curEventTarget = currentTarget;\n\t        }\n\t\n\t    };\n\t\n\t    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n\t        var i = 0, len = interactions.length,\n\t            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n\t                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n\t                          || pointer.pointerType === 4),\n\t            interaction;\n\t\n\t        var id = getPointerId(pointer);\n\t\n\t        // try to resume inertia with a new pointer\n\t        if (/down|start/i.test(eventType)) {\n\t            for (i = 0; i < len; i++) {\n\t                interaction = interactions[i];\n\t\n\t                var element = eventTarget;\n\t\n\t                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n\t                    && (interaction.mouse === mouseEvent)) {\n\t                    while (element) {\n\t                        // if the element is the interaction element\n\t                        if (element === interaction.element) {\n\t                            return interaction;\n\t                        }\n\t                        element = parentElement(element);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // if it's a mouse interaction\n\t        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\t\n\t            // find a mouse interaction that's not in inertia phase\n\t            for (i = 0; i < len; i++) {\n\t                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n\t                    return interactions[i];\n\t                }\n\t            }\n\t\n\t            // find any interaction specifically for mouse.\n\t            // if the eventType is a mousedown, and inertia is active\n\t            // ignore the interaction\n\t            for (i = 0; i < len; i++) {\n\t                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n\t                    return interaction;\n\t                }\n\t            }\n\t\n\t            // create a new interaction for mouse\n\t            interaction = new Interaction();\n\t            interaction.mouse = true;\n\t\n\t            return interaction;\n\t        }\n\t\n\t        // get interaction that has this pointer\n\t        for (i = 0; i < len; i++) {\n\t            if (contains(interactions[i].pointerIds, id)) {\n\t                return interactions[i];\n\t            }\n\t        }\n\t\n\t        // at this stage, a pointerUp should not return an interaction\n\t        if (/up|end|out/i.test(eventType)) {\n\t            return null;\n\t        }\n\t\n\t        // get first idle interaction\n\t        for (i = 0; i < len; i++) {\n\t            interaction = interactions[i];\n\t\n\t            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n\t                && !interaction.interacting()\n\t                && !(!mouseEvent && interaction.mouse)) {\n\t\n\t                return interaction;\n\t            }\n\t        }\n\t\n\t        return new Interaction();\n\t    }\n\t\n\t    function doOnInteractions (method) {\n\t        return (function (event) {\n\t            var interaction,\n\t                eventTarget = getActualElement(event.path\n\t                                               ? event.path[0]\n\t                                               : event.target),\n\t                curEventTarget = getActualElement(event.currentTarget),\n\t                i;\n\t\n\t            if (supportsTouch && /touch/.test(event.type)) {\n\t                prevTouchTime = new Date().getTime();\n\t\n\t                for (i = 0; i < event.changedTouches.length; i++) {\n\t                    var pointer = event.changedTouches[i];\n\t\n\t                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\t\n\t                    if (!interaction) { continue; }\n\t\n\t                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t                    interaction[method](pointer, event, eventTarget, curEventTarget);\n\t                }\n\t            }\n\t            else {\n\t                if (!supportsPointerEvent && /mouse/.test(event.type)) {\n\t                    // ignore mouse events while touch interactions are active\n\t                    for (i = 0; i < interactions.length; i++) {\n\t                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n\t                            return;\n\t                        }\n\t                    }\n\t\n\t                    // try to ignore mouse events that are simulated by the browser\n\t                    // after a touch event\n\t                    if (new Date().getTime() - prevTouchTime < 500) {\n\t                        return;\n\t                    }\n\t                }\n\t\n\t                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\t\n\t                if (!interaction) { return; }\n\t\n\t                interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t                interaction[method](event, event, eventTarget, curEventTarget);\n\t            }\n\t        });\n\t    }\n\t\n\t    function InteractEvent (interaction, event, action, phase, element, related) {\n\t        var client,\n\t            page,\n\t            target      = interaction.target,\n\t            snapStatus  = interaction.snapStatus,\n\t            restrictStatus  = interaction.restrictStatus,\n\t            pointers    = interaction.pointers,\n\t            deltaSource = (target && target.options || defaultOptions).deltaSource,\n\t            sourceX     = deltaSource + 'X',\n\t            sourceY     = deltaSource + 'Y',\n\t            options     = target? target.options: defaultOptions,\n\t            origin      = getOriginXY(target, element),\n\t            starting    = phase === 'start',\n\t            ending      = phase === 'end',\n\t            coords      = starting? interaction.startCoords : interaction.curCoords;\n\t\n\t        element = element || interaction.element;\n\t\n\t        page   = extend({}, coords.page);\n\t        client = extend({}, coords.client);\n\t\n\t        page.x -= origin.x;\n\t        page.y -= origin.y;\n\t\n\t        client.x -= origin.x;\n\t        client.y -= origin.y;\n\t\n\t        var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\t\n\t        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n\t            this.snap = {\n\t                range  : snapStatus.range,\n\t                locked : snapStatus.locked,\n\t                x      : snapStatus.snappedX,\n\t                y      : snapStatus.snappedY,\n\t                realX  : snapStatus.realX,\n\t                realY  : snapStatus.realY,\n\t                dx     : snapStatus.dx,\n\t                dy     : snapStatus.dy\n\t            };\n\t\n\t            if (snapStatus.locked) {\n\t                page.x += snapStatus.dx;\n\t                page.y += snapStatus.dy;\n\t                client.x += snapStatus.dx;\n\t                client.y += snapStatus.dy;\n\t            }\n\t        }\n\t\n\t        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n\t            page.x += restrictStatus.dx;\n\t            page.y += restrictStatus.dy;\n\t            client.x += restrictStatus.dx;\n\t            client.y += restrictStatus.dy;\n\t\n\t            this.restrict = {\n\t                dx: restrictStatus.dx,\n\t                dy: restrictStatus.dy\n\t            };\n\t        }\n\t\n\t        this.pageX     = page.x;\n\t        this.pageY     = page.y;\n\t        this.clientX   = client.x;\n\t        this.clientY   = client.y;\n\t\n\t        this.x0        = interaction.startCoords.page.x - origin.x;\n\t        this.y0        = interaction.startCoords.page.y - origin.y;\n\t        this.clientX0  = interaction.startCoords.client.x - origin.x;\n\t        this.clientY0  = interaction.startCoords.client.y - origin.y;\n\t        this.ctrlKey   = event.ctrlKey;\n\t        this.altKey    = event.altKey;\n\t        this.shiftKey  = event.shiftKey;\n\t        this.metaKey   = event.metaKey;\n\t        this.button    = event.button;\n\t        this.buttons   = event.buttons;\n\t        this.target    = element;\n\t        this.t0        = interaction.downTimes[0];\n\t        this.type      = action + (phase || '');\n\t\n\t        this.interaction = interaction;\n\t        this.interactable = target;\n\t\n\t        var inertiaStatus = interaction.inertiaStatus;\n\t\n\t        if (inertiaStatus.active) {\n\t            this.detail = 'inertia';\n\t        }\n\t\n\t        if (related) {\n\t            this.relatedTarget = related;\n\t        }\n\t\n\t        // end event dx, dy is difference between start and end points\n\t        if (ending) {\n\t            if (deltaSource === 'client') {\n\t                this.dx = client.x - interaction.startCoords.client.x;\n\t                this.dy = client.y - interaction.startCoords.client.y;\n\t            }\n\t            else {\n\t                this.dx = page.x - interaction.startCoords.page.x;\n\t                this.dy = page.y - interaction.startCoords.page.y;\n\t            }\n\t        }\n\t        else if (starting) {\n\t            this.dx = 0;\n\t            this.dy = 0;\n\t        }\n\t        // copy properties from previousmove if starting inertia\n\t        else if (phase === 'inertiastart') {\n\t            this.dx = interaction.prevEvent.dx;\n\t            this.dy = interaction.prevEvent.dy;\n\t        }\n\t        else {\n\t            if (deltaSource === 'client') {\n\t                this.dx = client.x - interaction.prevEvent.clientX;\n\t                this.dy = client.y - interaction.prevEvent.clientY;\n\t            }\n\t            else {\n\t                this.dx = page.x - interaction.prevEvent.pageX;\n\t                this.dy = page.y - interaction.prevEvent.pageY;\n\t            }\n\t        }\n\t        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n\t            && !inertiaStatus.active\n\t            && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\t\n\t            inertiaStatus.resumeDx += this.dx;\n\t            inertiaStatus.resumeDy += this.dy;\n\t\n\t            this.dx = this.dy = 0;\n\t        }\n\t\n\t        if (action === 'resize' && interaction.resizeAxes) {\n\t            if (options.resize.square) {\n\t                if (interaction.resizeAxes === 'y') {\n\t                    this.dx = this.dy;\n\t                }\n\t                else {\n\t                    this.dy = this.dx;\n\t                }\n\t                this.axes = 'xy';\n\t            }\n\t            else {\n\t                this.axes = interaction.resizeAxes;\n\t\n\t                if (interaction.resizeAxes === 'x') {\n\t                    this.dy = 0;\n\t                }\n\t                else if (interaction.resizeAxes === 'y') {\n\t                    this.dx = 0;\n\t                }\n\t            }\n\t        }\n\t        else if (action === 'gesture') {\n\t            this.touches = [pointers[0], pointers[1]];\n\t\n\t            if (starting) {\n\t                this.distance = touchDistance(pointers, deltaSource);\n\t                this.box      = touchBBox(pointers);\n\t                this.scale    = 1;\n\t                this.ds       = 0;\n\t                this.angle    = touchAngle(pointers, undefined, deltaSource);\n\t                this.da       = 0;\n\t            }\n\t            else if (ending || event instanceof InteractEvent) {\n\t                this.distance = interaction.prevEvent.distance;\n\t                this.box      = interaction.prevEvent.box;\n\t                this.scale    = interaction.prevEvent.scale;\n\t                this.ds       = this.scale - 1;\n\t                this.angle    = interaction.prevEvent.angle;\n\t                this.da       = this.angle - interaction.gesture.startAngle;\n\t            }\n\t            else {\n\t                this.distance = touchDistance(pointers, deltaSource);\n\t                this.box      = touchBBox(pointers);\n\t                this.scale    = this.distance / interaction.gesture.startDistance;\n\t                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\t\n\t                this.ds = this.scale - interaction.gesture.prevScale;\n\t                this.da = this.angle - interaction.gesture.prevAngle;\n\t            }\n\t        }\n\t\n\t        if (starting) {\n\t            this.timeStamp = interaction.downTimes[0];\n\t            this.dt        = 0;\n\t            this.duration  = 0;\n\t            this.speed     = 0;\n\t            this.velocityX = 0;\n\t            this.velocityY = 0;\n\t        }\n\t        else if (phase === 'inertiastart') {\n\t            this.timeStamp = interaction.prevEvent.timeStamp;\n\t            this.dt        = interaction.prevEvent.dt;\n\t            this.duration  = interaction.prevEvent.duration;\n\t            this.speed     = interaction.prevEvent.speed;\n\t            this.velocityX = interaction.prevEvent.velocityX;\n\t            this.velocityY = interaction.prevEvent.velocityY;\n\t        }\n\t        else {\n\t            this.timeStamp = new Date().getTime();\n\t            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n\t            this.duration  = this.timeStamp - interaction.downTimes[0];\n\t\n\t            if (event instanceof InteractEvent) {\n\t                var dx = this[sourceX] - interaction.prevEvent[sourceX],\n\t                    dy = this[sourceY] - interaction.prevEvent[sourceY],\n\t                    dt = this.dt / 1000;\n\t\n\t                this.speed = hypot(dx, dy) / dt;\n\t                this.velocityX = dx / dt;\n\t                this.velocityY = dy / dt;\n\t            }\n\t            // if normal move or end event, use previous user event coords\n\t            else {\n\t                // speed and velocity in pixels per second\n\t                this.speed = interaction.pointerDelta[deltaSource].speed;\n\t                this.velocityX = interaction.pointerDelta[deltaSource].vx;\n\t                this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\t            }\n\t        }\n\t\n\t        if ((ending || phase === 'inertiastart')\n\t            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\t\n\t            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n\t                overlap = 22.5;\n\t\n\t            if (angle < 0) {\n\t                angle += 360;\n\t            }\n\t\n\t            var left = 135 - overlap <= angle && angle < 225 + overlap,\n\t                up   = 225 - overlap <= angle && angle < 315 + overlap,\n\t\n\t                right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n\t                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\t\n\t            this.swipe = {\n\t                up   : up,\n\t                down : down,\n\t                left : left,\n\t                right: right,\n\t                angle: angle,\n\t                speed: interaction.prevEvent.speed,\n\t                velocity: {\n\t                    x: interaction.prevEvent.velocityX,\n\t                    y: interaction.prevEvent.velocityY\n\t                }\n\t            };\n\t        }\n\t    }\n\t\n\t    InteractEvent.prototype = {\n\t        preventDefault: blank,\n\t        stopImmediatePropagation: function () {\n\t            this.immediatePropagationStopped = this.propagationStopped = true;\n\t        },\n\t        stopPropagation: function () {\n\t            this.propagationStopped = true;\n\t        }\n\t    };\n\t\n\t    function preventOriginalDefault () {\n\t        this.originalEvent.preventDefault();\n\t    }\n\t\n\t    function getActionCursor (action) {\n\t        var cursor = '';\n\t\n\t        if (action.name === 'drag') {\n\t            cursor =  actionCursors.drag;\n\t        }\n\t        if (action.name === 'resize') {\n\t            if (action.axis) {\n\t                cursor =  actionCursors[action.name + action.axis];\n\t            }\n\t            else if (action.edges) {\n\t                var cursorKey = 'resize',\n\t                    edgeNames = ['top', 'bottom', 'left', 'right'];\n\t\n\t                for (var i = 0; i < 4; i++) {\n\t                    if (action.edges[edgeNames[i]]) {\n\t                        cursorKey += edgeNames[i];\n\t                    }\n\t                }\n\t\n\t                cursor = actionCursors[cursorKey];\n\t            }\n\t        }\n\t\n\t        return cursor;\n\t    }\n\t\n\t    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n\t        // false, '', undefined, null\n\t        if (!value) { return false; }\n\t\n\t        // true value, use pointer coords and element rect\n\t        if (value === true) {\n\t            // if dimensions are negative, \"switch\" edges\n\t            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n\t                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\t\n\t            if (width < 0) {\n\t                if      (name === 'left' ) { name = 'right'; }\n\t                else if (name === 'right') { name = 'left' ; }\n\t            }\n\t            if (height < 0) {\n\t                if      (name === 'top'   ) { name = 'bottom'; }\n\t                else if (name === 'bottom') { name = 'top'   ; }\n\t            }\n\t\n\t            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n\t            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\t\n\t            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n\t            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n\t        }\n\t\n\t        // the remaining checks require an element\n\t        if (!isElement(element)) { return false; }\n\t\n\t        return isElement(value)\n\t                    // the value is an element to use as a resize handle\n\t                    ? value === element\n\t                    // otherwise check if element matches value as selector\n\t                    : matchesUpTo(element, value, interactableElement);\n\t    }\n\t\n\t    function defaultActionChecker (pointer, interaction, element) {\n\t        var rect = this.getRect(element),\n\t            shouldResize = false,\n\t            action = null,\n\t            resizeAxes = null,\n\t            resizeEdges,\n\t            page = extend({}, interaction.curCoords.page),\n\t            options = this.options;\n\t\n\t        if (!rect) { return null; }\n\t\n\t        if (actionIsEnabled.resize && options.resize.enabled) {\n\t            var resizeOptions = options.resize;\n\t\n\t            resizeEdges = {\n\t                left: false, right: false, top: false, bottom: false\n\t            };\n\t\n\t            // if using resize.edges\n\t            if (isObject(resizeOptions.edges)) {\n\t                for (var edge in resizeEdges) {\n\t                    resizeEdges[edge] = checkResizeEdge(edge,\n\t                                                        resizeOptions.edges[edge],\n\t                                                        page,\n\t                                                        interaction._eventTarget,\n\t                                                        element,\n\t                                                        rect,\n\t                                                        resizeOptions.margin || margin);\n\t                }\n\t\n\t                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n\t                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\t\n\t                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n\t            }\n\t            else {\n\t                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n\t                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\t\n\t                shouldResize = right || bottom;\n\t                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n\t            }\n\t        }\n\t\n\t        action = shouldResize\n\t            ? 'resize'\n\t            : actionIsEnabled.drag && options.drag.enabled\n\t                ? 'drag'\n\t                : null;\n\t\n\t        if (actionIsEnabled.gesture\n\t            && interaction.pointerIds.length >=2\n\t            && !(interaction.dragging || interaction.resizing)) {\n\t            action = 'gesture';\n\t        }\n\t\n\t        if (action) {\n\t            return {\n\t                name: action,\n\t                axis: resizeAxes,\n\t                edges: resizeEdges\n\t            };\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    // Check if action is enabled globally and the current target supports it\n\t    // If so, return the validated action. Otherwise, return null\n\t    function validateAction (action, interactable) {\n\t        if (!isObject(action)) { return null; }\n\t\n\t        var actionName = action.name,\n\t            options = interactable.options;\n\t\n\t        if ((  (actionName  === 'resize'   && options.resize.enabled )\n\t            || (actionName      === 'drag'     && options.drag.enabled  )\n\t            || (actionName      === 'gesture'  && options.gesture.enabled))\n\t            && actionIsEnabled[actionName]) {\n\t\n\t            if (actionName === 'resize' || actionName === 'resizeyx') {\n\t                actionName = 'resizexy';\n\t            }\n\t\n\t            return action;\n\t        }\n\t        return null;\n\t    }\n\t\n\t    var listeners = {},\n\t        interactionListeners = [\n\t            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n\t            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n\t            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n\t            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n\t        ];\n\t\n\t    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n\t        var name = interactionListeners[i];\n\t\n\t        listeners[name] = doOnInteractions(name);\n\t    }\n\t\n\t    // bound to the interactable context when a DOM event\n\t    // listener is added to a selector interactable\n\t    function delegateListener (event, useCapture) {\n\t        var fakeEvent = {},\n\t            delegated = delegatedEvents[event.type],\n\t            eventTarget = getActualElement(event.path\n\t                                           ? event.path[0]\n\t                                           : event.target),\n\t            element = eventTarget;\n\t\n\t        useCapture = useCapture? true: false;\n\t\n\t        // duplicate the event so that currentTarget can be changed\n\t        for (var prop in event) {\n\t            fakeEvent[prop] = event[prop];\n\t        }\n\t\n\t        fakeEvent.originalEvent = event;\n\t        fakeEvent.preventDefault = preventOriginalDefault;\n\t\n\t        // climb up document tree looking for selector matches\n\t        while (isElement(element)) {\n\t            for (var i = 0; i < delegated.selectors.length; i++) {\n\t                var selector = delegated.selectors[i],\n\t                    context = delegated.contexts[i];\n\t\n\t                if (matchesSelector(element, selector)\n\t                    && nodeContains(context, eventTarget)\n\t                    && nodeContains(context, element)) {\n\t\n\t                    var listeners = delegated.listeners[i];\n\t\n\t                    fakeEvent.currentTarget = element;\n\t\n\t                    for (var j = 0; j < listeners.length; j++) {\n\t                        if (listeners[j][1] === useCapture) {\n\t                            listeners[j][0](fakeEvent);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t\n\t            element = parentElement(element);\n\t        }\n\t    }\n\t\n\t    function delegateUseCapture (event) {\n\t        return delegateListener.call(this, event, true);\n\t    }\n\t\n\t    interactables.indexOfElement = function indexOfElement (element, context) {\n\t        context = context || document;\n\t\n\t        for (var i = 0; i < this.length; i++) {\n\t            var interactable = this[i];\n\t\n\t            if ((interactable.selector === element\n\t                && (interactable._context === context))\n\t                || (!interactable.selector && interactable._element === element)) {\n\t\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    interactables.get = function interactableGet (element, options) {\n\t        return this[this.indexOfElement(element, options && options.context)];\n\t    };\n\t\n\t    interactables.forEachSelector = function (callback) {\n\t        for (var i = 0; i < this.length; i++) {\n\t            var interactable = this[i];\n\t\n\t            if (!interactable.selector) {\n\t                continue;\n\t            }\n\t\n\t            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\t\n\t            if (ret !== undefined) {\n\t                return ret;\n\t            }\n\t        }\n\t    };\n\t\n\t    /*\\\n\t     * interact\n\t     [ method ]\n\t     *\n\t     * The methods of this variable can be used to set elements as\n\t     * interactables and also to change various default settings.\n\t     *\n\t     * Calling it as a function and passing an element or a valid CSS selector\n\t     * string returns an Interactable object which has various methods to\n\t     * configure it.\n\t     *\n\t     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n\t     = (object) An @Interactable\n\t     *\n\t     > Usage\n\t     | interact(document.getElementById('draggable')).draggable(true);\n\t     |\n\t     | var rectables = interact('rect');\n\t     | rectables\n\t     |     .gesturable(true)\n\t     |     .on('gesturemove', function (event) {\n\t     |         // something cool...\n\t     |     })\n\t     |     .autoScroll(true);\n\t    \\*/\n\t    function interact (element, options) {\n\t        return interactables.get(element, options) || new Interactable(element, options);\n\t    }\n\t\n\t    /*\\\n\t     * Interactable\n\t     [ property ]\n\t     **\n\t     * Object type returned by @interact\n\t    \\*/\n\t    function Interactable (element, options) {\n\t        this._element = element;\n\t        this._iEvents = this._iEvents || {};\n\t\n\t        var _window;\n\t\n\t        if (trySelector(element)) {\n\t            this.selector = element;\n\t\n\t            var context = options && options.context;\n\t\n\t            _window = context? getWindow(context) : window;\n\t\n\t            if (context && (_window.Node\n\t                    ? context instanceof _window.Node\n\t                    : (isElement(context) || context === _window.document))) {\n\t\n\t                this._context = context;\n\t            }\n\t        }\n\t        else {\n\t            _window = getWindow(element);\n\t\n\t            if (isElement(element, _window)) {\n\t\n\t                if (PointerEvent) {\n\t                    events.add(this._element, pEventTypes.down, listeners.pointerDown );\n\t                    events.add(this._element, pEventTypes.move, listeners.pointerHover);\n\t                }\n\t                else {\n\t                    events.add(this._element, 'mousedown' , listeners.pointerDown );\n\t                    events.add(this._element, 'mousemove' , listeners.pointerHover);\n\t                    events.add(this._element, 'touchstart', listeners.pointerDown );\n\t                    events.add(this._element, 'touchmove' , listeners.pointerHover);\n\t                }\n\t            }\n\t        }\n\t\n\t        this._doc = _window.document;\n\t\n\t        if (!contains(documents, this._doc)) {\n\t            listenToDocument(this._doc);\n\t        }\n\t\n\t        interactables.push(this);\n\t\n\t        this.set(options);\n\t    }\n\t\n\t    Interactable.prototype = {\n\t        setOnEvents: function (action, phases) {\n\t            if (action === 'drop') {\n\t                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n\t                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n\t                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n\t                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n\t                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n\t                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n\t            }\n\t            else {\n\t                action = 'on' + action;\n\t\n\t                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n\t                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n\t                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n\t                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.draggable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether drag actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of drag events\n\t         | var isDraggable = interact('ul li').draggable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n\t         = (object) This Interactable\n\t         | interact(element).draggable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // the axis in which the first movement must be\n\t         |     // for the drag sequence to start\n\t         |     // 'xy' by default - any direction\n\t         |     axis: 'x' || 'y' || 'xy',\n\t         |\n\t         |     // max number of drags that can happen concurrently\n\t         |     // with elements of this Interactable. Infinity by default\n\t         |     max: Infinity,\n\t         |\n\t         |     // max number of drags that can target the same element+Interactable\n\t         |     // 1 by default\n\t         |     maxPerElement: 2\n\t         | });\n\t        \\*/\n\t        draggable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.drag.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('drag', options);\n\t                this.setOnEvents('drag', options);\n\t\n\t                if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t                    this.options.drag.axis = options.axis;\n\t                }\n\t                else if (options.axis === null) {\n\t                    delete this.options.drag.axis;\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.drag.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drag;\n\t        },\n\t\n\t        setPerAction: function (action, options) {\n\t            // for all the default per-action options\n\t            for (var option in options) {\n\t                // if this option exists for this action\n\t                if (option in defaultOptions[action]) {\n\t                    // if the option in the options arg is an object value\n\t                    if (isObject(options[option])) {\n\t                        // duplicate the object\n\t                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\t\n\t                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n\t                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n\t                        }\n\t                    }\n\t                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n\t                        this.options[action][option].enabled = options[option];\n\t                    }\n\t                    else if (options[option] !== undefined) {\n\t                        // or if it's not undefined, do a plain assignment\n\t                        this.options[action][option] = options[option];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.dropzone\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether elements can be dropped onto this\n\t         * Interactable to trigger drop events\n\t         *\n\t         * Dropzones can receive the following events:\n\t         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n\t         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n\t         *  - `dragmove` when a draggable that has entered the dropzone is moved\n\t         *  - `drop` when a draggable is dropped into this dropzone\n\t         *\n\t         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n\t         *\n\t         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n\t         *   - `'pointer'`, the pointer must be over the dropzone (default)\n\t         *   - `'center'`, the draggable element's center must be over the dropzone\n\t         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n\t         *       e.g. `0.5` for drop to happen when half of the area of the\n\t         *       draggable is over the dropzone\n\t         *\n\t         - options (boolean | object | null) #optional The new value to be set.\n\t         | interact('.drop').dropzone({\n\t         |   accept: '.can-drop' || document.getElementById('single-drop'),\n\t         |   overlap: 'pointer' || 'center' || zeroToOne\n\t         | }\n\t         = (boolean | object) The current setting or this Interactable\n\t        \\*/\n\t        dropzone: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.drop.enabled = options.enabled === false? false: true;\n\t                this.setOnEvents('drop', options);\n\t\n\t                if (/^(pointer|center)$/.test(options.overlap)) {\n\t                    this.options.drop.overlap = options.overlap;\n\t                }\n\t                else if (isNumber(options.overlap)) {\n\t                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n\t                }\n\t                if ('accept' in options) {\n\t                  this.options.drop.accept = options.accept;\n\t                }\n\t                if ('checker' in options) {\n\t                  this.options.drop.checker = options.checker;\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.drop.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop;\n\t        },\n\t\n\t        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n\t            var dropped = false;\n\t\n\t            // if the dropzone has no rect (eg. display: none)\n\t            // call the custom dropChecker or just return false\n\t            if (!(rect = rect || this.getRect(dropElement))) {\n\t                return (this.options.drop.checker\n\t                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n\t                    : false);\n\t            }\n\t\n\t            var dropOverlap = this.options.drop.overlap;\n\t\n\t            if (dropOverlap === 'pointer') {\n\t                var page = getPageXY(dragEvent),\n\t                    origin = getOriginXY(draggable, draggableElement),\n\t                    horizontal,\n\t                    vertical;\n\t\n\t                page.x += origin.x;\n\t                page.y += origin.y;\n\t\n\t                horizontal = (page.x > rect.left) && (page.x < rect.right);\n\t                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\t\n\t                dropped = horizontal && vertical;\n\t            }\n\t\n\t            var dragRect = draggable.getRect(draggableElement);\n\t\n\t            if (dropOverlap === 'center') {\n\t                var cx = dragRect.left + dragRect.width  / 2,\n\t                    cy = dragRect.top  + dragRect.height / 2;\n\t\n\t                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n\t            }\n\t\n\t            if (isNumber(dropOverlap)) {\n\t                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n\t                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n\t                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\t\n\t                dropped = overlapRatio >= dropOverlap;\n\t            }\n\t\n\t            if (this.options.drop.checker) {\n\t                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n\t            }\n\t\n\t            return dropped;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.dropChecker\n\t         [ method ]\n\t         *\n\t         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n\t         *\n\t         * Gets or sets the function used to check if a dragged element is\n\t         * over this Interactable.\n\t         *\n\t         - checker (function) #optional The function that will be called when checking for a drop\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         * The checker function takes the following arguments:\n\t         *\n\t         - dragEvent (InteractEvent) The related dragmove or dragend event\n\t         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n\t         - dropped (boolean) The value from the default drop checker\n\t         - dropzone (Interactable) The dropzone interactable\n\t         - dropElement (Element) The dropzone element\n\t         - draggable (Interactable) The Interactable being dragged\n\t         - draggableElement (Element) The actual element that's being dragged\n\t         *\n\t         > Usage:\n\t         | interact(target)\n\t         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n\t         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n\t         |                       dropped,           // bool result of the default checker\n\t         |                       dropzone,          // dropzone Interactable\n\t         |                       dropElement,       // dropzone elemnt\n\t         |                       draggable,         // draggable Interactable\n\t         |                       draggableElement) {// draggable element\n\t         |\n\t         |   return dropped && event.target.hasAttribute('allow-drop');\n\t         | }\n\t        \\*/\n\t        dropChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.options.drop.checker = checker;\n\t\n\t                return this;\n\t            }\n\t            if (checker === null) {\n\t                delete this.options.getRect;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop.checker;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.accept\n\t         [ method ]\n\t         *\n\t         * Deprecated. add an `accept` property to the options object passed to\n\t         * @Interactable.dropzone instead.\n\t         *\n\t         * Gets or sets the Element or CSS selector match that this\n\t         * Interactable accepts if it is a dropzone.\n\t         *\n\t         - newValue (Element | string | null) #optional\n\t         * If it is an Element, then only that element can be dropped into this dropzone.\n\t         * If it is a string, the element being dragged must match it as a selector.\n\t         * If it is null, the accept options is cleared - it accepts any element.\n\t         *\n\t         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n\t        \\*/\n\t        accept: function (newValue) {\n\t            if (isElement(newValue)) {\n\t                this.options.drop.accept = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            // test if it is a valid CSS selector\n\t            if (trySelector(newValue)) {\n\t                this.options.drop.accept = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.drop.accept;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop.accept;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.resizable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether resize actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of resize elements\n\t         | var isResizeable = interact('input[type=text]').resizable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n\t         = (object) This Interactable\n\t         | interact(element).resizable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     edges: {\n\t         |       top   : true,       // Use pointer coords to check for resize.\n\t         |       left  : false,      // Disable resizing from left edge.\n\t         |       bottom: '.resize-s',// Resize if pointer target matches selector\n\t         |       right : handleEl    // Resize if pointer target is the given Element\n\t         |     },\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height are adjusted at a 1:1 ratio.\n\t         |     square: false,\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height maintain the aspect ratio they had when resizing started.\n\t         |     preserveAspectRatio: false,\n\t         |\n\t         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t         |     // 'negate' will allow the rect to have negative width/height\n\t         |     // 'reposition' will keep the width/height positive by swapping\n\t         |     // the top and bottom edges and/or swapping the left and right edges\n\t         |     invert: 'none' || 'negate' || 'reposition'\n\t         |\n\t         |     // limit multiple resizes.\n\t         |     // See the explanation in the @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t        resizable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.resize.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('resize', options);\n\t                this.setOnEvents('resize', options);\n\t\n\t                if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t                    this.options.resize.axis = options.axis;\n\t                }\n\t                else if (options.axis === null) {\n\t                    this.options.resize.axis = defaultOptions.resize.axis;\n\t                }\n\t\n\t                if (isBool(options.preserveAspectRatio)) {\n\t                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n\t                }\n\t                else if (isBool(options.square)) {\n\t                    this.options.resize.square = options.square;\n\t                }\n\t\n\t                return this;\n\t            }\n\t            if (isBool(options)) {\n\t                this.options.resize.enabled = options;\n\t\n\t                return this;\n\t            }\n\t            return this.options.resize;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.squareResize\n\t         [ method ]\n\t         *\n\t         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n\t         *\n\t         * Gets or sets whether resizing is forced 1:1 aspect\n\t         *\n\t         = (boolean) Current setting\n\t         *\n\t         * or\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (object) this Interactable\n\t        \\*/\n\t        squareResize: function (newValue) {\n\t            if (isBool(newValue)) {\n\t                this.options.resize.square = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.resize.square;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.resize.square;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.gesturable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether multitouch gestures can be performed on the\n\t         * Interactable's element\n\t         *\n\t         = (boolean) Indicates if this can be the target of gesture events\n\t         | var isGestureable = interact(element).gesturable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n\t         = (object) this Interactable\n\t         | interact(element).gesturable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // limit multiple gestures.\n\t         |     // See the explanation in @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t        gesturable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.gesture.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('gesture', options);\n\t                this.setOnEvents('gesture', options);\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.gesture.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.gesture;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.autoScroll\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `autoscroll` property to the options object\n\t         * passed to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets whether dragging and resizing near the edges of the\n\t         * window/container trigger autoScroll for this Interactable\n\t         *\n\t         = (object) Object with autoScroll properties\n\t         *\n\t         * or\n\t         *\n\t         - options (object | boolean) #optional\n\t         * options can be:\n\t         * - an object with margin, distance and interval properties,\n\t         * - true or false to enable or disable autoScroll or\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t        autoScroll: function (options) {\n\t            if (isObject(options)) {\n\t                options = extend({ actions: ['drag', 'resize']}, options);\n\t            }\n\t            else if (isBool(options)) {\n\t                options = { actions: ['drag', 'resize'], enabled: options };\n\t            }\n\t\n\t            return this.setOptions('autoScroll', options);\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.snap\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `snap` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how action coordinates are snapped. By\n\t         * default, snapping is relative to the pointer coordinates. You can\n\t         * change this by setting the\n\t         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | interact(document.querySelector('#thing')).snap({\n\t         |     targets: [\n\t         |         // snap to this specific point\n\t         |         {\n\t         |             x: 100,\n\t         |             y: 100,\n\t         |             range: 25\n\t         |         },\n\t         |         // give this function the x and y page coords and snap to the object returned\n\t         |         function (x, y) {\n\t         |             return {\n\t         |                 x: x,\n\t         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n\t         |                 range: 40\n\t         |             };\n\t         |         },\n\t         |         // create a function that snaps to a grid\n\t         |         interact.createSnapGrid({\n\t         |             x: 50,\n\t         |             y: 50,\n\t         |             range: 10,              // optional\n\t         |             offset: { x: 5, y: 10 } // optional\n\t         |         })\n\t         |     ],\n\t         |     // do not snap during normal movement.\n\t         |     // Instead, trigger only one snapped move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     relativePoints: [\n\t         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n\t         |         { x: 1, y: 1 },  // and also to the bottom right\n\t         |     ],  \n\t         |\n\t         |     // offset the snap target coordinates\n\t         |     // can be an object with x/y or 'startCoords'\n\t         |     offset: { x: 50, y: 50 }\n\t         |   }\n\t         | });\n\t        \\*/\n\t        snap: function (options) {\n\t            var ret = this.setOptions('snap', options);\n\t\n\t            if (ret === this) { return this; }\n\t\n\t            return ret.drag;\n\t        },\n\t\n\t        setOptions: function (option, options) {\n\t            var actions = options && isArray(options.actions)\n\t                    ? options.actions\n\t                    : ['drag'];\n\t\n\t            var i;\n\t\n\t            if (isObject(options) || isBool(options)) {\n\t                for (i = 0; i < actions.length; i++) {\n\t                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\t\n\t                    if (!isObject(this.options[action])) { continue; }\n\t\n\t                    var thisOption = this.options[action][option];\n\t\n\t                    if (isObject(options)) {\n\t                        extend(thisOption, options);\n\t                        thisOption.enabled = options.enabled === false? false: true;\n\t\n\t                        if (option === 'snap') {\n\t                            if (thisOption.mode === 'grid') {\n\t                                thisOption.targets = [\n\t                                    interact.createSnapGrid(extend({\n\t                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n\t                                    }, thisOption.grid || {}))\n\t                                ];\n\t                            }\n\t                            else if (thisOption.mode === 'anchor') {\n\t                                thisOption.targets = thisOption.anchors;\n\t                            }\n\t                            else if (thisOption.mode === 'path') {\n\t                                thisOption.targets = thisOption.paths;\n\t                            }\n\t\n\t                            if ('elementOrigin' in options) {\n\t                                thisOption.relativePoints = [options.elementOrigin];\n\t                            }\n\t                        }\n\t                    }\n\t                    else if (isBool(options)) {\n\t                        thisOption.enabled = options;\n\t                    }\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            var ret = {},\n\t                allActions = ['drag', 'resize', 'gesture'];\n\t\n\t            for (i = 0; i < allActions.length; i++) {\n\t                if (option in defaultOptions[allActions[i]]) {\n\t                    ret[allActions[i]] = this.options[allActions[i]][option];\n\t                }\n\t            }\n\t\n\t            return ret;\n\t        },\n\t\n\t\n\t        /*\\\n\t         * Interactable.inertia\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `inertia` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how events continue to run after the pointer is released\n\t         **\n\t         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | // enable and use default settings\n\t         | interact(element).inertia(true);\n\t         |\n\t         | // enable and use custom settings\n\t         | interact(element).inertia({\n\t         |     // value greater than 0\n\t         |     // high values slow the object down more quickly\n\t         |     resistance     : 16,\n\t         |\n\t         |     // the minimum launch speed (pixels per second) that results in inertia start\n\t         |     minSpeed       : 200,\n\t         |\n\t         |     // inertia will stop when the object slows down to this speed\n\t         |     endSpeed       : 20,\n\t         |\n\t         |     // boolean; should actions be resumed when the pointer goes down during inertia\n\t         |     allowResume    : true,\n\t         |\n\t         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n\t         |     zeroResumeDelta: false,\n\t         |\n\t         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n\t         |     // the pointer without triggering inertia will animate from the release\n\t         |     // point to the snaped/restricted point in the given amount of time (ms)\n\t         |     smoothEndDuration: 300,\n\t         |\n\t         |     // an array of action types that can have inertia (no gesture)\n\t         |     actions        : ['drag', 'resize']\n\t         | });\n\t         |\n\t         | // reset custom settings and use all defaults\n\t         | interact(element).inertia(null);\n\t        \\*/\n\t        inertia: function (options) {\n\t            var ret = this.setOptions('inertia', options);\n\t\n\t            if (ret === this) { return this; }\n\t\n\t            return ret.drag;\n\t        },\n\t\n\t        getAction: function (pointer, event, interaction, element) {\n\t            var action = this.defaultActionChecker(pointer, interaction, element);\n\t\n\t            if (this.options.actionChecker) {\n\t                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n\t            }\n\t\n\t            return action;\n\t        },\n\t\n\t        defaultActionChecker: defaultActionChecker,\n\t\n\t        /*\\\n\t         * Interactable.actionChecker\n\t         [ method ]\n\t         *\n\t         * Gets or sets the function used to check action to be performed on\n\t         * pointerDown\n\t         *\n\t         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         | interact('.resize-drag')\n\t         |   .resizable(true)\n\t         |   .draggable(true)\n\t         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n\t         |\n\t         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n\t         |     // force drag with handle target\n\t         |     action.name = drag;\n\t         |   }\n\t         |   else {\n\t         |     // resize from the top and right edges\n\t         |     action.name  = 'resize';\n\t         |     action.edges = { top: true, right: true };\n\t         |   }\n\t         |\n\t         |   return action;\n\t         | });\n\t        \\*/\n\t        actionChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.options.actionChecker = checker;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (checker === null) {\n\t                delete this.options.actionChecker;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.actionChecker;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.getRect\n\t         [ method ]\n\t         *\n\t         * The default function to get an Interactables bounding rect. Can be\n\t         * overridden using @Interactable.rectChecker.\n\t         *\n\t         - element (Element) #optional The element to measure.\n\t         = (object) The object's bounding rectangle.\n\t         o {\n\t         o     top   : 0,\n\t         o     left  : 0,\n\t         o     bottom: 0,\n\t         o     right : 0,\n\t         o     width : 0,\n\t         o     height: 0\n\t         o }\n\t        \\*/\n\t        getRect: function rectCheck (element) {\n\t            element = element || this._element;\n\t\n\t            if (this.selector && !(isElement(element))) {\n\t                element = this._context.querySelector(this.selector);\n\t            }\n\t\n\t            return getElementRect(element);\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.rectChecker\n\t         [ method ]\n\t         *\n\t         * Returns or sets the function used to calculate the interactable's\n\t         * element's rectangle\n\t         *\n\t         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n\t         = (function | object) The checker function or this Interactable\n\t        \\*/\n\t        rectChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.getRect = checker;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (checker === null) {\n\t                delete this.options.getRect;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.getRect;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.styleCursor\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether the action that would be performed when the\n\t         * mouse on the element are checked on `mousemove` so that the cursor\n\t         * may be styled appropriately\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (boolean | Interactable) The current setting or this Interactable\n\t        \\*/\n\t        styleCursor: function (newValue) {\n\t            if (isBool(newValue)) {\n\t                this.options.styleCursor = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.styleCursor;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.styleCursor;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.preventDefault\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether to prevent the browser's default behaviour\n\t         * in response to pointer events. Can be set to:\n\t         *  - `'always'` to always prevent\n\t         *  - `'never'` to never prevent\n\t         *  - `'auto'` to let interact.js try to determine what would be best\n\t         *\n\t         - newValue (string) #optional `true`, `false` or `'auto'`\n\t         = (string | Interactable) The current setting or this Interactable\n\t        \\*/\n\t        preventDefault: function (newValue) {\n\t            if (/^(always|never|auto)$/.test(newValue)) {\n\t                this.options.preventDefault = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isBool(newValue)) {\n\t                this.options.preventDefault = newValue? 'always' : 'never';\n\t                return this;\n\t            }\n\t\n\t            return this.options.preventDefault;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.origin\n\t         [ method ]\n\t         *\n\t         * Gets or sets the origin of the Interactable's element.  The x and y\n\t         * of the origin will be subtracted from action event coordinates.\n\t         *\n\t         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n\t         * OR\n\t         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n\t         **\n\t         = (object) The current origin or this Interactable\n\t        \\*/\n\t        origin: function (newValue) {\n\t            if (trySelector(newValue)) {\n\t                this.options.origin = newValue;\n\t                return this;\n\t            }\n\t            else if (isObject(newValue)) {\n\t                this.options.origin = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.origin;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.deltaSource\n\t         [ method ]\n\t         *\n\t         * Returns or sets the mouse coordinate types used to calculate the\n\t         * movement of the pointer.\n\t         *\n\t         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n\t         = (string | object) The current deltaSource or this Interactable\n\t        \\*/\n\t        deltaSource: function (newValue) {\n\t            if (newValue === 'page' || newValue === 'client') {\n\t                this.options.deltaSource = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.deltaSource;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.restrict\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `restrict` property to the options object passed to\n\t         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n\t         *\n\t         * Returns or sets the rectangles within which actions on this\n\t         * interactable (after snap calculations) are restricted. By default,\n\t         * restricting is relative to the pointer coordinates. You can change\n\t         * this by setting the\n\t         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n\t         = (object) The current restrictions object or this Interactable\n\t         **\n\t         | interact(element).restrict({\n\t         |     // the rect will be `interact.getElementRect(element.parentNode)`\n\t         |     drag: element.parentNode,\n\t         |\n\t         |     // x and y are relative to the the interactable's origin\n\t         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n\t         | })\n\t         |\n\t         | interact('.draggable').restrict({\n\t         |     // the rect will be the selected element's parent\n\t         |     drag: 'parent',\n\t         |\n\t         |     // do not restrict during normal movement.\n\t         |     // Instead, trigger only one restricted move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n\t         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n\t         | });\n\t        \\*/\n\t        restrict: function (options) {\n\t            if (!isObject(options)) {\n\t                return this.setOptions('restrict', options);\n\t            }\n\t\n\t            var actions = ['drag', 'resize', 'gesture'],\n\t                ret;\n\t\n\t            for (var i = 0; i < actions.length; i++) {\n\t                var action = actions[i];\n\t\n\t                if (action in options) {\n\t                    var perAction = extend({\n\t                            actions: [action],\n\t                            restriction: options[action]\n\t                        }, options);\n\t\n\t                    ret = this.setOptions('restrict', perAction);\n\t                }\n\t            }\n\t\n\t            return ret;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.context\n\t         [ method ]\n\t         *\n\t         * Gets the selector context Node of the Interactable. The default is `window.document`.\n\t         *\n\t         = (Node) The context Node of this Interactable\n\t         **\n\t        \\*/\n\t        context: function () {\n\t            return this._context;\n\t        },\n\t\n\t        _context: document,\n\t\n\t        /*\\\n\t         * Interactable.ignoreFrom\n\t         [ method ]\n\t         *\n\t         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n\t         * event or any of it's parents match the given CSS selector or\n\t         * Element, no drag/resize/gesture is started.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n\t         = (string | Element | object) The current ignoreFrom value or this Interactable\n\t         **\n\t         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n\t         | // or\n\t         | interact(element).ignoreFrom('input, textarea, a');\n\t        \\*/\n\t        ignoreFrom: function (newValue) {\n\t            if (trySelector(newValue)) {            // CSS selector to match event.target\n\t                this.options.ignoreFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isElement(newValue)) {              // specific element\n\t                this.options.ignoreFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.ignoreFrom;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.allowFrom\n\t         [ method ]\n\t         *\n\t         * A drag/resize/gesture is started only If the target of the\n\t         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n\t         * parents match the given CSS selector or Element.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n\t         = (string | Element | object) The current allowFrom value or this Interactable\n\t         **\n\t         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n\t         | // or\n\t         | interact(element).allowFrom('.handle');\n\t        \\*/\n\t        allowFrom: function (newValue) {\n\t            if (trySelector(newValue)) {            // CSS selector to match event.target\n\t                this.options.allowFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isElement(newValue)) {              // specific element\n\t                this.options.allowFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.allowFrom;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.element\n\t         [ method ]\n\t         *\n\t         * If this is not a selector Interactable, it returns the element this\n\t         * interactable represents\n\t         *\n\t         = (Element) HTML / SVG Element\n\t        \\*/\n\t        element: function () {\n\t            return this._element;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.fire\n\t         [ method ]\n\t         *\n\t         * Calls listeners for the given InteractEvent type bound globally\n\t         * and directly to this Interactable\n\t         *\n\t         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t        fire: function (iEvent) {\n\t            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n\t                return this;\n\t            }\n\t\n\t            var listeners,\n\t                i,\n\t                len,\n\t                onEvent = 'on' + iEvent.type,\n\t                funcName = '';\n\t\n\t            // Interactable#on() listeners\n\t            if (iEvent.type in this._iEvents) {\n\t                listeners = this._iEvents[iEvent.type];\n\t\n\t                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t                    funcName = listeners[i].name;\n\t                    listeners[i](iEvent);\n\t                }\n\t            }\n\t\n\t            // interactable.onevent listener\n\t            if (isFunction(this[onEvent])) {\n\t                funcName = this[onEvent].name;\n\t                this[onEvent](iEvent);\n\t            }\n\t\n\t            // interact.on() listeners\n\t            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\t\n\t                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t                    funcName = listeners[i].name;\n\t                    listeners[i](iEvent);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.on\n\t         [ method ]\n\t         *\n\t         * Binds a listener for an InteractEvent or DOM event.\n\t         *\n\t         - eventType  (string | array | object) The types of events to listen for\n\t         - listener   (function) The function to be called on the given event(s)\n\t         - useCapture (boolean) #optional useCapture flag for addEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t        on: function (eventType, listener, useCapture) {\n\t            var i;\n\t\n\t            if (isString(eventType) && eventType.search(' ') !== -1) {\n\t                eventType = eventType.trim().split(/ +/);\n\t            }\n\t\n\t            if (isArray(eventType)) {\n\t                for (i = 0; i < eventType.length; i++) {\n\t                    this.on(eventType[i], listener, useCapture);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isObject(eventType)) {\n\t                for (var prop in eventType) {\n\t                    this.on(prop, eventType[prop], listener);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (eventType === 'wheel') {\n\t                eventType = wheelEvent;\n\t            }\n\t\n\t            // convert to boolean\n\t            useCapture = useCapture? true: false;\n\t\n\t            if (contains(eventTypes, eventType)) {\n\t                // if this type of event was never bound to this Interactable\n\t                if (!(eventType in this._iEvents)) {\n\t                    this._iEvents[eventType] = [listener];\n\t                }\n\t                else {\n\t                    this._iEvents[eventType].push(listener);\n\t                }\n\t            }\n\t            // delegated event for selector\n\t            else if (this.selector) {\n\t                if (!delegatedEvents[eventType]) {\n\t                    delegatedEvents[eventType] = {\n\t                        selectors: [],\n\t                        contexts : [],\n\t                        listeners: []\n\t                    };\n\t\n\t                    // add delegate listener functions\n\t                    for (i = 0; i < documents.length; i++) {\n\t                        events.add(documents[i], eventType, delegateListener);\n\t                        events.add(documents[i], eventType, delegateUseCapture, true);\n\t                    }\n\t                }\n\t\n\t                var delegated = delegatedEvents[eventType],\n\t                    index;\n\t\n\t                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t                    if (delegated.selectors[index] === this.selector\n\t                        && delegated.contexts[index] === this._context) {\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                if (index === -1) {\n\t                    index = delegated.selectors.length;\n\t\n\t                    delegated.selectors.push(this.selector);\n\t                    delegated.contexts .push(this._context);\n\t                    delegated.listeners.push([]);\n\t                }\n\t\n\t                // keep listener and useCapture flag\n\t                delegated.listeners[index].push([listener, useCapture]);\n\t            }\n\t            else {\n\t                events.add(this._element, eventType, listener, useCapture);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.off\n\t         [ method ]\n\t         *\n\t         * Removes an InteractEvent or DOM event listener\n\t         *\n\t         - eventType  (string | array | object) The types of events that were listened for\n\t         - listener   (function) The listener function to be removed\n\t         - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t        off: function (eventType, listener, useCapture) {\n\t            var i;\n\t\n\t            if (isString(eventType) && eventType.search(' ') !== -1) {\n\t                eventType = eventType.trim().split(/ +/);\n\t            }\n\t\n\t            if (isArray(eventType)) {\n\t                for (i = 0; i < eventType.length; i++) {\n\t                    this.off(eventType[i], listener, useCapture);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isObject(eventType)) {\n\t                for (var prop in eventType) {\n\t                    this.off(prop, eventType[prop], listener);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            var eventList,\n\t                index = -1;\n\t\n\t            // convert to boolean\n\t            useCapture = useCapture? true: false;\n\t\n\t            if (eventType === 'wheel') {\n\t                eventType = wheelEvent;\n\t            }\n\t\n\t            // if it is an action event type\n\t            if (contains(eventTypes, eventType)) {\n\t                eventList = this._iEvents[eventType];\n\t\n\t                if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n\t                    this._iEvents[eventType].splice(index, 1);\n\t                }\n\t            }\n\t            // delegated event\n\t            else if (this.selector) {\n\t                var delegated = delegatedEvents[eventType],\n\t                    matchFound = false;\n\t\n\t                if (!delegated) { return this; }\n\t\n\t                // count from last index of delegated to 0\n\t                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t                    // look for matching selector and context Node\n\t                    if (delegated.selectors[index] === this.selector\n\t                        && delegated.contexts[index] === this._context) {\n\t\n\t                        var listeners = delegated.listeners[index];\n\t\n\t                        // each item of the listeners array is an array: [function, useCaptureFlag]\n\t                        for (i = listeners.length - 1; i >= 0; i--) {\n\t                            var fn = listeners[i][0],\n\t                                useCap = listeners[i][1];\n\t\n\t                            // check if the listener functions and useCapture flags match\n\t                            if (fn === listener && useCap === useCapture) {\n\t                                // remove the listener from the array of listeners\n\t                                listeners.splice(i, 1);\n\t\n\t                                // if all listeners for this interactable have been removed\n\t                                // remove the interactable from the delegated arrays\n\t                                if (!listeners.length) {\n\t                                    delegated.selectors.splice(index, 1);\n\t                                    delegated.contexts .splice(index, 1);\n\t                                    delegated.listeners.splice(index, 1);\n\t\n\t                                    // remove delegate function from context\n\t                                    events.remove(this._context, eventType, delegateListener);\n\t                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\t\n\t                                    // remove the arrays if they are empty\n\t                                    if (!delegated.selectors.length) {\n\t                                        delegatedEvents[eventType] = null;\n\t                                    }\n\t                                }\n\t\n\t                                // only remove one listener\n\t                                matchFound = true;\n\t                                break;\n\t                            }\n\t                        }\n\t\n\t                        if (matchFound) { break; }\n\t                    }\n\t                }\n\t            }\n\t            // remove listener from this Interatable's element\n\t            else {\n\t                events.remove(this._element, eventType, listener, useCapture);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.set\n\t         [ method ]\n\t         *\n\t         * Reset the options of this Interactable\n\t         - options (object) The new settings to apply\n\t         = (object) This Interactable\n\t        \\*/\n\t        set: function (options) {\n\t            if (!isObject(options)) {\n\t                options = {};\n\t            }\n\t\n\t            this.options = extend({}, defaultOptions.base);\n\t\n\t            var i,\n\t                actions = ['drag', 'drop', 'resize', 'gesture'],\n\t                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n\t                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\t\n\t            for (i = 0; i < actions.length; i++) {\n\t                var action = actions[i];\n\t\n\t                this.options[action] = extend({}, defaultOptions[action]);\n\t\n\t                this.setPerAction(action, perActions);\n\t\n\t                this[methods[i]](options[action]);\n\t            }\n\t\n\t            var settings = [\n\t                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n\t                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n\t                    'rectChecker', 'styleCursor'\n\t                ];\n\t\n\t            for (i = 0, len = settings.length; i < len; i++) {\n\t                var setting = settings[i];\n\t\n\t                this.options[setting] = defaultOptions.base[setting];\n\t\n\t                if (setting in options) {\n\t                    this[setting](options[setting]);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.unset\n\t         [ method ]\n\t         *\n\t         * Remove this interactable from the list of interactables and remove\n\t         * it's drag, drop, resize and gesture capabilities\n\t         *\n\t         = (object) @interact\n\t        \\*/\n\t        unset: function () {\n\t            events.remove(this._element, 'all');\n\t\n\t            if (!isString(this.selector)) {\n\t                events.remove(this, 'all');\n\t                if (this.options.styleCursor) {\n\t                    this._element.style.cursor = '';\n\t                }\n\t            }\n\t            else {\n\t                // remove delegated events\n\t                for (var type in delegatedEvents) {\n\t                    var delegated = delegatedEvents[type];\n\t\n\t                    for (var i = 0; i < delegated.selectors.length; i++) {\n\t                        if (delegated.selectors[i] === this.selector\n\t                            && delegated.contexts[i] === this._context) {\n\t\n\t                            delegated.selectors.splice(i, 1);\n\t                            delegated.contexts .splice(i, 1);\n\t                            delegated.listeners.splice(i, 1);\n\t\n\t                            // remove the arrays if they are empty\n\t                            if (!delegated.selectors.length) {\n\t                                delegatedEvents[type] = null;\n\t                            }\n\t                        }\n\t\n\t                        events.remove(this._context, type, delegateListener);\n\t                        events.remove(this._context, type, delegateUseCapture, true);\n\t\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dropzone(false);\n\t\n\t            interactables.splice(indexOf(interactables, this), 1);\n\t\n\t            return interact;\n\t        }\n\t    };\n\t\n\t    function warnOnce (method, message) {\n\t        var warned = false;\n\t\n\t        return function () {\n\t            if (!warned) {\n\t                window.console.warn(message);\n\t                warned = true;\n\t            }\n\t\n\t            return method.apply(this, arguments);\n\t        };\n\t    }\n\t\n\t    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n\t         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n\t    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n\t         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n\t    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n\t         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n\t    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n\t         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n\t    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n\t         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\t\n\t    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n\t         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n\t    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n\t         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n\t    Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n\t         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\t\n\t    /*\\\n\t     * interact.isSet\n\t     [ method ]\n\t     *\n\t     * Check if an element has been set\n\t     - element (Element) The Element being searched for\n\t     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\t    \\*/\n\t    interact.isSet = function(element, options) {\n\t        return interactables.indexOfElement(element, options && options.context) !== -1;\n\t    };\n\t\n\t    /*\\\n\t     * interact.on\n\t     [ method ]\n\t     *\n\t     * Adds a global listener for an InteractEvent or adds a DOM event to\n\t     * `document`\n\t     *\n\t     - type       (string | array | object) The types of events to listen for\n\t     - listener   (function) The function to be called on the given event(s)\n\t     - useCapture (boolean) #optional useCapture flag for addEventListener\n\t     = (object) interact\n\t    \\*/\n\t    interact.on = function (type, listener, useCapture) {\n\t        if (isString(type) && type.search(' ') !== -1) {\n\t            type = type.trim().split(/ +/);\n\t        }\n\t\n\t        if (isArray(type)) {\n\t            for (var i = 0; i < type.length; i++) {\n\t                interact.on(type[i], listener, useCapture);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (isObject(type)) {\n\t            for (var prop in type) {\n\t                interact.on(prop, type[prop], listener);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        // if it is an InteractEvent type, add listener to globalEvents\n\t        if (contains(eventTypes, type)) {\n\t            // if this type of event was never bound\n\t            if (!globalEvents[type]) {\n\t                globalEvents[type] = [listener];\n\t            }\n\t            else {\n\t                globalEvents[type].push(listener);\n\t            }\n\t        }\n\t        // If non InteractEvent type, addEventListener to document\n\t        else {\n\t            events.add(document, type, listener, useCapture);\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.off\n\t     [ method ]\n\t     *\n\t     * Removes a global InteractEvent listener or DOM event from `document`\n\t     *\n\t     - type       (string | array | object) The types of events that were listened for\n\t     - listener   (function) The listener function to be removed\n\t     - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t     = (object) interact\n\t     \\*/\n\t    interact.off = function (type, listener, useCapture) {\n\t        if (isString(type) && type.search(' ') !== -1) {\n\t            type = type.trim().split(/ +/);\n\t        }\n\t\n\t        if (isArray(type)) {\n\t            for (var i = 0; i < type.length; i++) {\n\t                interact.off(type[i], listener, useCapture);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (isObject(type)) {\n\t            for (var prop in type) {\n\t                interact.off(prop, type[prop], listener);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (!contains(eventTypes, type)) {\n\t            events.remove(document, type, listener, useCapture);\n\t        }\n\t        else {\n\t            var index;\n\t\n\t            if (type in globalEvents\n\t                && (index = indexOf(globalEvents[type], listener)) !== -1) {\n\t                globalEvents[type].splice(index, 1);\n\t            }\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.enableDragging\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether dragging is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableDragging = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.drag = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.drag;\n\t    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\t\n\t    /*\\\n\t     * interact.enableResizing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether resizing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableResizing = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.resize = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.resize;\n\t    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\t\n\t    /*\\\n\t     * interact.enableGesturing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether gesturing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableGesturing = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.gesture = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.gesture;\n\t    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\t\n\t    interact.eventTypes = eventTypes;\n\t\n\t    /*\\\n\t     * interact.debug\n\t     [ method ]\n\t     *\n\t     * Returns debugging data\n\t     = (object) An object with properties that outline the current state and expose internal functions and variables\n\t    \\*/\n\t    interact.debug = function () {\n\t        var interaction = interactions[0] || new Interaction();\n\t\n\t        return {\n\t            interactions          : interactions,\n\t            target                : interaction.target,\n\t            dragging              : interaction.dragging,\n\t            resizing              : interaction.resizing,\n\t            gesturing             : interaction.gesturing,\n\t            prepared              : interaction.prepared,\n\t            matches               : interaction.matches,\n\t            matchElements         : interaction.matchElements,\n\t\n\t            prevCoords            : interaction.prevCoords,\n\t            startCoords           : interaction.startCoords,\n\t\n\t            pointerIds            : interaction.pointerIds,\n\t            pointers              : interaction.pointers,\n\t            addPointer            : listeners.addPointer,\n\t            removePointer         : listeners.removePointer,\n\t            recordPointer        : listeners.recordPointer,\n\t\n\t            snap                  : interaction.snapStatus,\n\t            restrict              : interaction.restrictStatus,\n\t            inertia               : interaction.inertiaStatus,\n\t\n\t            downTime              : interaction.downTimes[0],\n\t            downEvent             : interaction.downEvent,\n\t            downPointer           : interaction.downPointer,\n\t            prevEvent             : interaction.prevEvent,\n\t\n\t            Interactable          : Interactable,\n\t            interactables         : interactables,\n\t            pointerIsDown         : interaction.pointerIsDown,\n\t            defaultOptions        : defaultOptions,\n\t            defaultActionChecker  : defaultActionChecker,\n\t\n\t            actionCursors         : actionCursors,\n\t            dragMove              : listeners.dragMove,\n\t            resizeMove            : listeners.resizeMove,\n\t            gestureMove           : listeners.gestureMove,\n\t            pointerUp             : listeners.pointerUp,\n\t            pointerDown           : listeners.pointerDown,\n\t            pointerMove           : listeners.pointerMove,\n\t            pointerHover          : listeners.pointerHover,\n\t\n\t            eventTypes            : eventTypes,\n\t\n\t            events                : events,\n\t            globalEvents          : globalEvents,\n\t            delegatedEvents       : delegatedEvents,\n\t\n\t            prefixedPropREs       : prefixedPropREs\n\t        };\n\t    };\n\t\n\t    // expose the functions used to calculate multi-touch properties\n\t    interact.getPointerAverage = pointerAverage;\n\t    interact.getTouchBBox     = touchBBox;\n\t    interact.getTouchDistance = touchDistance;\n\t    interact.getTouchAngle    = touchAngle;\n\t\n\t    interact.getElementRect         = getElementRect;\n\t    interact.getElementClientRect   = getElementClientRect;\n\t    interact.matchesSelector        = matchesSelector;\n\t    interact.closest                = closest;\n\t\n\t    /*\\\n\t     * interact.margin\n\t     [ method ]\n\t     *\n\t     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n\t     * Returns or sets the margin for autocheck resizing used in\n\t     * @Interactable.getAction. That is the distance from the bottom and right\n\t     * edges of an element clicking in which will start resizing\n\t     *\n\t     - newValue (number) #optional\n\t     = (number | interact) The current margin value or interact\n\t    \\*/\n\t    interact.margin = warnOnce(function (newvalue) {\n\t        if (isNumber(newvalue)) {\n\t            margin = newvalue;\n\t\n\t            return interact;\n\t        }\n\t        return margin;\n\t    },\n\t    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\t\n\t    /*\\\n\t     * interact.supportsTouch\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports touch input\n\t    \\*/\n\t    interact.supportsTouch = function () {\n\t        return supportsTouch;\n\t    };\n\t\n\t    /*\\\n\t     * interact.supportsPointerEvent\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports PointerEvents\n\t    \\*/\n\t    interact.supportsPointerEvent = function () {\n\t        return supportsPointerEvent;\n\t    };\n\t\n\t    /*\\\n\t     * interact.stop\n\t     [ method ]\n\t     *\n\t     * Cancels all interactions (end events are not fired)\n\t     *\n\t     - event (Event) An event on which to call preventDefault()\n\t     = (object) interact\n\t    \\*/\n\t    interact.stop = function (event) {\n\t        for (var i = interactions.length - 1; i >= 0; i--) {\n\t            interactions[i].stop(event);\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.dynamicDrop\n\t     [ method ]\n\t     *\n\t     * Returns or sets whether the dimensions of dropzone elements are\n\t     * calculated on every dragmove or only on dragstart for the default\n\t     * dropChecker\n\t     *\n\t     - newValue (boolean) #optional True to check on each move. False to check only before start\n\t     = (boolean | interact) The current setting or interact\n\t    \\*/\n\t    interact.dynamicDrop = function (newValue) {\n\t        if (isBool(newValue)) {\n\t            //if (dragging && dynamicDrop !== newValue && !newValue) {\n\t                //calcRects(dropzones);\n\t            //}\n\t\n\t            dynamicDrop = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return dynamicDrop;\n\t    };\n\t\n\t    /*\\\n\t     * interact.pointerMoveTolerance\n\t     [ method ]\n\t     * Returns or sets the distance the pointer must be moved before an action\n\t     * sequence occurs. This also affects tolerance for tap events.\n\t     *\n\t     - newValue (number) #optional The movement from the start position must be greater than this value\n\t     = (number | Interactable) The current setting or interact\n\t    \\*/\n\t    interact.pointerMoveTolerance = function (newValue) {\n\t        if (isNumber(newValue)) {\n\t            pointerMoveTolerance = newValue;\n\t\n\t            return this;\n\t        }\n\t\n\t        return pointerMoveTolerance;\n\t    };\n\t\n\t    /*\\\n\t     * interact.maxInteractions\n\t     [ method ]\n\t     **\n\t     * Returns or sets the maximum number of concurrent interactions allowed.\n\t     * By default only 1 interaction is allowed at a time (for backwards\n\t     * compatibility). To allow multiple interactions on the same Interactables\n\t     * and elements, you need to enable it in the draggable, resizable and\n\t     * gesturable `'max'` and `'maxPerElement'` options.\n\t     **\n\t     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\t    \\*/\n\t    interact.maxInteractions = function (newValue) {\n\t        if (isNumber(newValue)) {\n\t            maxInteractions = newValue;\n\t\n\t            return this;\n\t        }\n\t\n\t        return maxInteractions;\n\t    };\n\t\n\t    interact.createSnapGrid = function (grid) {\n\t        return function (x, y) {\n\t            var offsetX = 0,\n\t                offsetY = 0;\n\t\n\t            if (isObject(grid.offset)) {\n\t                offsetX = grid.offset.x;\n\t                offsetY = grid.offset.y;\n\t            }\n\t\n\t            var gridx = Math.round((x - offsetX) / grid.x),\n\t                gridy = Math.round((y - offsetY) / grid.y),\n\t\n\t                newX = gridx * grid.x + offsetX,\n\t                newY = gridy * grid.y + offsetY;\n\t\n\t            return {\n\t                x: newX,\n\t                y: newY,\n\t                range: grid.range\n\t            };\n\t        };\n\t    };\n\t\n\t    function endAllInteractions (event) {\n\t        for (var i = 0; i < interactions.length; i++) {\n\t            interactions[i].pointerEnd(event, event);\n\t        }\n\t    }\n\t\n\t    function listenToDocument (doc) {\n\t        if (contains(documents, doc)) { return; }\n\t\n\t        var win = doc.defaultView || doc.parentWindow;\n\t\n\t        // add delegate event listener\n\t        for (var eventType in delegatedEvents) {\n\t            events.add(doc, eventType, delegateListener);\n\t            events.add(doc, eventType, delegateUseCapture, true);\n\t        }\n\t\n\t        if (PointerEvent) {\n\t            if (PointerEvent === win.MSPointerEvent) {\n\t                pEventTypes = {\n\t                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n\t                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n\t            }\n\t            else {\n\t                pEventTypes = {\n\t                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n\t                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n\t            }\n\t\n\t            events.add(doc, pEventTypes.down  , listeners.selectorDown );\n\t            events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n\t            events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n\t            events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n\t            events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n\t            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\t\n\t            // autoscroll\n\t            events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n\t        }\n\t        else {\n\t            events.add(doc, 'mousedown', listeners.selectorDown);\n\t            events.add(doc, 'mousemove', listeners.pointerMove );\n\t            events.add(doc, 'mouseup'  , listeners.pointerUp   );\n\t            events.add(doc, 'mouseover', listeners.pointerOver );\n\t            events.add(doc, 'mouseout' , listeners.pointerOut  );\n\t\n\t            events.add(doc, 'touchstart' , listeners.selectorDown );\n\t            events.add(doc, 'touchmove'  , listeners.pointerMove  );\n\t            events.add(doc, 'touchend'   , listeners.pointerUp    );\n\t            events.add(doc, 'touchcancel', listeners.pointerCancel);\n\t\n\t            // autoscroll\n\t            events.add(doc, 'mousemove', listeners.autoScrollMove);\n\t            events.add(doc, 'touchmove', listeners.autoScrollMove);\n\t        }\n\t\n\t        events.add(win, 'blur', endAllInteractions);\n\t\n\t        try {\n\t            if (win.frameElement) {\n\t                var parentDoc = win.frameElement.ownerDocument,\n\t                    parentWindow = parentDoc.defaultView;\n\t\n\t                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n\t                events.add(parentWindow, 'blur'         , endAllInteractions );\n\t            }\n\t        }\n\t        catch (error) {\n\t            interact.windowParentError = error;\n\t        }\n\t\n\t        // prevent native HTML5 drag on interact.js target elements\n\t        events.add(doc, 'dragstart', function (event) {\n\t            for (var i = 0; i < interactions.length; i++) {\n\t                var interaction = interactions[i];\n\t\n\t                if (interaction.element\n\t                    && (interaction.element === event.target\n\t                        || nodeContains(interaction.element, event.target))) {\n\t\n\t                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t\n\t        if (events.useAttachEvent) {\n\t            // For IE's lack of Event#preventDefault\n\t            events.add(doc, 'selectstart', function (event) {\n\t                var interaction = interactions[0];\n\t\n\t                if (interaction.currentAction()) {\n\t                    interaction.checkAndPreventDefault(event);\n\t                }\n\t            });\n\t\n\t            // For IE's bad dblclick event sequence\n\t            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n\t        }\n\t\n\t        documents.push(doc);\n\t    }\n\t\n\t    listenToDocument(document);\n\t\n\t    function indexOf (array, target) {\n\t        for (var i = 0, len = array.length; i < len; i++) {\n\t            if (array[i] === target) {\n\t                return i;\n\t            }\n\t        }\n\t\n\t        return -1;\n\t    }\n\t\n\t    function contains (array, target) {\n\t        return indexOf(array, target) !== -1;\n\t    }\n\t\n\t    function matchesSelector (element, selector, nodeList) {\n\t        if (ie8MatchesSelector) {\n\t            return ie8MatchesSelector(element, selector, nodeList);\n\t        }\n\t\n\t        // remove /deep/ from selectors if shadowDOM polyfill is used\n\t        if (window !== realWindow) {\n\t            selector = selector.replace(/\\/deep\\//g, ' ');\n\t        }\n\t\n\t        return element[prefixedMatchesSelector](selector);\n\t    }\n\t\n\t    function matchesUpTo (element, selector, limit) {\n\t        while (isElement(element)) {\n\t            if (matchesSelector(element, selector)) {\n\t                return true;\n\t            }\n\t\n\t            element = parentElement(element);\n\t\n\t            if (element === limit) {\n\t                return matchesSelector(element, selector);\n\t            }\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    // For IE8's lack of an Element#matchesSelector\n\t    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n\t    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n\t        ie8MatchesSelector = function (element, selector, elems) {\n\t            elems = elems || element.parentNode.querySelectorAll(selector);\n\t\n\t            for (var i = 0, len = elems.length; i < len; i++) {\n\t                if (elems[i] === element) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            return false;\n\t        };\n\t    }\n\t\n\t    // requestAnimationFrame polyfill\n\t    (function() {\n\t        var lastTime = 0,\n\t            vendors = ['ms', 'moz', 'webkit', 'o'];\n\t\n\t        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n\t            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n\t            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n\t        }\n\t\n\t        if (!reqFrame) {\n\t            reqFrame = function(callback) {\n\t                var currTime = new Date().getTime(),\n\t                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n\t                    id = setTimeout(function() { callback(currTime + timeToCall); },\n\t                  timeToCall);\n\t                lastTime = currTime + timeToCall;\n\t                return id;\n\t            };\n\t        }\n\t\n\t        if (!cancelFrame) {\n\t            cancelFrame = function(id) {\n\t                clearTimeout(id);\n\t            };\n\t        }\n\t    }());\n\t\n\t    /* global exports: true, module, define */\n\t\n\t    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n\t    if (true) {\n\t        if (typeof module !== 'undefined' && module.exports) {\n\t            exports = module.exports = interact;\n\t        }\n\t        exports.interact = interact;\n\t    }\n\t    // AMD\n\t    else if (typeof define === 'function' && define.amd) {\n\t        define('interact', function() {\n\t            return interact;\n\t        });\n\t    }\n\t    else {\n\t        realWindow.interact = interact;\n\t    }\n\t\n\t} (typeof window === 'undefined'? undefined : window));\n\n\n/***/ },\n\n/***/ 33:\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div class=\\\"w-app card\\\" v-bind:class=\\\"[loading ? 'isLoading': '', isDeleted ? 'animated zoomOutDown': '', isMax ? 'is-fullwidth' : '']\\\" @click=bringToFront @mousedown=bringToFront @animationend=makeMe draggable=true tabindex=0 _v-ca6846e8=\\\"\\\"> <header class=card-header _v-ca6846e8=\\\"\\\"> <p class=card-header-title _v-ca6846e8=\\\"\\\"> {{title}} </p> <a class=card-header-icon _v-ca6846e8=\\\"\\\"> <i class=\\\"fa fa-minus\\\" _v-ca6846e8=\\\"\\\"></i> </a> <a class=card-header-icon @click=maxApp _v-ca6846e8=\\\"\\\"> <i class=fa v-bind:class=\\\"[isMax ? 'fa-compress': 'fa-expand']\\\" _v-ca6846e8=\\\"\\\"></i> </a> <a class=card-header-icon @click=closeApp _v-ca6846e8=\\\"\\\"> <i class=\\\"fa fa-times\\\" _v-ca6846e8=\\\"\\\"></i> </a> </header> <header v-if=hasSubNav class=\\\"card-header card-header--subnav\\\" _v-ca6846e8=\\\"\\\"> <slot name=header _v-ca6846e8=\\\"\\\"></slot> </header> <div class=card-content _v-ca6846e8=\\\"\\\"> <div class=content _v-ca6846e8=\\\"\\\"> <slot _v-ca6846e8=\\\"\\\"></slot> </div> </div> </div> \";\n\n/***/ },\n\n/***/ 34:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(29)\n\t__webpack_require__(28)\n\t__vue_script__ = __webpack_require__(24)\n\t__vue_template__ = __webpack_require__(33)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n\n/***/ 325:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _wApp = __webpack_require__(34);\n\t\n\tvar _wApp2 = _interopRequireDefault(_wApp);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  data: function data() {\n\t    return {\n\t      fileName: '',\n\t      fileData: ''\n\t    };\n\t  },\n\t\n\t  components: {\n\t    wApp: _wApp2.default\n\t  },\n\t  methods: {\n\t    saveFile: function saveFile(data) {\n\t      console.log('save file:', this.fileData);\n\t      this.$dispatch('saveFile', { data: this.fileData, name: this.fileName });\n\t    },\n\t    getFileSystem: function getFileSystem(e) {\n\t      console.log('getFileSystem:', this);\n\t      this.$dispatch('getFileSystem', this);\n\t    },\n\t    openNew: function openNew(app) {\n\t      this.$dispatch('openApp', app);\n\t    }\n\t  }\n\t};\n\n/***/ },\n\n/***/ 369:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\", \"\", {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"textEditor.vue\",\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 380:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(369);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(14)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-082eb0c5&scoped=true!./../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./textEditor.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-082eb0c5&scoped=true!./../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./textEditor.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 753:\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <w-app title=Text-Editor class=\\\"app--text-editor animated fadeInDown\\\" :has-sub-nav=true _v-082eb0c5=\\\"\\\"> <nav slot=header _v-082eb0c5=\\\"\\\"> <p class=panel-tabs _v-082eb0c5=\\\"\\\"> <a @click=getFileSystem class=\\\"\\\" href=# _v-082eb0c5=\\\"\\\">Open</a> <a @click=saveFile class=\\\"\\\" href=# _v-082eb0c5=\\\"\\\">Save</a> <a @click=\\\"openNew('textEditor')\\\" class=\\\"\\\" href=# _v-082eb0c5=\\\"\\\">New</a> </p> </nav> <p class=control _v-082eb0c5=\\\"\\\"> <textarea class=textarea v-model=fileData placeholder=Type.. _v-082eb0c5=\\\"\\\">{{fileData}}</textarea> </p> </w-app> \";\n\n/***/ },\n\n/***/ 765:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(380)\n\t__vue_script__ = __webpack_require__(325)\n\t__vue_template__ = __webpack_require__(753)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** static/js/4.12068b5f31e0746c35b2.js\n **/","<template>\n  <div class=\"w-app card\"\n    v-bind:class=\"[loading ? 'isLoading': '', isDeleted ? 'animated zoomOutDown': '', isMax ? 'is-fullwidth' : '']\"     \n    @click=\"bringToFront\"\n    @mousedown=\"bringToFront\"\n    @animationend=\"makeMe\"  \n    draggable='true'\n    tabindex=\"0\">\n    <header class=\"card-header\">\n      <p class=\"card-header-title\">\n        {{title}}\n      </p>\n      <a class=\"card-header-icon\" >\n        <i class=\"fa fa-minus\"></i>\n      </a>\n      <a class=\"card-header-icon\" @click='maxApp'>\n        <i class=\"fa\" v-bind:class=\"[isMax ? 'fa-compress': 'fa-expand']\"></i>\n      </a>\n      <a class=\"card-header-icon\" @click='closeApp'>\n        <i class=\"fa fa-times\"></i>\n      </a>\n    </header>\n    <header v-if='hasSubNav' class='card-header card-header--subnav'>\n      <slot name='header'></slot>\n    </header>\n    <div class=\"card-content\">\n      <div class=\"content\">\n        <slot></slot>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nlet interact = require('interact.js')\ninteract('.w-app header')\n  .draggable({\n    inertia: true,\n    restrict: {\n      restriction: '.bound',\n      endOnly: true,\n      elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n    },\n    autoScroll: true,\n    onmove: dragMoveListener,\n    // call this function on every dragend event\n    onend: function (event) {\n    //   var textEl = event.target.querySelector('p')\n\n    //   textEl && (textEl.textContent =\n    //     'moved a distance of ' +\n    //     (Math.sqrt(event.dx * event.dx +\n    //     event.dy * event.dy) | 0) + 'px')\n    }\n  })\n  // .resizable({\n  //   preserveAspectRatio: false,\n  //   edges: { left: true, right: true, bottom: true, top: true }\n  // })\n  // .on('resizemove', function (event) {\n  //   var target = event.target\n  //   var x = (parseFloat(target.getAttribute('data-x')) || 0)\n  //   var y = (parseFloat(target.getAttribute('data-y')) || 0)\n\n  //   // update the element's style\n  //   target.style.width = event.rect.width + 'px'\n  //   target.style.height = event.rect.height + 'px'\n\n  //   // translate when resizing from top or left edges\n  //   x += event.deltaRect.left\n  //   y += event.deltaRect.top\n\n  //   target.style.webkitTransform = target.style.transform =\n  //       'translate(' + x + 'px,' + y + 'px)'\n\n  //   target.setAttribute('data-x', x)\n  //   target.setAttribute('data-y', y)\n  // })\nfunction dragMoveListener (event) {\n  var target = event.target.parentNode\n      // keep the dragged position in the data-x/data-y attributes\n  var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx\n  var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy\n\n  // translate the element\n  target.style.webkitTransform =\n  target.style.transform =\n    'translate(' + x + 'px, ' + y + 'px)'\n  // target.style.zIndex = 1\n  // update the posiion attributes\n  target.setAttribute('data-x', x)\n  target.setAttribute('data-y', y)\n}\nexport default {\n  data () {\n    return {\n      // note: changing this line won't causes changes\n      // with hot-reload because the reloaded component\n      // preserves its current state and we are modifying\n      // its initial state.\n      hasFocus: false,\n      isMax: false,\n      isDeleted: false\n    }\n  },\n  methods: {\n    bringToFront (e) {\n      this.$dispatch('bringToFront', e.currentTarget)\n      this.$dispatch('loseFocus')\n      this.$set('hasFocus', true)\n    },\n    closeApp (e) {\n      this.$set('isDeleted', true)\n      this.$dispatch('closeApp', e)\n    },\n    maxApp (e) {\n      this.$set('isMax', !this.isMax)\n    },\n    makeMe (e) {\n      let target = e.currentTarget\n      if (this.isDeleted) {\n        target.parentNode.removeChild(target)\n      } else {\n        target.classList.remove('animated')\n        target.classList.remove('fadeInDown')\n        this.$dispatch('addMe', target)\n        this.$dispatch('loseFocus')\n        this.$set('hasFocus', true)\n      }\n    }\n  },\n  events: {\n    loseFocus () {\n      this.$set('hasFocus', false)\n    }\n  },\n  props: {\n    title: {\n      type: String,\n      required: true\n    },\n    loading: {\n      type: Boolean\n    },\n    hasSubNav: {\n      type: Boolean,\n      default: false,\n      required: true\n    }\n  }\n}\n</script>\n<style lang='css' scoped>\n  .w-app {\n    position: absolute;\n\t  color: #FFF;\n    top: 100px;\n    left: 100px;\n    box-shadow: 0px 0px 5px black;\n    z-index: 0;\n    .card-header {\n      cursor: move;\n    }\n    transition: 1s background ease-in-out;\n  }\n  .card-header .card-header-icon {\n    width: 24px;\n    color: #42afe3;\n  }\n  .card-content {\n    width: unset;\n  }\n  .is-fullwidth {\n    transform: translate(-100px, -44px) !important;\n    height: 93%;\n    .card-content {\n      height: 100%;\n      overflow-y: auto;\n    }\n  }\n  .isLoading {\n    background-color: #c3c3c3;\n  }\n</style>\n\n<style>\n  .card-header--subnav .panel-tabs a {\n    color: #42afe3;\n  }\n</style>\n\n\n/** WEBPACK FOOTER **\n ** wApp.vue?464ab078\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".card-header--subnav .panel-tabs a{color:#42afe3}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/wApp.vue\"],\"names\":[],\"mappings\":\"AA0LA,mCACE,aAAe,CAChB\",\"file\":\"wApp.vue\",\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n.card-header--subnav .panel-tabs a {\\n  color: #42afe3;\\n}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js!./~/vue-loader/lib/selector.js?type=style&index=1!./src/components/wApp.vue\n ** module id = 26\n ** module chunks = 0 1 2 3 4 5\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".w-app[_v-ca6846e8]{position:absolute;color:#fff;top:100px;left:100px;box-shadow:0 0 5px #000;z-index:0;.card-header{cursor:move}-webkit-transition:background 1s ease-in-out;transition:background 1s ease-in-out}.card-header .card-header-icon[_v-ca6846e8]{width:24px;color:#42afe3}.card-content[_v-ca6846e8]{width:unset}.is-fullwidth[_v-ca6846e8]{-webkit-transform:translate(-100px,-44px)!important;transform:translate(-100px,-44px)!important;height:93%;.card-content{height:100%;overflow-y:auto}}.isLoading[_v-ca6846e8]{background-color:#c3c3c3}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/wApp.vue\"],\"names\":[],\"mappings\":\"AAyJE,oBACE,kBAAmB,AACpB,WAAY,AACX,UAAW,AACX,WAAY,AACZ,wBAA8B,AAC9B,UAAW,AACX,aACE,WAAa,CACd,AACD,6CAA8C,AAC9C,oCAAsC,CACvC,AACD,4CACE,WAAY,AACZ,aAAe,CAChB,AACD,2BACE,WAAa,CACd,AACD,2BACE,oDAAuD,AAC/C,4CAA+C,AACvD,WAAY,AACZ,cACE,YAAa,AACb,eAAiB,CAClB,CACF,AACD,wBACE,wBAA0B,CAC3B\",\"file\":\"wApp.vue\",\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  .w-app[_v-ca6846e8] {\\n    position: absolute;\\n\\t  color: #FFF;\\n    top: 100px;\\n    left: 100px;\\n    box-shadow: 0px 0px 5px black;\\n    z-index: 0;\\n    .card-header {\\n      cursor: move;\\n    }\\n    -webkit-transition: 1s background ease-in-out;\\n    transition: 1s background ease-in-out;\\n  }\\n  .card-header .card-header-icon[_v-ca6846e8] {\\n    width: 24px;\\n    color: #42afe3;\\n  }\\n  .card-content[_v-ca6846e8] {\\n    width: unset;\\n  }\\n  .is-fullwidth[_v-ca6846e8] {\\n    -webkit-transform: translate(-100px, -44px) !important;\\n            transform: translate(-100px, -44px) !important;\\n    height: 93%;\\n    .card-content {\\n      height: 100%;\\n      overflow-y: auto;\\n    }\\n  }\\n  .isLoading[_v-ca6846e8] {\\n    background-color: #c3c3c3;\\n  }\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/wApp.vue\n ** module id = 27\n ** module chunks = 0 1 2 3 4 5\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js!./~/vue-loader/lib/selector.js?type=style&index=1!./src/components/wApp.vue\n ** module id = 28\n ** module chunks = 0 1 2 3 4 5\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/wApp.vue\n ** module id = 29\n ** module chunks = 0 1 2 3 4 5\n **/","/**\n * interact.js v1.2.6\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function (realWindow) {\n    'use strict';\n\n    // return early if there's no window to work with (eg. Node.js)\n    if (!realWindow) { return; }\n\n    var // get wrapped window if using Shadow DOM polyfill\n        window = (function () {\n            // create a TextNode\n            var el = realWindow.document.createTextNode('');\n\n            // check if it's wrapped by a polyfill\n            if (el.ownerDocument !== realWindow.document\n                && typeof realWindow.wrap === 'function'\n                && realWindow.wrap(el) === el) {\n                // return wrapped window\n                return realWindow.wrap(realWindow);\n            }\n\n            // no Shadow DOM polyfil or native implementation\n            return realWindow;\n        }()),\n\n        document           = window.document,\n        DocumentFragment   = window.DocumentFragment   || blank,\n        SVGElement         = window.SVGElement         || blank,\n        SVGSVGElement      = window.SVGSVGElement      || blank,\n        SVGElementInstance = window.SVGElementInstance || blank,\n        HTMLElement        = window.HTMLElement        || window.Element,\n\n        PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n        pEventTypes,\n\n        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\n        tmpXY = {},     // reduce object creation in getXY()\n\n        documents       = [],   // all documents being listened to\n\n        interactables   = [],   // all set interactables\n        interactions    = [],   // all interactions\n\n        dynamicDrop     = false,\n\n        // {\n        //      type: {\n        //          selectors: ['selector', ...],\n        //          contexts : [document, ...],\n        //          listeners: [[listener, useCapture], ...]\n        //      }\n        //  }\n        delegatedEvents = {},\n\n        defaultOptions = {\n            base: {\n                accept        : null,\n                actionChecker : null,\n                styleCursor   : true,\n                preventDefault: 'auto',\n                origin        : { x: 0, y: 0 },\n                deltaSource   : 'page',\n                allowFrom     : null,\n                ignoreFrom    : null,\n                _context      : document,\n                dropChecker   : null\n            },\n\n            drag: {\n                enabled: false,\n                manualStart: true,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                axis: 'xy'\n            },\n\n            drop: {\n                enabled: false,\n                accept: null,\n                overlap: 'pointer'\n            },\n\n            resize: {\n                enabled: false,\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                square: false,\n                preserveAspectRatio: false,\n                axis: 'xy',\n\n                // use default margin\n                margin: NaN,\n\n                // object with props left, right, top, bottom which are\n                // true/false values to resize when the pointer is over that edge,\n                // CSS selectors to match the handles for each direction\n                // or the Elements for each handle\n                edges: null,\n\n                // a value of 'none' will limit the resize rect to a minimum of 0x0\n                // 'negate' will alow the rect to have negative width/height\n                // 'reposition' will keep the width/height positive by swapping\n                // the top and bottom edges and/or swapping the left and right edges\n                invert: 'none'\n            },\n\n            gesture: {\n                manualStart: false,\n                enabled: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                restrict: null\n            },\n\n            perAction: {\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: {\n                    enabled     : false,\n                    endOnly     : false,\n                    range       : Infinity,\n                    targets     : null,\n                    offsets     : null,\n\n                    relativePoints: null\n                },\n\n                restrict: {\n                    enabled: false,\n                    endOnly: false\n                },\n\n                autoScroll: {\n                    enabled     : false,\n                    container   : null,     // the item that is scrolled (Window or HTMLElement)\n                    margin      : 60,\n                    speed       : 300       // the scroll speed in pixels per second\n                },\n\n                inertia: {\n                    enabled          : false,\n                    resistance       : 10,    // the lambda in exponential decay\n                    minSpeed         : 100,   // target speed must be above this for inertia to start\n                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n                    allowResume      : true,  // allow resuming an action in inertia phase\n                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n                }\n            },\n\n            _holdDuration: 600\n        },\n\n        // Things related to autoScroll\n        autoScroll = {\n            interaction: null,\n            i: null,    // the handle returned by window.setInterval\n            x: 0, y: 0, // Direction each pulse is to scroll in\n\n            // scroll the window by the values in scroll.x/y\n            scroll: function () {\n                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n                    container = options.container || getWindow(autoScroll.interaction.element),\n                    now = new Date().getTime(),\n                    // change in time in seconds\n                    dtx = (now - autoScroll.prevTimeX) / 1000,\n                    dty = (now - autoScroll.prevTimeY) / 1000,\n                    vx, vy, sx, sy;\n\n                // displacement\n                if (options.velocity) {\n                  vx = options.velocity.x;\n                  vy = options.velocity.y;\n                }\n                else {\n                  vx = vy = options.speed\n                }\n \n                sx = vx * dtx;\n                sy = vy * dty;\n\n                if (sx >= 1 || sy >= 1) {\n                    if (isWindow(container)) {\n                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n                    }\n                    else if (container) {\n                        container.scrollLeft += autoScroll.x * sx;\n                        container.scrollTop  += autoScroll.y * sy;\n                    }\n\n                    if (sx >=1) autoScroll.prevTimeX = now;\n                    if (sy >= 1) autoScroll.prevTimeY = now;\n                }\n\n                if (autoScroll.isScrolling) {\n                    cancelFrame(autoScroll.i);\n                    autoScroll.i = reqFrame(autoScroll.scroll);\n                }\n            },\n\n            isScrolling: false,\n            prevTimeX: 0,\n            prevTimeY: 0,\n\n            start: function (interaction) {\n                autoScroll.isScrolling = true;\n                cancelFrame(autoScroll.i);\n\n                autoScroll.interaction = interaction;\n                autoScroll.prevTimeX = new Date().getTime();\n                autoScroll.prevTimeY = new Date().getTime();\n                autoScroll.i = reqFrame(autoScroll.scroll);\n            },\n\n            stop: function () {\n                autoScroll.isScrolling = false;\n                cancelFrame(autoScroll.i);\n            }\n        },\n\n        // Does the browser support touch input?\n        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\n        // Does the browser support PointerEvents\n        supportsPointerEvent = !!PointerEvent,\n\n        // Less Precision with touch input\n        margin = supportsTouch || supportsPointerEvent? 20: 10,\n\n        pointerMoveTolerance = 1,\n\n        // for ignoring browser's simulated mouse events\n        prevTouchTime = 0,\n\n        // Allow this many interactions to happen simultaneously\n        maxInteractions = Infinity,\n\n        // Check if is IE9 or older\n        actionCursors = (document.all && !window.atob) ? {\n            drag    : 'move',\n            resizex : 'e-resize',\n            resizey : 's-resize',\n            resizexy: 'se-resize',\n\n            resizetop        : 'n-resize',\n            resizeleft       : 'w-resize',\n            resizebottom     : 's-resize',\n            resizeright      : 'e-resize',\n            resizetopleft    : 'se-resize',\n            resizebottomright: 'se-resize',\n            resizetopright   : 'ne-resize',\n            resizebottomleft : 'ne-resize',\n\n            gesture : ''\n        } : {\n            drag    : 'move',\n            resizex : 'ew-resize',\n            resizey : 'ns-resize',\n            resizexy: 'nwse-resize',\n\n            resizetop        : 'ns-resize',\n            resizeleft       : 'ew-resize',\n            resizebottom     : 'ns-resize',\n            resizeright      : 'ew-resize',\n            resizetopleft    : 'nwse-resize',\n            resizebottomright: 'nwse-resize',\n            resizetopright   : 'nesw-resize',\n            resizebottomleft : 'nesw-resize',\n\n            gesture : ''\n        },\n\n        actionIsEnabled = {\n            drag   : true,\n            resize : true,\n            gesture: true\n        },\n\n        // because Webkit and Opera still use 'mousewheel' event type\n        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\n        eventTypes = [\n            'dragstart',\n            'dragmove',\n            'draginertiastart',\n            'dragend',\n            'dragenter',\n            'dragleave',\n            'dropactivate',\n            'dropdeactivate',\n            'dropmove',\n            'drop',\n            'resizestart',\n            'resizemove',\n            'resizeinertiastart',\n            'resizeend',\n            'gesturestart',\n            'gesturemove',\n            'gestureinertiastart',\n            'gestureend',\n\n            'down',\n            'move',\n            'up',\n            'cancel',\n            'tap',\n            'doubletap',\n            'hold'\n        ],\n\n        globalEvents = {},\n\n        // Opera Mobile must be handled differently\n        isOperaMobile = navigator.appName == 'Opera' &&\n            supportsTouch &&\n            navigator.userAgent.match('Presto'),\n\n        // scrolling doesn't change the result of getClientRects on iOS 7\n        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n                         && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n        // prefix matchesSelector\n        prefixedMatchesSelector = 'matches' in Element.prototype?\n                'matches': 'webkitMatchesSelector' in Element.prototype?\n                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n                            'oMatchesSelector': 'msMatchesSelector',\n\n        // will be polyfill function if browser is IE8\n        ie8MatchesSelector,\n\n        // native requestAnimationFrame or polyfill\n        reqFrame = realWindow.requestAnimationFrame,\n        cancelFrame = realWindow.cancelAnimationFrame,\n\n        // Events wrapper\n        events = (function () {\n            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n                on             = useAttachEvent? 'on': '',\n\n                elements          = [],\n                targets           = [],\n                attachedListeners = [];\n\n            function add (element, type, listener, useCapture) {\n                var elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex];\n\n                if (!target) {\n                    target = {\n                        events: {},\n                        typeCount: 0\n                    };\n\n                    elementIndex = elements.push(element) - 1;\n                    targets.push(target);\n\n                    attachedListeners.push((useAttachEvent ? {\n                            supplied: [],\n                            wrapped : [],\n                            useCount: []\n                        } : null));\n                }\n\n                if (!target.events[type]) {\n                    target.events[type] = [];\n                    target.typeCount++;\n                }\n\n                if (!contains(target.events[type], listener)) {\n                    var ret;\n\n                    if (useAttachEvent) {\n                        var listeners = attachedListeners[elementIndex],\n                            listenerIndex = indexOf(listeners.supplied, listener);\n\n                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n                            if (!event.immediatePropagationStopped) {\n                                event.target = event.srcElement;\n                                event.currentTarget = element;\n\n                                event.preventDefault = event.preventDefault || preventDef;\n                                event.stopPropagation = event.stopPropagation || stopProp;\n                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n                                if (/mouse|click/.test(event.type)) {\n                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n                                }\n\n                                listener(event);\n                            }\n                        };\n\n                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\n                        if (listenerIndex === -1) {\n                            listeners.supplied.push(listener);\n                            listeners.wrapped.push(wrapped);\n                            listeners.useCount.push(1);\n                        }\n                        else {\n                            listeners.useCount[listenerIndex]++;\n                        }\n                    }\n                    else {\n                        ret = element[addEvent](type, listener, useCapture || false);\n                    }\n                    target.events[type].push(listener);\n\n                    return ret;\n                }\n            }\n\n            function remove (element, type, listener, useCapture) {\n                var i,\n                    elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex],\n                    listeners,\n                    listenerIndex,\n                    wrapped = listener;\n\n                if (!target || !target.events) {\n                    return;\n                }\n\n                if (useAttachEvent) {\n                    listeners = attachedListeners[elementIndex];\n                    listenerIndex = indexOf(listeners.supplied, listener);\n                    wrapped = listeners.wrapped[listenerIndex];\n                }\n\n                if (type === 'all') {\n                    for (type in target.events) {\n                        if (target.events.hasOwnProperty(type)) {\n                            remove(element, type, 'all');\n                        }\n                    }\n                    return;\n                }\n\n                if (target.events[type]) {\n                    var len = target.events[type].length;\n\n                    if (listener === 'all') {\n                        for (i = 0; i < len; i++) {\n                            remove(element, type, target.events[type][i], Boolean(useCapture));\n                        }\n                        return;\n                    } else {\n                        for (i = 0; i < len; i++) {\n                            if (target.events[type][i] === listener) {\n                                element[removeEvent](on + type, wrapped, useCapture || false);\n                                target.events[type].splice(i, 1);\n\n                                if (useAttachEvent && listeners) {\n                                    listeners.useCount[listenerIndex]--;\n                                    if (listeners.useCount[listenerIndex] === 0) {\n                                        listeners.supplied.splice(listenerIndex, 1);\n                                        listeners.wrapped.splice(listenerIndex, 1);\n                                        listeners.useCount.splice(listenerIndex, 1);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n                    }\n\n                    if (target.events[type] && target.events[type].length === 0) {\n                        target.events[type] = null;\n                        target.typeCount--;\n                    }\n                }\n\n                if (!target.typeCount) {\n                    targets.splice(elementIndex, 1);\n                    elements.splice(elementIndex, 1);\n                    attachedListeners.splice(elementIndex, 1);\n                }\n            }\n\n            function preventDef () {\n                this.returnValue = false;\n            }\n\n            function stopProp () {\n                this.cancelBubble = true;\n            }\n\n            function stopImmProp () {\n                this.cancelBubble = true;\n                this.immediatePropagationStopped = true;\n            }\n\n            return {\n                add: add,\n                remove: remove,\n                useAttachEvent: useAttachEvent,\n\n                _elements: elements,\n                _targets: targets,\n                _attachedListeners: attachedListeners\n            };\n        }());\n\n    function blank () {}\n\n    function isElement (o) {\n        if (!o || (typeof o !== 'object')) { return false; }\n\n        var _window = getWindow(o) || window;\n\n        return (/object|function/.test(typeof _window.Element)\n            ? o instanceof _window.Element //DOM2\n            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n    }\n    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n    function isArray (thing) {\n        return isObject(thing)\n                && (typeof thing.length !== undefined)\n                && isFunction(thing.splice);\n    }\n    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n    function isFunction (thing) { return typeof thing === 'function'; }\n    function isNumber   (thing) { return typeof thing === 'number'  ; }\n    function isBool     (thing) { return typeof thing === 'boolean' ; }\n    function isString   (thing) { return typeof thing === 'string'  ; }\n\n    function trySelector (value) {\n        if (!isString(value)) { return false; }\n\n        // an exception will be raised if it is invalid\n        document.querySelector(value);\n        return true;\n    }\n\n    function extend (dest, source) {\n        for (var prop in source) {\n            dest[prop] = source[prop];\n        }\n        return dest;\n    }\n\n    var prefixedPropREs = {\n      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n    };\n\n    function pointerExtend (dest, source) {\n        for (var prop in source) {\n          var deprecated = false;\n\n          // skip deprecated prefixed properties\n          for (var vendor in prefixedPropREs) {\n            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n              deprecated = true;\n              break;\n            }\n          }\n\n          if (!deprecated) {\n            dest[prop] = source[prop];\n          }\n        }\n        return dest;\n    }\n\n    function copyCoords (dest, src) {\n        dest.page = dest.page || {};\n        dest.page.x = src.page.x;\n        dest.page.y = src.page.y;\n\n        dest.client = dest.client || {};\n        dest.client.x = src.client.x;\n        dest.client.y = src.client.y;\n\n        dest.timeStamp = src.timeStamp;\n    }\n\n    function setEventXY (targetObj, pointers, interaction) {\n        var pointer = (pointers.length > 1\n                       ? pointerAverage(pointers)\n                       : pointers[0]);\n\n        getPageXY(pointer, tmpXY, interaction);\n        targetObj.page.x = tmpXY.x;\n        targetObj.page.y = tmpXY.y;\n\n        getClientXY(pointer, tmpXY, interaction);\n        targetObj.client.x = tmpXY.x;\n        targetObj.client.y = tmpXY.y;\n\n        targetObj.timeStamp = new Date().getTime();\n    }\n\n    function setEventDeltas (targetObj, prev, cur) {\n        targetObj.page.x     = cur.page.x      - prev.page.x;\n        targetObj.page.y     = cur.page.y      - prev.page.y;\n        targetObj.client.x   = cur.client.x    - prev.client.x;\n        targetObj.client.y   = cur.client.y    - prev.client.y;\n        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\n        // set pointer velocity\n        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n        targetObj.page.vx      = targetObj.page.x / dt;\n        targetObj.page.vy      = targetObj.page.y / dt;\n\n        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n        targetObj.client.vx    = targetObj.client.x / dt;\n        targetObj.client.vy    = targetObj.client.y / dt;\n    }\n\n    function isNativePointer (pointer) {\n        return (pointer instanceof window.Event\n            || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n    }\n\n    // Get specified X/Y coords for mouse or event.touches[0]\n    function getXY (type, pointer, xy) {\n        xy = xy || {};\n        type = type || 'page';\n\n        xy.x = pointer[type + 'X'];\n        xy.y = pointer[type + 'Y'];\n\n        return xy;\n    }\n\n    function getPageXY (pointer, page) {\n        page = page || {};\n\n        // Opera Mobile handles the viewport and scrolling oddly\n        if (isOperaMobile && isNativePointer(pointer)) {\n            getXY('screen', pointer, page);\n\n            page.x += window.scrollX;\n            page.y += window.scrollY;\n        }\n        else {\n            getXY('page', pointer, page);\n        }\n\n        return page;\n    }\n\n    function getClientXY (pointer, client) {\n        client = client || {};\n\n        if (isOperaMobile && isNativePointer(pointer)) {\n            // Opera Mobile handles the viewport and scrolling oddly\n            getXY('screen', pointer, client);\n        }\n        else {\n          getXY('client', pointer, client);\n        }\n\n        return client;\n    }\n\n    function getScrollXY (win) {\n        win = win || window;\n        return {\n            x: win.scrollX || win.document.documentElement.scrollLeft,\n            y: win.scrollY || win.document.documentElement.scrollTop\n        };\n    }\n\n    function getPointerId (pointer) {\n        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n    }\n\n    function getActualElement (element) {\n        return (element instanceof SVGElementInstance\n            ? element.correspondingUseElement\n            : element);\n    }\n\n    function getWindow (node) {\n        if (isWindow(node)) {\n            return node;\n        }\n\n        var rootNode = (node.ownerDocument || node);\n\n        return rootNode.defaultView || rootNode.parentWindow || window;\n    }\n\n    function getElementClientRect (element) {\n        var clientRect = (element instanceof SVGElement\n                            ? element.getBoundingClientRect()\n                            : element.getClientRects()[0]);\n\n        return clientRect && {\n            left  : clientRect.left,\n            right : clientRect.right,\n            top   : clientRect.top,\n            bottom: clientRect.bottom,\n            width : clientRect.width || clientRect.right - clientRect.left,\n            height: clientRect.height || clientRect.bottom - clientRect.top\n        };\n    }\n\n    function getElementRect (element) {\n        var clientRect = getElementClientRect(element);\n\n        if (!isIOS7 && clientRect) {\n            var scroll = getScrollXY(getWindow(element));\n\n            clientRect.left   += scroll.x;\n            clientRect.right  += scroll.x;\n            clientRect.top    += scroll.y;\n            clientRect.bottom += scroll.y;\n        }\n\n        return clientRect;\n    }\n\n    function getTouchPair (event) {\n        var touches = [];\n\n        // array of touches is supplied\n        if (isArray(event)) {\n            touches[0] = event[0];\n            touches[1] = event[1];\n        }\n        // an event\n        else {\n            if (event.type === 'touchend') {\n                if (event.touches.length === 1) {\n                    touches[0] = event.touches[0];\n                    touches[1] = event.changedTouches[0];\n                }\n                else if (event.touches.length === 0) {\n                    touches[0] = event.changedTouches[0];\n                    touches[1] = event.changedTouches[1];\n                }\n            }\n            else {\n                touches[0] = event.touches[0];\n                touches[1] = event.touches[1];\n            }\n        }\n\n        return touches;\n    }\n\n    function pointerAverage (pointers) {\n        var average = {\n            pageX  : 0,\n            pageY  : 0,\n            clientX: 0,\n            clientY: 0,\n            screenX: 0,\n            screenY: 0\n        };\n        var prop;\n\n        for (var i = 0; i < pointers.length; i++) {\n            for (prop in average) {\n                average[prop] += pointers[i][prop];\n            }\n        }\n        for (prop in average) {\n            average[prop] /= pointers.length;\n        }\n\n        return average;\n    }\n\n    function touchBBox (event) {\n        if (!event.length && !(event.touches && event.touches.length > 1)) {\n            return;\n        }\n\n        var touches = getTouchPair(event),\n            minX = Math.min(touches[0].pageX, touches[1].pageX),\n            minY = Math.min(touches[0].pageY, touches[1].pageY),\n            maxX = Math.max(touches[0].pageX, touches[1].pageX),\n            maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n        return {\n            x: minX,\n            y: minY,\n            left: minX,\n            top: minY,\n            width: maxX - minX,\n            height: maxY - minY\n        };\n    }\n\n    function touchDistance (event, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event);\n\n\n        var dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY];\n\n        return hypot(dx, dy);\n    }\n\n    function touchAngle (event, prevAngle, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event),\n            dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY],\n            angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n        if (isNumber(prevAngle)) {\n            var dr = angle - prevAngle,\n                drClamped = dr % 360;\n\n            if (drClamped > 315) {\n                angle -= 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped > 135) {\n                angle -= 180 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -315) {\n                angle += 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -135) {\n                angle += 180 + (angle / 360)|0 * 360;\n            }\n        }\n\n        return  angle;\n    }\n\n    function getOriginXY (interactable, element) {\n        var origin = interactable\n                ? interactable.options.origin\n                : defaultOptions.origin;\n\n        if (origin === 'parent') {\n            origin = parentElement(element);\n        }\n        else if (origin === 'self') {\n            origin = interactable.getRect(element);\n        }\n        else if (trySelector(origin)) {\n            origin = closest(element, origin) || { x: 0, y: 0 };\n        }\n\n        if (isFunction(origin)) {\n            origin = origin(interactable && element);\n        }\n\n        if (isElement(origin))  {\n            origin = getElementRect(origin);\n        }\n\n        origin.x = ('x' in origin)? origin.x : origin.left;\n        origin.y = ('y' in origin)? origin.y : origin.top;\n\n        return origin;\n    }\n\n    // http://stackoverflow.com/a/5634528/2280888\n    function _getQBezierValue(t, p1, p2, p3) {\n        var iT = 1 - t;\n        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n    }\n\n    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n        return {\n            x:  _getQBezierValue(position, startX, cpX, endX),\n            y:  _getQBezierValue(position, startY, cpY, endY)\n        };\n    }\n\n    // http://gizma.com/easing/\n    function easeOutQuad (t, b, c, d) {\n        t /= d;\n        return -c * t*(t-2) + b;\n    }\n\n    function nodeContains (parent, child) {\n        while (child) {\n            if (child === parent) {\n                return true;\n            }\n\n            child = child.parentNode;\n        }\n\n        return false;\n    }\n\n    function closest (child, selector) {\n        var parent = parentElement(child);\n\n        while (isElement(parent)) {\n            if (matchesSelector(parent, selector)) { return parent; }\n\n            parent = parentElement(parent);\n        }\n\n        return null;\n    }\n\n    function parentElement (node) {\n        var parent = node.parentNode;\n\n        if (isDocFrag(parent)) {\n            // skip past #shado-root fragments\n            while ((parent = parent.host) && isDocFrag(parent)) {}\n\n            return parent;\n        }\n\n        return parent;\n    }\n\n    function inContext (interactable, element) {\n        return interactable._context === element.ownerDocument\n                || nodeContains(interactable._context, element);\n    }\n\n    function testIgnore (interactable, interactableElement, element) {\n        var ignoreFrom = interactable.options.ignoreFrom;\n\n        if (!ignoreFrom || !isElement(element)) { return false; }\n\n        if (isString(ignoreFrom)) {\n            return matchesUpTo(element, ignoreFrom, interactableElement);\n        }\n        else if (isElement(ignoreFrom)) {\n            return nodeContains(ignoreFrom, element);\n        }\n\n        return false;\n    }\n\n    function testAllow (interactable, interactableElement, element) {\n        var allowFrom = interactable.options.allowFrom;\n\n        if (!allowFrom) { return true; }\n\n        if (!isElement(element)) { return false; }\n\n        if (isString(allowFrom)) {\n            return matchesUpTo(element, allowFrom, interactableElement);\n        }\n        else if (isElement(allowFrom)) {\n            return nodeContains(allowFrom, element);\n        }\n\n        return false;\n    }\n\n    function checkAxis (axis, interactable) {\n        if (!interactable) { return false; }\n\n        var thisAxis = interactable.options.drag.axis;\n\n        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n    }\n\n    function checkSnap (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return options[action].snap && options[action].snap.enabled;\n    }\n\n    function checkRestrict (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].restrict && options[action].restrict.enabled;\n    }\n\n    function checkAutoScroll (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].autoScroll && options[action].autoScroll.enabled;\n    }\n\n    function withinInteractionLimit (interactable, element, action) {\n        var options = interactable.options,\n            maxActions = options[action.name].max,\n            maxPerElement = options[action.name].maxPerElement,\n            activeInteractions = 0,\n            targetCount = 0,\n            targetElementCount = 0;\n\n        for (var i = 0, len = interactions.length; i < len; i++) {\n            var interaction = interactions[i],\n                otherAction = interaction.prepared.name,\n                active = interaction.interacting();\n\n            if (!active) { continue; }\n\n            activeInteractions++;\n\n            if (activeInteractions >= maxInteractions) {\n                return false;\n            }\n\n            if (interaction.target !== interactable) { continue; }\n\n            targetCount += (otherAction === action.name)|0;\n\n            if (targetCount >= maxActions) {\n                return false;\n            }\n\n            if (interaction.element === element) {\n                targetElementCount++;\n\n                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n                    return false;\n                }\n            }\n        }\n\n        return maxInteractions > 0;\n    }\n\n    // Test for the element that's \"above\" all other qualifiers\n    function indexOfDeepestElement (elements) {\n        var dropzone,\n            deepestZone = elements[0],\n            index = deepestZone? 0: -1,\n            parent,\n            deepestZoneParents = [],\n            dropzoneParents = [],\n            child,\n            i,\n            n;\n\n        for (i = 1; i < elements.length; i++) {\n            dropzone = elements[i];\n\n            // an element might belong to multiple selector dropzones\n            if (!dropzone || dropzone === deepestZone) {\n                continue;\n            }\n\n            if (!deepestZone) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            // check if the deepest or current are document.documentElement or document.rootElement\n            // - if the current dropzone is, do nothing and continue\n            if (dropzone.parentNode === dropzone.ownerDocument) {\n                continue;\n            }\n            // - if deepest is, update with the current dropzone and continue to next\n            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            if (!deepestZoneParents.length) {\n                parent = deepestZone;\n                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n                    deepestZoneParents.unshift(parent);\n                    parent = parent.parentNode;\n                }\n            }\n\n            // if this element is an svg element and the current deepest is\n            // an HTMLElement\n            if (deepestZone instanceof HTMLElement\n                && dropzone instanceof SVGElement\n                && !(dropzone instanceof SVGSVGElement)) {\n\n                if (dropzone === deepestZone.parentNode) {\n                    continue;\n                }\n\n                parent = dropzone.ownerSVGElement;\n            }\n            else {\n                parent = dropzone;\n            }\n\n            dropzoneParents = [];\n\n            while (parent.parentNode !== parent.ownerDocument) {\n                dropzoneParents.unshift(parent);\n                parent = parent.parentNode;\n            }\n\n            n = 0;\n\n            // get (position of last common ancestor) + 1\n            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n                n++;\n            }\n\n            var parents = [\n                dropzoneParents[n - 1],\n                dropzoneParents[n],\n                deepestZoneParents[n]\n            ];\n\n            child = parents[0].lastChild;\n\n            while (child) {\n                if (child === parents[1]) {\n                    deepestZone = dropzone;\n                    index = i;\n                    deepestZoneParents = [];\n\n                    break;\n                }\n                else if (child === parents[2]) {\n                    break;\n                }\n\n                child = child.previousSibling;\n            }\n        }\n\n        return index;\n    }\n\n    function Interaction () {\n        this.target          = null; // current interactable being interacted with\n        this.element         = null; // the target element of the interactable\n        this.dropTarget      = null; // the dropzone a drag target might be dropped into\n        this.dropElement     = null; // the element at the time of checking\n        this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n        this.prevDropElement = null; // the element at the time of checking\n\n        this.prepared        = {     // action that's ready to be fired on next move event\n            name : null,\n            axis : null,\n            edges: null\n        };\n\n        this.matches         = [];   // all selectors that are matched by target element\n        this.matchElements   = [];   // corresponding elements\n\n        this.inertiaStatus = {\n            active       : false,\n            smoothEnd    : false,\n            ending       : false,\n\n            startEvent: null,\n            upCoords: {},\n\n            xe: 0, ye: 0,\n            sx: 0, sy: 0,\n\n            t0: 0,\n            vx0: 0, vys: 0,\n            duration: 0,\n\n            resumeDx: 0,\n            resumeDy: 0,\n\n            lambda_v0: 0,\n            one_ve_v0: 0,\n            i  : null\n        };\n\n        if (isFunction(Function.prototype.bind)) {\n            this.boundInertiaFrame = this.inertiaFrame.bind(this);\n            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n        }\n        else {\n            var that = this;\n\n            this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n        }\n\n        this.activeDrops = {\n            dropzones: [],      // the dropzones that are mentioned below\n            elements : [],      // elements of dropzones that accept the target draggable\n            rects    : []       // the rects of the elements mentioned above\n        };\n\n        // keep track of added pointers\n        this.pointers    = [];\n        this.pointerIds  = [];\n        this.downTargets = [];\n        this.downTimes   = [];\n        this.holdTimers  = [];\n\n        // Previous native pointer move event coordinates\n        this.prevCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n        // current native pointer move event coordinates\n        this.curCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Starting InteractEvent pointer coordinates\n        this.startCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Change in coordinates and time of the pointer\n        this.pointerDelta = {\n            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            timeStamp: 0\n        };\n\n        this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n        this.downPointer = {};\n\n        this._eventTarget    = null;\n        this._curEventTarget = null;\n\n        this.prevEvent = null;      // previous action event\n        this.tapTime   = 0;         // time of the most recent tap event\n        this.prevTap   = null;\n\n        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.snapOffsets    = [];\n\n        this.gesture = {\n            start: { x: 0, y: 0 },\n\n            startDistance: 0,   // distance between two touches of touchStart\n            prevDistance : 0,\n            distance     : 0,\n\n            scale: 1,           // gesture.distance / gesture.startDistance\n\n            startAngle: 0,      // angle of line joining two touches\n            prevAngle : 0       // angle of the previous gesture event\n        };\n\n        this.snapStatus = {\n            x       : 0, y       : 0,\n            dx      : 0, dy      : 0,\n            realX   : 0, realY   : 0,\n            snappedX: 0, snappedY: 0,\n            targets : [],\n            locked  : false,\n            changed : false\n        };\n\n        this.restrictStatus = {\n            dx         : 0, dy         : 0,\n            restrictedX: 0, restrictedY: 0,\n            snap       : null,\n            restricted : false,\n            changed    : false\n        };\n\n        this.restrictStatus.snap = this.snapStatus;\n\n        this.pointerIsDown   = false;\n        this.pointerWasMoved = false;\n        this.gesturing       = false;\n        this.dragging        = false;\n        this.resizing        = false;\n        this.resizeAxes      = 'xy';\n\n        this.mouse = false;\n\n        interactions.push(this);\n    }\n\n    Interaction.prototype = {\n        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\n        pointerOver: function (pointer, event, eventTarget) {\n            if (this.prepared.name || !this.mouse) { return; }\n\n            var curMatches = [],\n                curMatchElements = [],\n                prevTargetElement = this.element;\n\n            this.addPointer(pointer);\n\n            if (this.target\n                && (testIgnore(this.target, this.element, eventTarget)\n                    || !testAllow(this.target, this.element, eventTarget))) {\n                // if the eventTarget should be ignored or shouldn't be allowed\n                // clear the previous target\n                this.target = null;\n                this.element = null;\n                this.matches = [];\n                this.matchElements = [];\n            }\n\n            var elementInteractable = interactables.get(eventTarget),\n                elementAction = (elementInteractable\n                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)\n                                 && testAllow(elementInteractable, eventTarget, eventTarget)\n                                 && validateAction(\n                                     elementInteractable.getAction(pointer, event, this, eventTarget),\n                                     elementInteractable));\n\n            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n                 elementAction = null;\n            }\n\n            function pushCurMatches (interactable, selector) {\n                if (interactable\n                    && inContext(interactable, eventTarget)\n                    && !testIgnore(interactable, eventTarget, eventTarget)\n                    && testAllow(interactable, eventTarget, eventTarget)\n                    && matchesSelector(eventTarget, selector)) {\n\n                    curMatches.push(interactable);\n                    curMatchElements.push(eventTarget);\n                }\n            }\n\n            if (elementAction) {\n                this.target = elementInteractable;\n                this.element = eventTarget;\n                this.matches = [];\n                this.matchElements = [];\n            }\n            else {\n                interactables.forEachSelector(pushCurMatches);\n\n                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n                    this.matches = curMatches;\n                    this.matchElements = curMatchElements;\n\n                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n                    events.add(eventTarget,\n                                        PointerEvent? pEventTypes.move : 'mousemove',\n                                        listeners.pointerHover);\n                }\n                else if (this.target) {\n                    if (nodeContains(prevTargetElement, eventTarget)) {\n                        this.pointerHover(pointer, event, this.matches, this.matchElements);\n                        events.add(this.element,\n                                            PointerEvent? pEventTypes.move : 'mousemove',\n                                            listeners.pointerHover);\n                    }\n                    else {\n                        this.target = null;\n                        this.element = null;\n                        this.matches = [];\n                        this.matchElements = [];\n                    }\n                }\n            }\n        },\n\n        // Check what action would be performed on pointerMove target if a mouse\n        // button were pressed and change the cursor accordingly\n        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n            var target = this.target;\n\n            if (!this.prepared.name && this.mouse) {\n\n                var action;\n\n                // update pointer coords for defaultActionChecker to use\n                this.setEventXY(this.curCoords, [pointer]);\n\n                if (matches) {\n                    action = this.validateSelector(pointer, event, matches, matchElements);\n                }\n                else if (target) {\n                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n                }\n\n                if (target && target.options.styleCursor) {\n                    if (action) {\n                        target._doc.documentElement.style.cursor = getActionCursor(action);\n                    }\n                    else {\n                        target._doc.documentElement.style.cursor = '';\n                    }\n                }\n            }\n            else if (this.prepared.name) {\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        pointerOut: function (pointer, event, eventTarget) {\n            if (this.prepared.name) { return; }\n\n            // Remove temporary event listeners for selector Interactables\n            if (!interactables.get(eventTarget)) {\n                events.remove(eventTarget,\n                                       PointerEvent? pEventTypes.move : 'mousemove',\n                                       listeners.pointerHover);\n            }\n\n            if (this.target && this.target.options.styleCursor && !this.interacting()) {\n                this.target._doc.documentElement.style.cursor = '';\n            }\n        },\n\n        selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n            var that = this,\n                // copy event to be used in timeout for IE8\n                eventCopy = events.useAttachEvent? extend({}, event) : event,\n                element = eventTarget,\n                pointerIndex = this.addPointer(pointer),\n                action;\n\n            this.holdTimers[pointerIndex] = setTimeout(function () {\n                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n            }, defaultOptions._holdDuration);\n\n            this.pointerIsDown = true;\n\n            // Check if the down event hits the current inertia target\n            if (this.inertiaStatus.active && this.target.selector) {\n                // climb up the DOM tree from the event target\n                while (isElement(element)) {\n\n                    // if this element is the current inertia target element\n                    if (element === this.element\n                        // and the prospective action is the same as the ongoing one\n                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n                        // stop inertia so that the next move will be a normal one\n                        cancelFrame(this.inertiaStatus.i);\n                        this.inertiaStatus.active = false;\n\n                        this.collectEventTargets(pointer, event, eventTarget, 'down');\n                        return;\n                    }\n                    element = parentElement(element);\n                }\n            }\n\n            // do nothing if interacting\n            if (this.interacting()) {\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n                return;\n            }\n\n            function pushMatches (interactable, selector, context) {\n                var elements = ie8MatchesSelector\n                    ? context.querySelectorAll(selector)\n                    : undefined;\n\n                if (inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, elements)) {\n\n                    that.matches.push(interactable);\n                    that.matchElements.push(element);\n                }\n            }\n\n            // update pointer coords for defaultActionChecker to use\n            this.setEventXY(this.curCoords, [pointer]);\n            this.downEvent = event;\n\n            while (isElement(element) && !action) {\n                this.matches = [];\n                this.matchElements = [];\n\n                interactables.forEachSelector(pushMatches);\n\n                action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n                element = parentElement(element);\n            }\n\n            if (action) {\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\n                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n            }\n            else {\n                // do these now since pointerDown isn't being called from here\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.curCoords);\n                this.pointerWasMoved = false;\n            }\n\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n        },\n\n        // Determine action to be performed on next pointerMove and add appropriate\n        // style and event Listeners\n        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n\n                return;\n            }\n\n            this.pointerIsDown = true;\n            this.downEvent = event;\n\n            var pointerIndex = this.addPointer(pointer),\n                action;\n\n            // If it is the second touch of a multi-touch gesture, keep the\n            // target the same and get a new action if a target was set by the\n            // first touch\n            if (this.pointerIds.length > 1 && this.target._element === this.element) {\n                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n                if (withinInteractionLimit(this.target, this.element, newAction)) {\n                    action = newAction;\n                }\n\n                this.prepared.name = null;\n            }\n            // Otherwise, set the target if there is no action prepared\n            else if (!this.prepared.name) {\n                var interactable = interactables.get(curEventTarget);\n\n                if (interactable\n                    && !testIgnore(interactable, curEventTarget, eventTarget)\n                    && testAllow(interactable, curEventTarget, eventTarget)\n                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n                    && withinInteractionLimit(interactable, curEventTarget, action)) {\n                    this.target = interactable;\n                    this.element = curEventTarget;\n                }\n            }\n\n            var target = this.target,\n                options = target && target.options;\n\n            if (target && (forceAction || !this.prepared.name)) {\n                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n                this.setEventXY(this.startCoords, this.pointers);\n\n                if (!action) { return; }\n\n                if (options.styleCursor) {\n                    target._doc.documentElement.style.cursor = getActionCursor(action);\n                }\n\n                this.resizeAxes = action.name === 'resize'? action.axis : null;\n\n                if (action === 'gesture' && this.pointerIds.length < 2) {\n                    action = null;\n                }\n\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.snapStatus.snappedX = this.snapStatus.snappedY =\n                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.startCoords);\n                this.pointerWasMoved = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n            // if inertia is active try to resume action\n            else if (this.inertiaStatus.active\n                && curEventTarget === this.element\n                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n                cancelFrame(this.inertiaStatus.i);\n                this.inertiaStatus.active = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        setModifications: function (coords, preEnd) {\n            var target         = this.target,\n                shouldMove     = true,\n                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\n            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n            }\n            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n                shouldMove = false;\n            }\n\n            return shouldMove;\n        },\n\n        setStartOffsets: function (action, interactable, element) {\n            var rect = interactable.getRect(element),\n                origin = getOriginXY(interactable, element),\n                snap = interactable.options[this.prepared.name].snap,\n                restrict = interactable.options[this.prepared.name].restrict,\n                width, height;\n\n            if (rect) {\n                this.startOffset.left = this.startCoords.page.x - rect.left;\n                this.startOffset.top  = this.startCoords.page.y - rect.top;\n\n                this.startOffset.right  = rect.right  - this.startCoords.page.x;\n                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n                if ('width' in rect) { width = rect.width; }\n                else { width = rect.right - rect.left; }\n                if ('height' in rect) { height = rect.height; }\n                else { height = rect.bottom - rect.top; }\n            }\n            else {\n                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n            }\n\n            this.snapOffsets.splice(0);\n\n            var snapOffset = snap && snap.offset === 'startCoords'\n                                ? {\n                                    x: this.startCoords.page.x - origin.x,\n                                    y: this.startCoords.page.y - origin.y\n                                }\n                                : snap && snap.offset || { x: 0, y: 0 };\n\n            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n                for (var i = 0; i < snap.relativePoints.length; i++) {\n                    this.snapOffsets.push({\n                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n                    });\n                }\n            }\n            else {\n                this.snapOffsets.push(snapOffset);\n            }\n\n            if (rect && restrict.elementRect) {\n                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\n                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n            }\n            else {\n                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n            }\n        },\n\n        /*\\\n         * Interaction.start\n         [ method ]\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate number\n         * of pointers must be held down – 1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         - action       (object)  The action to be performed - drag, resize, etc.\n         - interactable (Interactable) The Interactable to target\n         - element      (Element) The DOM Element to target\n         = (object) interact\n         **\n         | interact(target)\n         |   .draggable({\n         |     // disable the default drag start by down->move\n         |     manualStart: true\n         |   })\n         |   // start dragging after the user holds the pointer down\n         |   .on('hold', function (event) {\n         |     var interaction = event.interaction;\n         |\n         |     if (!interaction.interacting()) {\n         |       interaction.start({ name: 'drag' },\n         |                         event.interactable,\n         |                         event.currentTarget);\n         |     }\n         | });\n        \\*/\n        start: function (action, interactable, element) {\n            if (this.interacting()\n                || !this.pointerIsDown\n                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n                return;\n            }\n\n            // if this interaction had been removed after stopping\n            // add it back\n            if (indexOf(interactions, this) === -1) {\n                interactions.push(this);\n            }\n\n            // set the startCoords if there was no prepared action\n            if (!this.prepared.name) {\n                this.setEventXY(this.startCoords);\n            }\n\n            this.prepared.name  = action.name;\n            this.prepared.axis  = action.axis;\n            this.prepared.edges = action.edges;\n            this.target         = interactable;\n            this.element        = element;\n\n            this.setStartOffsets(action.name, interactable, element);\n            this.setModifications(this.startCoords.page);\n\n            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n        },\n\n        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n            if (this.inertiaStatus.active) {\n                var pageUp   = this.inertiaStatus.upCoords.page;\n                var clientUp = this.inertiaStatus.upCoords.client;\n\n                var inertiaPosition = {\n                    pageX  : pageUp.x   + this.inertiaStatus.sx,\n                    pageY  : pageUp.y   + this.inertiaStatus.sy,\n                    clientX: clientUp.x + this.inertiaStatus.sx,\n                    clientY: clientUp.y + this.inertiaStatus.sy\n                };\n\n                this.setEventXY(this.curCoords, [inertiaPosition]);\n            }\n            else {\n                this.recordPointer(pointer);\n                this.setEventXY(this.curCoords, this.pointers);\n            }\n\n            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                                 && this.curCoords.page.y === this.prevCoords.page.y\n                                 && this.curCoords.client.x === this.prevCoords.client.x\n                                 && this.curCoords.client.y === this.prevCoords.client.y);\n\n            var dx, dy,\n                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // register movement greater than pointerMoveTolerance\n            if (this.pointerIsDown && !this.pointerWasMoved) {\n                dx = this.curCoords.client.x - this.startCoords.client.x;\n                dy = this.curCoords.client.y - this.startCoords.client.y;\n\n                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n            }\n\n            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n                if (this.pointerIsDown) {\n                    clearTimeout(this.holdTimers[pointerIndex]);\n                }\n\n                this.collectEventTargets(pointer, event, eventTarget, 'move');\n            }\n\n            if (!this.pointerIsDown) { return; }\n\n            if (duplicateMove && this.pointerWasMoved && !preEnd) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n                return;\n            }\n\n            // set pointer coordinate, time changes and speeds\n            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n            if (!this.prepared.name) { return; }\n\n            if (this.pointerWasMoved\n                // ignore movement while inertia is active\n                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\n                // if just starting an action, calculate the pointer speed now\n                if (!this.interacting()) {\n                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n                    // check if a drag is in the correct axis\n                    if (this.prepared.name === 'drag') {\n                        var absX = Math.abs(dx),\n                            absY = Math.abs(dy),\n                            targetAxis = this.target.options.drag.axis,\n                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n                        // if the movement isn't in the axis of the interactable\n                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n                            // cancel the prepared action\n                            this.prepared.name = null;\n\n                            // then try to get a drag from another ineractable\n\n                            var element = eventTarget;\n\n                            // check element interactables\n                            while (isElement(element)) {\n                                var elementInteractable = interactables.get(element);\n\n                                if (elementInteractable\n                                    && elementInteractable !== this.target\n                                    && !elementInteractable.options.drag.manualStart\n                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n                                    && checkAxis(axis, elementInteractable)) {\n\n                                    this.prepared.name = 'drag';\n                                    this.target = elementInteractable;\n                                    this.element = element;\n                                    break;\n                                }\n\n                                element = parentElement(element);\n                            }\n\n                            // if there's no drag from element interactables,\n                            // check the selector interactables\n                            if (!this.prepared.name) {\n                                var thisInteraction = this;\n\n                                var getDraggable = function (interactable, selector, context) {\n                                    var elements = ie8MatchesSelector\n                                        ? context.querySelectorAll(selector)\n                                        : undefined;\n\n                                    if (interactable === thisInteraction.target) { return; }\n\n                                    if (inContext(interactable, eventTarget)\n                                        && !interactable.options.drag.manualStart\n                                        && !testIgnore(interactable, element, eventTarget)\n                                        && testAllow(interactable, element, eventTarget)\n                                        && matchesSelector(element, selector, elements)\n                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n                                        && checkAxis(axis, interactable)\n                                        && withinInteractionLimit(interactable, element, 'drag')) {\n\n                                        return interactable;\n                                    }\n                                };\n\n                                element = eventTarget;\n\n                                while (isElement(element)) {\n                                    var selectorInteractable = interactables.forEachSelector(getDraggable);\n\n                                    if (selectorInteractable) {\n                                        this.prepared.name = 'drag';\n                                        this.target = selectorInteractable;\n                                        this.element = element;\n                                        break;\n                                    }\n\n                                    element = parentElement(element);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                var starting = !!this.prepared.name && !this.interacting();\n\n                if (starting\n                    && (this.target.options[this.prepared.name].manualStart\n                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n                    this.stop(event);\n                    return;\n                }\n\n                if (this.prepared.name && this.target) {\n                    if (starting) {\n                        this.start(this.prepared, this.target, this.element);\n                    }\n\n                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\n                    // move if snapping or restriction doesn't prevent it\n                    if (shouldMove || starting) {\n                        this.prevEvent = this[this.prepared.name + 'Move'](event);\n                    }\n\n                    this.checkAndPreventDefault(event, this.target, this.element);\n                }\n            }\n\n            copyCoords(this.prevCoords, this.curCoords);\n\n            if (this.dragging || this.resizing) {\n                this.autoScrollMove(pointer);\n            }\n        },\n\n        dragStart: function (event) {\n            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\n            this.dragging = true;\n            this.target.fire(dragEvent);\n\n            // reset active dropzones\n            this.activeDrops.dropzones = [];\n            this.activeDrops.elements  = [];\n            this.activeDrops.rects     = [];\n\n            if (!this.dynamicDrop) {\n                this.setActiveDrops(this.element);\n            }\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            if (dropEvents.activate) {\n                this.fireActiveDrops(dropEvents.activate);\n            }\n\n            return dragEvent;\n        },\n\n        dragMove: function (event) {\n            var target = this.target,\n                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n                draggableElement = this.element,\n                drop = this.getDrop(dragEvent, event, draggableElement);\n\n            this.dropTarget = drop.dropzone;\n            this.dropElement = drop.element;\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            target.fire(dragEvent);\n\n            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\n            this.prevDropTarget  = this.dropTarget;\n            this.prevDropElement = this.dropElement;\n\n            return dragEvent;\n        },\n\n        resizeStart: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\n            if (this.prepared.edges) {\n                var startRect = this.target.getRect(this.element);\n\n                /*\n                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n                 * on the active edges and the edge being interacted with.\n                 */\n                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n                    var linkedEdges = extend({}, this.prepared.edges);\n\n                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n                    this.prepared._linkedEdges = linkedEdges;\n                }\n                else {\n                    this.prepared._linkedEdges = null;\n                }\n\n                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n                if (this.target.options.resize.preserveAspectRatio) {\n                    this.resizeStartAspectRatio = startRect.width / startRect.height;\n                }\n\n                this.resizeRects = {\n                    start     : startRect,\n                    current   : extend({}, startRect),\n                    restricted: extend({}, startRect),\n                    previous  : extend({}, startRect),\n                    delta     : {\n                        left: 0, right : 0, width : 0,\n                        top : 0, bottom: 0, height: 0\n                    }\n                };\n\n                resizeEvent.rect = this.resizeRects.restricted;\n                resizeEvent.deltaRect = this.resizeRects.delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            this.resizing = true;\n\n            return resizeEvent;\n        },\n\n        resizeMove: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\n            var edges = this.prepared.edges,\n                invert = this.target.options.resize.invert,\n                invertible = invert === 'reposition' || invert === 'negate';\n\n            if (edges) {\n                var dx = resizeEvent.dx,\n                    dy = resizeEvent.dy,\n\n                    start      = this.resizeRects.start,\n                    current    = this.resizeRects.current,\n                    restricted = this.resizeRects.restricted,\n                    delta      = this.resizeRects.delta,\n                    previous   = extend(this.resizeRects.previous, restricted),\n\n                    originalEdges = edges;\n\n                // `resize.preserveAspectRatio` takes precedence over `resize.square`\n                if (this.target.options.resize.preserveAspectRatio) {\n                    var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx / resizeStartAspectRatio;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n                }\n                else if (this.target.options.resize.square) {\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n                }\n\n                // update the 'current' rect without modifications\n                if (edges.top   ) { current.top    += dy; }\n                if (edges.bottom) { current.bottom += dy; }\n                if (edges.left  ) { current.left   += dx; }\n                if (edges.right ) { current.right  += dx; }\n\n                if (invertible) {\n                    // if invertible, copy the current rect\n                    extend(restricted, current);\n\n                    if (invert === 'reposition') {\n                        // swap edge values if necessary to keep width/height positive\n                        var swap;\n\n                        if (restricted.top > restricted.bottom) {\n                            swap = restricted.top;\n\n                            restricted.top = restricted.bottom;\n                            restricted.bottom = swap;\n                        }\n                        if (restricted.left > restricted.right) {\n                            swap = restricted.left;\n\n                            restricted.left = restricted.right;\n                            restricted.right = swap;\n                        }\n                    }\n                }\n                else {\n                    // if not invertible, restrict to minimum of 0x0 rect\n                    restricted.top    = Math.min(current.top, start.bottom);\n                    restricted.bottom = Math.max(current.bottom, start.top);\n                    restricted.left   = Math.min(current.left, start.right);\n                    restricted.right  = Math.max(current.right, start.left);\n                }\n\n                restricted.width  = restricted.right  - restricted.left;\n                restricted.height = restricted.bottom - restricted.top ;\n\n                for (var edge in restricted) {\n                    delta[edge] = restricted[edge] - previous[edge];\n                }\n\n                resizeEvent.edges = this.prepared.edges;\n                resizeEvent.rect = restricted;\n                resizeEvent.deltaRect = delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            return resizeEvent;\n        },\n\n        gestureStart: function (event) {\n            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\n            gestureEvent.ds = 0;\n\n            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.scale = 1;\n\n            this.gesturing = true;\n\n            this.target.fire(gestureEvent);\n\n            return gestureEvent;\n        },\n\n        gestureMove: function (event) {\n            if (!this.pointerIds.length) {\n                return this.prevEvent;\n            }\n\n            var gestureEvent;\n\n            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\n            this.target.fire(gestureEvent);\n\n            this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.prevDistance = gestureEvent.distance;\n\n            if (gestureEvent.scale !== Infinity &&\n                gestureEvent.scale !== null &&\n                gestureEvent.scale !== undefined  &&\n                !isNaN(gestureEvent.scale)) {\n\n                this.gesture.scale = gestureEvent.scale;\n            }\n\n            return gestureEvent;\n        },\n\n        pointerHold: function (pointer, event, eventTarget) {\n            this.collectEventTargets(pointer, event, eventTarget, 'hold');\n        },\n\n        pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'up' );\n            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        // http://www.quirksmode.org/dom/events/click.html\n        // >Events leading to dblclick\n        //\n        // IE8 doesn't fire down event before dblclick.\n        // This workaround tries to fire a tap and doubletap after dblclick\n        ie8Dblclick: function (pointer, event, eventTarget) {\n            if (this.prevTap\n                && event.clientX === this.prevTap.clientX\n                && event.clientY === this.prevTap.clientY\n                && eventTarget   === this.prevTap.target) {\n\n                this.downTargets[0] = eventTarget;\n                this.downTimes[0] = new Date().getTime();\n                this.collectEventTargets(pointer, event, eventTarget, 'tap');\n            }\n        },\n\n        // End interact move events and stop auto-scroll unless inertia is enabled\n        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n            var endEvent,\n                target = this.target,\n                options = target && target.options,\n                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n                inertiaStatus = this.inertiaStatus;\n\n            if (this.interacting()) {\n\n                if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\n                var pointerSpeed,\n                    now = new Date().getTime(),\n                    inertiaPossible = false,\n                    inertia = false,\n                    smoothEnd = false,\n                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n                    dx = 0,\n                    dy = 0,\n                    startEvent;\n\n                if (this.dragging) {\n                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n                }\n                else {\n                    pointerSpeed = this.pointerDelta.client.speed;\n                }\n\n                // check if inertia should be started\n                inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                                   && this.prepared.name !== 'gesture'\n                                   && event !== inertiaStatus.startEvent);\n\n                inertia = (inertiaPossible\n                           && (now - this.curCoords.timeStamp) < 50\n                           && pointerSpeed > inertiaOptions.minSpeed\n                           && pointerSpeed > inertiaOptions.endSpeed);\n\n                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\n                    var snapRestrict = {};\n\n                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n                    if (endSnap) {\n                        this.setSnapping(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.locked) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (endRestrict) {\n                        this.setRestriction(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.restricted) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (dx || dy) {\n                        smoothEnd = true;\n                    }\n                }\n\n                if (inertia || smoothEnd) {\n                    copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n                    this.pointers[0] = inertiaStatus.startEvent = startEvent =\n                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n                    inertiaStatus.t0 = now;\n\n                    target.fire(inertiaStatus.startEvent);\n\n                    if (inertia) {\n                        inertiaStatus.vx0 = this.pointerDelta.client.vx;\n                        inertiaStatus.vy0 = this.pointerDelta.client.vy;\n                        inertiaStatus.v0 = pointerSpeed;\n\n                        this.calcInertia(inertiaStatus);\n\n                        var page = extend({}, this.curCoords.page),\n                            origin = getOriginXY(target, this.element),\n                            statusObject;\n\n                        page.x = page.x + inertiaStatus.xe - origin.x;\n                        page.y = page.y + inertiaStatus.ye - origin.y;\n\n                        statusObject = {\n                            useStatusXY: true,\n                            x: page.x,\n                            y: page.y,\n                            dx: 0,\n                            dy: 0,\n                            snap: null\n                        };\n\n                        statusObject.snap = statusObject;\n\n                        dx = dy = 0;\n\n                        if (endSnap) {\n                            var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n                            if (snap.locked) {\n                                dx += snap.dx;\n                                dy += snap.dy;\n                            }\n                        }\n\n                        if (endRestrict) {\n                            var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\n                            if (restrict.restricted) {\n                                dx += restrict.dx;\n                                dy += restrict.dy;\n                            }\n                        }\n\n                        inertiaStatus.modifiedXe += dx;\n                        inertiaStatus.modifiedYe += dy;\n\n                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n                    }\n                    else {\n                        inertiaStatus.smoothEnd = true;\n                        inertiaStatus.xe = dx;\n                        inertiaStatus.ye = dy;\n\n                        inertiaStatus.sx = inertiaStatus.sy = 0;\n\n                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n                    }\n\n                    inertiaStatus.active = true;\n                    return;\n                }\n\n                if (endSnap || endRestrict) {\n                    // fire a move event at the snapped coordinates\n                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n                }\n            }\n\n            if (this.dragging) {\n                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\n                var draggableElement = this.element,\n                    drop = this.getDrop(endEvent, event, draggableElement);\n\n                this.dropTarget = drop.dropzone;\n                this.dropElement = drop.element;\n\n                var dropEvents = this.getDropEvents(event, endEvent);\n\n                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n                if (dropEvents.deactivate) {\n                    this.fireActiveDrops(dropEvents.deactivate);\n                }\n\n                target.fire(endEvent);\n            }\n            else if (this.resizing) {\n                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n                target.fire(endEvent);\n            }\n            else if (this.gesturing) {\n                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n                target.fire(endEvent);\n            }\n\n            this.stop(event);\n        },\n\n        collectDrops: function (element) {\n            var drops = [],\n                elements = [],\n                i;\n\n            element = element || this.element;\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (i = 0; i < interactables.length; i++) {\n                if (!interactables[i].options.drop.enabled) { continue; }\n\n                var current = interactables[i],\n                    accept = current.options.drop.accept;\n\n                // test the draggable element against the dropzone's accept setting\n                if ((isElement(accept) && accept !== element)\n                    || (isString(accept)\n                        && !matchesSelector(element, accept))) {\n\n                    continue;\n                }\n\n                // query for new elements if necessary\n                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\n                for (var j = 0, len = dropElements.length; j < len; j++) {\n                    var currentElement = dropElements[j];\n\n                    if (currentElement === element) {\n                        continue;\n                    }\n\n                    drops.push(current);\n                    elements.push(currentElement);\n                }\n            }\n\n            return {\n                dropzones: drops,\n                elements: elements\n            };\n        },\n\n        fireActiveDrops: function (event) {\n            var i,\n                current,\n                currentElement,\n                prevElement;\n\n            // loop through all active dropzones and trigger event\n            for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n                current = this.activeDrops.dropzones[i];\n                currentElement = this.activeDrops.elements [i];\n\n                // prevent trigger of duplicate events on same element\n                if (currentElement !== prevElement) {\n                    // set current element as event target\n                    event.target = currentElement;\n                    current.fire(event);\n                }\n                prevElement = currentElement;\n            }\n        },\n\n        // Collect a new set of possible drops and save them in activeDrops.\n        // setActiveDrops should always be called when a drag has just started or a\n        // drag event happens while dynamicDrop is true\n        setActiveDrops: function (dragElement) {\n            // get dropzones and their elements that could receive the draggable\n            var possibleDrops = this.collectDrops(dragElement, true);\n\n            this.activeDrops.dropzones = possibleDrops.dropzones;\n            this.activeDrops.elements  = possibleDrops.elements;\n            this.activeDrops.rects     = [];\n\n            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n            }\n        },\n\n        getDrop: function (dragEvent, event, dragElement) {\n            var validDrops = [];\n\n            if (dynamicDrop) {\n                this.setActiveDrops(dragElement);\n            }\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n                var current        = this.activeDrops.dropzones[j],\n                    currentElement = this.activeDrops.elements [j],\n                    rect           = this.activeDrops.rects    [j];\n\n                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n                                ? currentElement\n                                : null);\n            }\n\n            // get the most appropriate dropzone based on DOM depth and order\n            var dropIndex = indexOfDeepestElement(validDrops),\n                dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n                element   = this.activeDrops.elements [dropIndex] || null;\n\n            return {\n                dropzone: dropzone,\n                element: element\n            };\n        },\n\n        getDropEvents: function (pointerEvent, dragEvent) {\n            var dropEvents = {\n                enter     : null,\n                leave     : null,\n                activate  : null,\n                deactivate: null,\n                move      : null,\n                drop      : null\n            };\n\n            if (this.dropElement !== this.prevDropElement) {\n                // if there was a prevDropTarget, create a dragleave event\n                if (this.prevDropTarget) {\n                    dropEvents.leave = {\n                        target       : this.prevDropElement,\n                        dropzone     : this.prevDropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragleave'\n                    };\n\n                    dragEvent.dragLeave = this.prevDropElement;\n                    dragEvent.prevDropzone = this.prevDropTarget;\n                }\n                // if the dropTarget is not null, create a dragenter event\n                if (this.dropTarget) {\n                    dropEvents.enter = {\n                        target       : this.dropElement,\n                        dropzone     : this.dropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragenter'\n                    };\n\n                    dragEvent.dragEnter = this.dropElement;\n                    dragEvent.dropzone = this.dropTarget;\n                }\n            }\n\n            if (dragEvent.type === 'dragend' && this.dropTarget) {\n                dropEvents.drop = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'drop'\n                };\n\n                dragEvent.dropzone = this.dropTarget;\n            }\n            if (dragEvent.type === 'dragstart') {\n                dropEvents.activate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropactivate'\n                };\n            }\n            if (dragEvent.type === 'dragend') {\n                dropEvents.deactivate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropdeactivate'\n                };\n            }\n            if (dragEvent.type === 'dragmove' && this.dropTarget) {\n                dropEvents.move = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    dragmove     : dragEvent,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropmove'\n                };\n                dragEvent.dropzone = this.dropTarget;\n            }\n\n            return dropEvents;\n        },\n\n        currentAction: function () {\n            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n        },\n\n        interacting: function () {\n            return this.dragging || this.resizing || this.gesturing;\n        },\n\n        clearTargets: function () {\n            this.target = this.element = null;\n\n            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n        },\n\n        stop: function (event) {\n            if (this.interacting()) {\n                autoScroll.stop();\n                this.matches = [];\n                this.matchElements = [];\n\n                var target = this.target;\n\n                if (target.options.styleCursor) {\n                    target._doc.documentElement.style.cursor = '';\n                }\n\n                // prevent Default only if were previously interacting\n                if (event && isFunction(event.preventDefault)) {\n                    this.checkAndPreventDefault(event, target, this.element);\n                }\n\n                if (this.dragging) {\n                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n                }\n            }\n\n            this.clearTargets();\n\n            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n            this.prepared.name = this.prevEvent = null;\n            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n            // remove pointers if their ID isn't in this.pointerIds\n            for (var i = 0; i < this.pointers.length; i++) {\n                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n                    this.pointers.splice(i, 1);\n                }\n            }\n        },\n\n        inertiaFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                options = this.target.options[this.prepared.name].inertia,\n                lambda = options.resistance,\n                t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n            if (t < inertiaStatus.te) {\n\n                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n                    inertiaStatus.sx = inertiaStatus.xe * progress;\n                    inertiaStatus.sy = inertiaStatus.ye * progress;\n                }\n                else {\n                    var quadPoint = getQuadraticCurvePoint(\n                            0, 0,\n                            inertiaStatus.xe, inertiaStatus.ye,\n                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n                            progress);\n\n                    inertiaStatus.sx = quadPoint.x;\n                    inertiaStatus.sy = quadPoint.y;\n                }\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.modifiedXe;\n                inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        smoothEndFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                t = new Date().getTime() - inertiaStatus.t0,\n                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n            if (t < duration) {\n                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.xe;\n                inertiaStatus.sy = inertiaStatus.ye;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.smoothEnd =\n                  inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        addPointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) {\n                index = this.pointerIds.length;\n            }\n\n            this.pointerIds[index] = id;\n            this.pointers[index] = pointer;\n\n            return index;\n        },\n\n        removePointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) { return; }\n\n            this.pointers   .splice(index, 1);\n            this.pointerIds .splice(index, 1);\n            this.downTargets.splice(index, 1);\n            this.downTimes  .splice(index, 1);\n            this.holdTimers .splice(index, 1);\n        },\n\n        recordPointer: function (pointer) {\n            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\n            if (index === -1) { return; }\n\n            this.pointers[index] = pointer;\n        },\n\n        collectEventTargets: function (pointer, event, eventTarget, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // do not fire a tap event if the pointer was moved before being lifted\n            if (eventType === 'tap' && (this.pointerWasMoved\n                // or if the pointerup target is different to the pointerdown target\n                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n                return;\n            }\n\n            var targets = [],\n                elements = [],\n                element = eventTarget;\n\n            function collectSelectors (interactable, selector, context) {\n                var els = ie8MatchesSelector\n                        ? context.querySelectorAll(selector)\n                        : undefined;\n\n                if (interactable._iEvents[eventType]\n                    && isElement(element)\n                    && inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, els)) {\n\n                    targets.push(interactable);\n                    elements.push(element);\n                }\n            }\n\n            while (element) {\n                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n                    targets.push(interact(element));\n                    elements.push(element);\n                }\n\n                interactables.forEachSelector(collectSelectors);\n\n                element = parentElement(element);\n            }\n\n            // create the tap event even if there are no listeners so that\n            // doubletap can still be created and fired\n            if (targets.length || eventType === 'tap') {\n                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n            }\n        },\n\n        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n                pointerEvent = {},\n                i,\n                // for tap events\n                interval, createNewDoubleTap;\n\n            // if it's a doubletap then the event properties would have been\n            // copied from the tap event and provided as the pointer argument\n            if (eventType === 'doubletap') {\n                pointerEvent = pointer;\n            }\n            else {\n                pointerExtend(pointerEvent, event);\n                if (event !== pointer) {\n                    pointerExtend(pointerEvent, pointer);\n                }\n\n                pointerEvent.preventDefault           = preventOriginalDefault;\n                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n                pointerEvent.interaction              = this;\n\n                pointerEvent.timeStamp       = new Date().getTime();\n                pointerEvent.originalEvent   = event;\n                pointerEvent.originalPointer = pointer;\n                pointerEvent.type            = eventType;\n                pointerEvent.pointerId       = getPointerId(pointer);\n                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n                                                    : isString(pointer.pointerType)\n                                                        ? pointer.pointerType\n                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n            }\n\n            if (eventType === 'tap') {\n                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\n                interval = pointerEvent.timeStamp - this.tapTime;\n                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n                       && this.prevTap.target === pointerEvent.target\n                       && interval < 500);\n\n                pointerEvent.double = createNewDoubleTap;\n\n                this.tapTime = pointerEvent.timeStamp;\n            }\n\n            for (i = 0; i < targets.length; i++) {\n                pointerEvent.currentTarget = elements[i];\n                pointerEvent.interactable = targets[i];\n                targets[i].fire(pointerEvent);\n\n                if (pointerEvent.immediatePropagationStopped\n                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n                    break;\n                }\n            }\n\n            if (createNewDoubleTap) {\n                var doubleTap = {};\n\n                extend(doubleTap, pointerEvent);\n\n                doubleTap.dt   = interval;\n                doubleTap.type = 'doubletap';\n\n                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\n                this.prevTap = doubleTap;\n            }\n            else if (eventType === 'tap') {\n                this.prevTap = pointerEvent;\n            }\n        },\n\n        validateSelector: function (pointer, event, matches, matchElements) {\n            for (var i = 0, len = matches.length; i < len; i++) {\n                var match = matches[i],\n                    matchElement = matchElements[i],\n                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n                if (action && withinInteractionLimit(match, matchElement, action)) {\n                    this.target = match;\n                    this.element = matchElement;\n\n                    return action;\n                }\n            }\n        },\n\n        setSnapping: function (pageCoords, status) {\n            var snap = this.target.options[this.prepared.name].snap,\n                targets = [],\n                target,\n                page,\n                i;\n\n            status = status || this.snapStatus;\n\n            if (status.useStatusXY) {\n                page = { x: status.x, y: status.y };\n            }\n            else {\n                var origin = getOriginXY(this.target, this.element);\n\n                page = extend({}, pageCoords);\n\n                page.x -= origin.x;\n                page.y -= origin.y;\n            }\n\n            status.realX = page.x;\n            status.realY = page.y;\n\n            page.x = page.x - this.inertiaStatus.resumeDx;\n            page.y = page.y - this.inertiaStatus.resumeDy;\n\n            var len = snap.targets? snap.targets.length : 0;\n\n            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n                var relative = {\n                    x: page.x - this.snapOffsets[relIndex].x,\n                    y: page.y - this.snapOffsets[relIndex].y\n                };\n\n                for (i = 0; i < len; i++) {\n                    if (isFunction(snap.targets[i])) {\n                        target = snap.targets[i](relative.x, relative.y, this);\n                    }\n                    else {\n                        target = snap.targets[i];\n                    }\n\n                    if (!target) { continue; }\n\n                    targets.push({\n                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\n                        range: isNumber(target.range)? target.range: snap.range\n                    });\n                }\n            }\n\n            var closest = {\n                    target: null,\n                    inRange: false,\n                    distance: 0,\n                    range: 0,\n                    dx: 0,\n                    dy: 0\n                };\n\n            for (i = 0, len = targets.length; i < len; i++) {\n                target = targets[i];\n\n                var range = target.range,\n                    dx = target.x - page.x,\n                    dy = target.y - page.y,\n                    distance = hypot(dx, dy),\n                    inRange = distance <= range;\n\n                // Infinite targets count as being out of range\n                // compared to non infinite ones that are in range\n                if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n                    inRange = false;\n                }\n\n                if (!closest.target || (inRange\n                    // is the closest target in range?\n                    ? (closest.inRange && range !== Infinity\n                        // the pointer is relatively deeper in this target\n                        ? distance / range < closest.distance / closest.range\n                        // this target has Infinite range and the closest doesn't\n                        : (range === Infinity && closest.range !== Infinity)\n                            // OR this target is closer that the previous closest\n                            || distance < closest.distance)\n                    // The other is not in range and the pointer is closer to this target\n                    : (!closest.inRange && distance < closest.distance))) {\n\n                    if (range === Infinity) {\n                        inRange = true;\n                    }\n\n                    closest.target = target;\n                    closest.distance = distance;\n                    closest.range = range;\n                    closest.inRange = inRange;\n                    closest.dx = dx;\n                    closest.dy = dy;\n\n                    status.range = range;\n                }\n            }\n\n            var snapChanged;\n\n            if (closest.target) {\n                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n                status.snappedX = closest.target.x;\n                status.snappedY = closest.target.y;\n            }\n            else {\n                snapChanged = true;\n\n                status.snappedX = NaN;\n                status.snappedY = NaN;\n            }\n\n            status.dx = closest.dx;\n            status.dy = closest.dy;\n\n            status.changed = (snapChanged || (closest.inRange && !status.locked));\n            status.locked = closest.inRange;\n\n            return status;\n        },\n\n        setRestriction: function (pageCoords, status) {\n            var target = this.target,\n                restrict = target && target.options[this.prepared.name].restrict,\n                restriction = restrict && restrict.restriction,\n                page;\n\n            if (!restriction) {\n                return status;\n            }\n\n            status = status || this.restrictStatus;\n\n            page = status.useStatusXY\n                    ? page = { x: status.x, y: status.y }\n                    : page = extend({}, pageCoords);\n\n            if (status.snap && status.snap.locked) {\n                page.x += status.snap.dx || 0;\n                page.y += status.snap.dy || 0;\n            }\n\n            page.x -= this.inertiaStatus.resumeDx;\n            page.y -= this.inertiaStatus.resumeDy;\n\n            status.dx = 0;\n            status.dy = 0;\n            status.restricted = false;\n\n            var rect, restrictedX, restrictedY;\n\n            if (isString(restriction)) {\n                if (restriction === 'parent') {\n                    restriction = parentElement(this.element);\n                }\n                else if (restriction === 'self') {\n                    restriction = target.getRect(this.element);\n                }\n                else {\n                    restriction = closest(this.element, restriction);\n                }\n\n                if (!restriction) { return status; }\n            }\n\n            if (isFunction(restriction)) {\n                restriction = restriction(page.x, page.y, this.element);\n            }\n\n            if (isElement(restriction)) {\n                restriction = getElementRect(restriction);\n            }\n\n            rect = restriction;\n\n            if (!restriction) {\n                restrictedX = page.x;\n                restrictedY = page.y;\n            }\n            // object is assumed to have\n            // x, y, width, height or\n            // left, top, right, bottom\n            else if ('x' in restriction && 'y' in restriction) {\n                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n            }\n            else {\n                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n            }\n\n            status.dx = restrictedX - page.x;\n            status.dy = restrictedY - page.y;\n\n            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n            status.restricted = !!(status.dx || status.dy);\n\n            status.restrictedX = restrictedX;\n            status.restrictedY = restrictedY;\n\n            return status;\n        },\n\n        checkAndPreventDefault: function (event, interactable, element) {\n            if (!(interactable = interactable || this.target)) { return; }\n\n            var options = interactable.options,\n                prevent = options.preventDefault;\n\n            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n                // do not preventDefault on pointerdown if the prepared action is a drag\n                // and dragging can only start from a certain direction - this allows\n                // a touch to pan the viewport if a drag isn't in the right direction\n                if (/down|start/i.test(event.type)\n                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n                    return;\n                }\n\n                // with manualStart, only preventDefault while interacting\n                if (options[this.prepared.name] && options[this.prepared.name].manualStart\n                    && !this.interacting()) {\n                    return;\n                }\n\n                event.preventDefault();\n                return;\n            }\n\n            if (prevent === 'always') {\n                event.preventDefault();\n                return;\n            }\n        },\n\n        calcInertia: function (status) {\n            var inertiaOptions = this.target.options[this.prepared.name].inertia,\n                lambda = inertiaOptions.resistance,\n                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n            status.x0 = this.prevEvent.pageX;\n            status.y0 = this.prevEvent.pageY;\n            status.t0 = status.startEvent.timeStamp / 1000;\n            status.sx = status.sy = 0;\n\n            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n            status.te = inertiaDur;\n\n            status.lambda_v0 = lambda / status.v0;\n            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n        },\n\n        autoScrollMove: function (pointer) {\n            if (!(this.interacting()\n                && checkAutoScroll(this.target, this.prepared.name))) {\n                return;\n            }\n\n            if (this.inertiaStatus.active) {\n                autoScroll.x = autoScroll.y = 0;\n                return;\n            }\n\n            var top,\n                right,\n                bottom,\n                left,\n                options = this.target.options[this.prepared.name].autoScroll,\n                container = options.container || getWindow(this.element);\n\n            if (isWindow(container)) {\n                left   = pointer.clientX < autoScroll.margin;\n                top    = pointer.clientY < autoScroll.margin;\n                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n            }\n            else {\n                var rect = getElementClientRect(container);\n\n                left   = pointer.clientX < rect.left   + autoScroll.margin;\n                top    = pointer.clientY < rect.top    + autoScroll.margin;\n                right  = pointer.clientX > rect.right  - autoScroll.margin;\n                bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n            }\n\n            autoScroll.x = (right ? 1: left? -1: 0);\n            autoScroll.y = (bottom? 1:  top? -1: 0);\n\n            if (!autoScroll.isScrolling) {\n                // set the autoScroll properties to those of the target\n                autoScroll.margin = options.margin;\n                autoScroll.speed  = options.speed;\n\n                autoScroll.start(this);\n            }\n        },\n\n        _updateEventTargets: function (target, currentTarget) {\n            this._eventTarget    = target;\n            this._curEventTarget = currentTarget;\n        }\n\n    };\n\n    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n        var i = 0, len = interactions.length,\n            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                          || pointer.pointerType === 4),\n            interaction;\n\n        var id = getPointerId(pointer);\n\n        // try to resume inertia with a new pointer\n        if (/down|start/i.test(eventType)) {\n            for (i = 0; i < len; i++) {\n                interaction = interactions[i];\n\n                var element = eventTarget;\n\n                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n                    && (interaction.mouse === mouseEvent)) {\n                    while (element) {\n                        // if the element is the interaction element\n                        if (element === interaction.element) {\n                            return interaction;\n                        }\n                        element = parentElement(element);\n                    }\n                }\n            }\n        }\n\n        // if it's a mouse interaction\n        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\n            // find a mouse interaction that's not in inertia phase\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n                    return interactions[i];\n                }\n            }\n\n            // find any interaction specifically for mouse.\n            // if the eventType is a mousedown, and inertia is active\n            // ignore the interaction\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n                    return interaction;\n                }\n            }\n\n            // create a new interaction for mouse\n            interaction = new Interaction();\n            interaction.mouse = true;\n\n            return interaction;\n        }\n\n        // get interaction that has this pointer\n        for (i = 0; i < len; i++) {\n            if (contains(interactions[i].pointerIds, id)) {\n                return interactions[i];\n            }\n        }\n\n        // at this stage, a pointerUp should not return an interaction\n        if (/up|end|out/i.test(eventType)) {\n            return null;\n        }\n\n        // get first idle interaction\n        for (i = 0; i < len; i++) {\n            interaction = interactions[i];\n\n            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n                && !interaction.interacting()\n                && !(!mouseEvent && interaction.mouse)) {\n\n                return interaction;\n            }\n        }\n\n        return new Interaction();\n    }\n\n    function doOnInteractions (method) {\n        return (function (event) {\n            var interaction,\n                eventTarget = getActualElement(event.path\n                                               ? event.path[0]\n                                               : event.target),\n                curEventTarget = getActualElement(event.currentTarget),\n                i;\n\n            if (supportsTouch && /touch/.test(event.type)) {\n                prevTouchTime = new Date().getTime();\n\n                for (i = 0; i < event.changedTouches.length; i++) {\n                    var pointer = event.changedTouches[i];\n\n                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\n                    if (!interaction) { continue; }\n\n                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                    interaction[method](pointer, event, eventTarget, curEventTarget);\n                }\n            }\n            else {\n                if (!supportsPointerEvent && /mouse/.test(event.type)) {\n                    // ignore mouse events while touch interactions are active\n                    for (i = 0; i < interactions.length; i++) {\n                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n                            return;\n                        }\n                    }\n\n                    // try to ignore mouse events that are simulated by the browser\n                    // after a touch event\n                    if (new Date().getTime() - prevTouchTime < 500) {\n                        return;\n                    }\n                }\n\n                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n                if (!interaction) { return; }\n\n                interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                interaction[method](event, event, eventTarget, curEventTarget);\n            }\n        });\n    }\n\n    function InteractEvent (interaction, event, action, phase, element, related) {\n        var client,\n            page,\n            target      = interaction.target,\n            snapStatus  = interaction.snapStatus,\n            restrictStatus  = interaction.restrictStatus,\n            pointers    = interaction.pointers,\n            deltaSource = (target && target.options || defaultOptions).deltaSource,\n            sourceX     = deltaSource + 'X',\n            sourceY     = deltaSource + 'Y',\n            options     = target? target.options: defaultOptions,\n            origin      = getOriginXY(target, element),\n            starting    = phase === 'start',\n            ending      = phase === 'end',\n            coords      = starting? interaction.startCoords : interaction.curCoords;\n\n        element = element || interaction.element;\n\n        page   = extend({}, coords.page);\n        client = extend({}, coords.client);\n\n        page.x -= origin.x;\n        page.y -= origin.y;\n\n        client.x -= origin.x;\n        client.y -= origin.y;\n\n        var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\n        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n            this.snap = {\n                range  : snapStatus.range,\n                locked : snapStatus.locked,\n                x      : snapStatus.snappedX,\n                y      : snapStatus.snappedY,\n                realX  : snapStatus.realX,\n                realY  : snapStatus.realY,\n                dx     : snapStatus.dx,\n                dy     : snapStatus.dy\n            };\n\n            if (snapStatus.locked) {\n                page.x += snapStatus.dx;\n                page.y += snapStatus.dy;\n                client.x += snapStatus.dx;\n                client.y += snapStatus.dy;\n            }\n        }\n\n        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n            page.x += restrictStatus.dx;\n            page.y += restrictStatus.dy;\n            client.x += restrictStatus.dx;\n            client.y += restrictStatus.dy;\n\n            this.restrict = {\n                dx: restrictStatus.dx,\n                dy: restrictStatus.dy\n            };\n        }\n\n        this.pageX     = page.x;\n        this.pageY     = page.y;\n        this.clientX   = client.x;\n        this.clientY   = client.y;\n\n        this.x0        = interaction.startCoords.page.x - origin.x;\n        this.y0        = interaction.startCoords.page.y - origin.y;\n        this.clientX0  = interaction.startCoords.client.x - origin.x;\n        this.clientY0  = interaction.startCoords.client.y - origin.y;\n        this.ctrlKey   = event.ctrlKey;\n        this.altKey    = event.altKey;\n        this.shiftKey  = event.shiftKey;\n        this.metaKey   = event.metaKey;\n        this.button    = event.button;\n        this.buttons   = event.buttons;\n        this.target    = element;\n        this.t0        = interaction.downTimes[0];\n        this.type      = action + (phase || '');\n\n        this.interaction = interaction;\n        this.interactable = target;\n\n        var inertiaStatus = interaction.inertiaStatus;\n\n        if (inertiaStatus.active) {\n            this.detail = 'inertia';\n        }\n\n        if (related) {\n            this.relatedTarget = related;\n        }\n\n        // end event dx, dy is difference between start and end points\n        if (ending) {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.startCoords.client.x;\n                this.dy = client.y - interaction.startCoords.client.y;\n            }\n            else {\n                this.dx = page.x - interaction.startCoords.page.x;\n                this.dy = page.y - interaction.startCoords.page.y;\n            }\n        }\n        else if (starting) {\n            this.dx = 0;\n            this.dy = 0;\n        }\n        // copy properties from previousmove if starting inertia\n        else if (phase === 'inertiastart') {\n            this.dx = interaction.prevEvent.dx;\n            this.dy = interaction.prevEvent.dy;\n        }\n        else {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.prevEvent.clientX;\n                this.dy = client.y - interaction.prevEvent.clientY;\n            }\n            else {\n                this.dx = page.x - interaction.prevEvent.pageX;\n                this.dy = page.y - interaction.prevEvent.pageY;\n            }\n        }\n        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n            && !inertiaStatus.active\n            && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n            inertiaStatus.resumeDx += this.dx;\n            inertiaStatus.resumeDy += this.dy;\n\n            this.dx = this.dy = 0;\n        }\n\n        if (action === 'resize' && interaction.resizeAxes) {\n            if (options.resize.square) {\n                if (interaction.resizeAxes === 'y') {\n                    this.dx = this.dy;\n                }\n                else {\n                    this.dy = this.dx;\n                }\n                this.axes = 'xy';\n            }\n            else {\n                this.axes = interaction.resizeAxes;\n\n                if (interaction.resizeAxes === 'x') {\n                    this.dy = 0;\n                }\n                else if (interaction.resizeAxes === 'y') {\n                    this.dx = 0;\n                }\n            }\n        }\n        else if (action === 'gesture') {\n            this.touches = [pointers[0], pointers[1]];\n\n            if (starting) {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = 1;\n                this.ds       = 0;\n                this.angle    = touchAngle(pointers, undefined, deltaSource);\n                this.da       = 0;\n            }\n            else if (ending || event instanceof InteractEvent) {\n                this.distance = interaction.prevEvent.distance;\n                this.box      = interaction.prevEvent.box;\n                this.scale    = interaction.prevEvent.scale;\n                this.ds       = this.scale - 1;\n                this.angle    = interaction.prevEvent.angle;\n                this.da       = this.angle - interaction.gesture.startAngle;\n            }\n            else {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = this.distance / interaction.gesture.startDistance;\n                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n                this.ds = this.scale - interaction.gesture.prevScale;\n                this.da = this.angle - interaction.gesture.prevAngle;\n            }\n        }\n\n        if (starting) {\n            this.timeStamp = interaction.downTimes[0];\n            this.dt        = 0;\n            this.duration  = 0;\n            this.speed     = 0;\n            this.velocityX = 0;\n            this.velocityY = 0;\n        }\n        else if (phase === 'inertiastart') {\n            this.timeStamp = interaction.prevEvent.timeStamp;\n            this.dt        = interaction.prevEvent.dt;\n            this.duration  = interaction.prevEvent.duration;\n            this.speed     = interaction.prevEvent.speed;\n            this.velocityX = interaction.prevEvent.velocityX;\n            this.velocityY = interaction.prevEvent.velocityY;\n        }\n        else {\n            this.timeStamp = new Date().getTime();\n            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n            this.duration  = this.timeStamp - interaction.downTimes[0];\n\n            if (event instanceof InteractEvent) {\n                var dx = this[sourceX] - interaction.prevEvent[sourceX],\n                    dy = this[sourceY] - interaction.prevEvent[sourceY],\n                    dt = this.dt / 1000;\n\n                this.speed = hypot(dx, dy) / dt;\n                this.velocityX = dx / dt;\n                this.velocityY = dy / dt;\n            }\n            // if normal move or end event, use previous user event coords\n            else {\n                // speed and velocity in pixels per second\n                this.speed = interaction.pointerDelta[deltaSource].speed;\n                this.velocityX = interaction.pointerDelta[deltaSource].vx;\n                this.velocityY = interaction.pointerDelta[deltaSource].vy;\n            }\n        }\n\n        if ((ending || phase === 'inertiastart')\n            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n                overlap = 22.5;\n\n            if (angle < 0) {\n                angle += 360;\n            }\n\n            var left = 135 - overlap <= angle && angle < 225 + overlap,\n                up   = 225 - overlap <= angle && angle < 315 + overlap,\n\n                right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n            this.swipe = {\n                up   : up,\n                down : down,\n                left : left,\n                right: right,\n                angle: angle,\n                speed: interaction.prevEvent.speed,\n                velocity: {\n                    x: interaction.prevEvent.velocityX,\n                    y: interaction.prevEvent.velocityY\n                }\n            };\n        }\n    }\n\n    InteractEvent.prototype = {\n        preventDefault: blank,\n        stopImmediatePropagation: function () {\n            this.immediatePropagationStopped = this.propagationStopped = true;\n        },\n        stopPropagation: function () {\n            this.propagationStopped = true;\n        }\n    };\n\n    function preventOriginalDefault () {\n        this.originalEvent.preventDefault();\n    }\n\n    function getActionCursor (action) {\n        var cursor = '';\n\n        if (action.name === 'drag') {\n            cursor =  actionCursors.drag;\n        }\n        if (action.name === 'resize') {\n            if (action.axis) {\n                cursor =  actionCursors[action.name + action.axis];\n            }\n            else if (action.edges) {\n                var cursorKey = 'resize',\n                    edgeNames = ['top', 'bottom', 'left', 'right'];\n\n                for (var i = 0; i < 4; i++) {\n                    if (action.edges[edgeNames[i]]) {\n                        cursorKey += edgeNames[i];\n                    }\n                }\n\n                cursor = actionCursors[cursorKey];\n            }\n        }\n\n        return cursor;\n    }\n\n    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n        // false, '', undefined, null\n        if (!value) { return false; }\n\n        // true value, use pointer coords and element rect\n        if (value === true) {\n            // if dimensions are negative, \"switch\" edges\n            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\n            if (width < 0) {\n                if      (name === 'left' ) { name = 'right'; }\n                else if (name === 'right') { name = 'left' ; }\n            }\n            if (height < 0) {\n                if      (name === 'top'   ) { name = 'bottom'; }\n                else if (name === 'bottom') { name = 'top'   ; }\n            }\n\n            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n        }\n\n        // the remaining checks require an element\n        if (!isElement(element)) { return false; }\n\n        return isElement(value)\n                    // the value is an element to use as a resize handle\n                    ? value === element\n                    // otherwise check if element matches value as selector\n                    : matchesUpTo(element, value, interactableElement);\n    }\n\n    function defaultActionChecker (pointer, interaction, element) {\n        var rect = this.getRect(element),\n            shouldResize = false,\n            action = null,\n            resizeAxes = null,\n            resizeEdges,\n            page = extend({}, interaction.curCoords.page),\n            options = this.options;\n\n        if (!rect) { return null; }\n\n        if (actionIsEnabled.resize && options.resize.enabled) {\n            var resizeOptions = options.resize;\n\n            resizeEdges = {\n                left: false, right: false, top: false, bottom: false\n            };\n\n            // if using resize.edges\n            if (isObject(resizeOptions.edges)) {\n                for (var edge in resizeEdges) {\n                    resizeEdges[edge] = checkResizeEdge(edge,\n                                                        resizeOptions.edges[edge],\n                                                        page,\n                                                        interaction._eventTarget,\n                                                        element,\n                                                        rect,\n                                                        resizeOptions.margin || margin);\n                }\n\n                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n            }\n            else {\n                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\n                shouldResize = right || bottom;\n                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n            }\n        }\n\n        action = shouldResize\n            ? 'resize'\n            : actionIsEnabled.drag && options.drag.enabled\n                ? 'drag'\n                : null;\n\n        if (actionIsEnabled.gesture\n            && interaction.pointerIds.length >=2\n            && !(interaction.dragging || interaction.resizing)) {\n            action = 'gesture';\n        }\n\n        if (action) {\n            return {\n                name: action,\n                axis: resizeAxes,\n                edges: resizeEdges\n            };\n        }\n\n        return null;\n    }\n\n    // Check if action is enabled globally and the current target supports it\n    // If so, return the validated action. Otherwise, return null\n    function validateAction (action, interactable) {\n        if (!isObject(action)) { return null; }\n\n        var actionName = action.name,\n            options = interactable.options;\n\n        if ((  (actionName  === 'resize'   && options.resize.enabled )\n            || (actionName      === 'drag'     && options.drag.enabled  )\n            || (actionName      === 'gesture'  && options.gesture.enabled))\n            && actionIsEnabled[actionName]) {\n\n            if (actionName === 'resize' || actionName === 'resizeyx') {\n                actionName = 'resizexy';\n            }\n\n            return action;\n        }\n        return null;\n    }\n\n    var listeners = {},\n        interactionListeners = [\n            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n        ];\n\n    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n        var name = interactionListeners[i];\n\n        listeners[name] = doOnInteractions(name);\n    }\n\n    // bound to the interactable context when a DOM event\n    // listener is added to a selector interactable\n    function delegateListener (event, useCapture) {\n        var fakeEvent = {},\n            delegated = delegatedEvents[event.type],\n            eventTarget = getActualElement(event.path\n                                           ? event.path[0]\n                                           : event.target),\n            element = eventTarget;\n\n        useCapture = useCapture? true: false;\n\n        // duplicate the event so that currentTarget can be changed\n        for (var prop in event) {\n            fakeEvent[prop] = event[prop];\n        }\n\n        fakeEvent.originalEvent = event;\n        fakeEvent.preventDefault = preventOriginalDefault;\n\n        // climb up document tree looking for selector matches\n        while (isElement(element)) {\n            for (var i = 0; i < delegated.selectors.length; i++) {\n                var selector = delegated.selectors[i],\n                    context = delegated.contexts[i];\n\n                if (matchesSelector(element, selector)\n                    && nodeContains(context, eventTarget)\n                    && nodeContains(context, element)) {\n\n                    var listeners = delegated.listeners[i];\n\n                    fakeEvent.currentTarget = element;\n\n                    for (var j = 0; j < listeners.length; j++) {\n                        if (listeners[j][1] === useCapture) {\n                            listeners[j][0](fakeEvent);\n                        }\n                    }\n                }\n            }\n\n            element = parentElement(element);\n        }\n    }\n\n    function delegateUseCapture (event) {\n        return delegateListener.call(this, event, true);\n    }\n\n    interactables.indexOfElement = function indexOfElement (element, context) {\n        context = context || document;\n\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if ((interactable.selector === element\n                && (interactable._context === context))\n                || (!interactable.selector && interactable._element === element)) {\n\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    interactables.get = function interactableGet (element, options) {\n        return this[this.indexOfElement(element, options && options.context)];\n    };\n\n    interactables.forEachSelector = function (callback) {\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if (!interactable.selector) {\n                continue;\n            }\n\n            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n    };\n\n    /*\\\n     * interact\n     [ method ]\n     *\n     * The methods of this variable can be used to set elements as\n     * interactables and also to change various default settings.\n     *\n     * Calling it as a function and passing an element or a valid CSS selector\n     * string returns an Interactable object which has various methods to\n     * configure it.\n     *\n     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n     = (object) An @Interactable\n     *\n     > Usage\n     | interact(document.getElementById('draggable')).draggable(true);\n     |\n     | var rectables = interact('rect');\n     | rectables\n     |     .gesturable(true)\n     |     .on('gesturemove', function (event) {\n     |         // something cool...\n     |     })\n     |     .autoScroll(true);\n    \\*/\n    function interact (element, options) {\n        return interactables.get(element, options) || new Interactable(element, options);\n    }\n\n    /*\\\n     * Interactable\n     [ property ]\n     **\n     * Object type returned by @interact\n    \\*/\n    function Interactable (element, options) {\n        this._element = element;\n        this._iEvents = this._iEvents || {};\n\n        var _window;\n\n        if (trySelector(element)) {\n            this.selector = element;\n\n            var context = options && options.context;\n\n            _window = context? getWindow(context) : window;\n\n            if (context && (_window.Node\n                    ? context instanceof _window.Node\n                    : (isElement(context) || context === _window.document))) {\n\n                this._context = context;\n            }\n        }\n        else {\n            _window = getWindow(element);\n\n            if (isElement(element, _window)) {\n\n                if (PointerEvent) {\n                    events.add(this._element, pEventTypes.down, listeners.pointerDown );\n                    events.add(this._element, pEventTypes.move, listeners.pointerHover);\n                }\n                else {\n                    events.add(this._element, 'mousedown' , listeners.pointerDown );\n                    events.add(this._element, 'mousemove' , listeners.pointerHover);\n                    events.add(this._element, 'touchstart', listeners.pointerDown );\n                    events.add(this._element, 'touchmove' , listeners.pointerHover);\n                }\n            }\n        }\n\n        this._doc = _window.document;\n\n        if (!contains(documents, this._doc)) {\n            listenToDocument(this._doc);\n        }\n\n        interactables.push(this);\n\n        this.set(options);\n    }\n\n    Interactable.prototype = {\n        setOnEvents: function (action, phases) {\n            if (action === 'drop') {\n                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n            }\n            else {\n                action = 'on' + action;\n\n                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.draggable\n         [ method ]\n         *\n         * Gets or sets whether drag actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of drag events\n         | var isDraggable = interact('ul li').draggable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n         = (object) This Interactable\n         | interact(element).draggable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // the axis in which the first movement must be\n         |     // for the drag sequence to start\n         |     // 'xy' by default - any direction\n         |     axis: 'x' || 'y' || 'xy',\n         |\n         |     // max number of drags that can happen concurrently\n         |     // with elements of this Interactable. Infinity by default\n         |     max: Infinity,\n         |\n         |     // max number of drags that can target the same element+Interactable\n         |     // 1 by default\n         |     maxPerElement: 2\n         | });\n        \\*/\n        draggable: function (options) {\n            if (isObject(options)) {\n                this.options.drag.enabled = options.enabled === false? false: true;\n                this.setPerAction('drag', options);\n                this.setOnEvents('drag', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.drag.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    delete this.options.drag.axis;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drag.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drag;\n        },\n\n        setPerAction: function (action, options) {\n            // for all the default per-action options\n            for (var option in options) {\n                // if this option exists for this action\n                if (option in defaultOptions[action]) {\n                    // if the option in the options arg is an object value\n                    if (isObject(options[option])) {\n                        // duplicate the object\n                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n                        }\n                    }\n                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n                        this.options[action][option].enabled = options[option];\n                    }\n                    else if (options[option] !== undefined) {\n                        // or if it's not undefined, do a plain assignment\n                        this.options[action][option] = options[option];\n                    }\n                }\n            }\n        },\n\n        /*\\\n         * Interactable.dropzone\n         [ method ]\n         *\n         * Returns or sets whether elements can be dropped onto this\n         * Interactable to trigger drop events\n         *\n         * Dropzones can receive the following events:\n         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n         *  - `dragmove` when a draggable that has entered the dropzone is moved\n         *  - `drop` when a draggable is dropped into this dropzone\n         *\n         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n         *\n         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n         *   - `'pointer'`, the pointer must be over the dropzone (default)\n         *   - `'center'`, the draggable element's center must be over the dropzone\n         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n         *       e.g. `0.5` for drop to happen when half of the area of the\n         *       draggable is over the dropzone\n         *\n         - options (boolean | object | null) #optional The new value to be set.\n         | interact('.drop').dropzone({\n         |   accept: '.can-drop' || document.getElementById('single-drop'),\n         |   overlap: 'pointer' || 'center' || zeroToOne\n         | }\n         = (boolean | object) The current setting or this Interactable\n        \\*/\n        dropzone: function (options) {\n            if (isObject(options)) {\n                this.options.drop.enabled = options.enabled === false? false: true;\n                this.setOnEvents('drop', options);\n\n                if (/^(pointer|center)$/.test(options.overlap)) {\n                    this.options.drop.overlap = options.overlap;\n                }\n                else if (isNumber(options.overlap)) {\n                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n                }\n                if ('accept' in options) {\n                  this.options.drop.accept = options.accept;\n                }\n                if ('checker' in options) {\n                  this.options.drop.checker = options.checker;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drop.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drop;\n        },\n\n        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n            var dropped = false;\n\n            // if the dropzone has no rect (eg. display: none)\n            // call the custom dropChecker or just return false\n            if (!(rect = rect || this.getRect(dropElement))) {\n                return (this.options.drop.checker\n                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n                    : false);\n            }\n\n            var dropOverlap = this.options.drop.overlap;\n\n            if (dropOverlap === 'pointer') {\n                var page = getPageXY(dragEvent),\n                    origin = getOriginXY(draggable, draggableElement),\n                    horizontal,\n                    vertical;\n\n                page.x += origin.x;\n                page.y += origin.y;\n\n                horizontal = (page.x > rect.left) && (page.x < rect.right);\n                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n                dropped = horizontal && vertical;\n            }\n\n            var dragRect = draggable.getRect(draggableElement);\n\n            if (dropOverlap === 'center') {\n                var cx = dragRect.left + dragRect.width  / 2,\n                    cy = dragRect.top  + dragRect.height / 2;\n\n                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n            }\n\n            if (isNumber(dropOverlap)) {\n                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n                dropped = overlapRatio >= dropOverlap;\n            }\n\n            if (this.options.drop.checker) {\n                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n            }\n\n            return dropped;\n        },\n\n        /*\\\n         * Interactable.dropChecker\n         [ method ]\n         *\n         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n         *\n         * Gets or sets the function used to check if a dragged element is\n         * over this Interactable.\n         *\n         - checker (function) #optional The function that will be called when checking for a drop\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         * The checker function takes the following arguments:\n         *\n         - dragEvent (InteractEvent) The related dragmove or dragend event\n         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n         - dropped (boolean) The value from the default drop checker\n         - dropzone (Interactable) The dropzone interactable\n         - dropElement (Element) The dropzone element\n         - draggable (Interactable) The Interactable being dragged\n         - draggableElement (Element) The actual element that's being dragged\n         *\n         > Usage:\n         | interact(target)\n         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n         |                       dropped,           // bool result of the default checker\n         |                       dropzone,          // dropzone Interactable\n         |                       dropElement,       // dropzone elemnt\n         |                       draggable,         // draggable Interactable\n         |                       draggableElement) {// draggable element\n         |\n         |   return dropped && event.target.hasAttribute('allow-drop');\n         | }\n        \\*/\n        dropChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.drop.checker = checker;\n\n                return this;\n            }\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.options.drop.checker;\n        },\n\n        /*\\\n         * Interactable.accept\n         [ method ]\n         *\n         * Deprecated. add an `accept` property to the options object passed to\n         * @Interactable.dropzone instead.\n         *\n         * Gets or sets the Element or CSS selector match that this\n         * Interactable accepts if it is a dropzone.\n         *\n         - newValue (Element | string | null) #optional\n         * If it is an Element, then only that element can be dropped into this dropzone.\n         * If it is a string, the element being dragged must match it as a selector.\n         * If it is null, the accept options is cleared - it accepts any element.\n         *\n         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n        \\*/\n        accept: function (newValue) {\n            if (isElement(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            // test if it is a valid CSS selector\n            if (trySelector(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.drop.accept;\n\n                return this;\n            }\n\n            return this.options.drop.accept;\n        },\n\n        /*\\\n         * Interactable.resizable\n         [ method ]\n         *\n         * Gets or sets whether resize actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of resize elements\n         | var isResizeable = interact('input[type=text]').resizable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n         = (object) This Interactable\n         | interact(element).resizable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     edges: {\n         |       top   : true,       // Use pointer coords to check for resize.\n         |       left  : false,      // Disable resizing from left edge.\n         |       bottom: '.resize-s',// Resize if pointer target matches selector\n         |       right : handleEl    // Resize if pointer target is the given Element\n         |     },\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height are adjusted at a 1:1 ratio.\n         |     square: false,\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height maintain the aspect ratio they had when resizing started.\n         |     preserveAspectRatio: false,\n         |\n         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n         |     // 'negate' will allow the rect to have negative width/height\n         |     // 'reposition' will keep the width/height positive by swapping\n         |     // the top and bottom edges and/or swapping the left and right edges\n         |     invert: 'none' || 'negate' || 'reposition'\n         |\n         |     // limit multiple resizes.\n         |     // See the explanation in the @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        resizable: function (options) {\n            if (isObject(options)) {\n                this.options.resize.enabled = options.enabled === false? false: true;\n                this.setPerAction('resize', options);\n                this.setOnEvents('resize', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.resize.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    this.options.resize.axis = defaultOptions.resize.axis;\n                }\n\n                if (isBool(options.preserveAspectRatio)) {\n                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n                }\n                else if (isBool(options.square)) {\n                    this.options.resize.square = options.square;\n                }\n\n                return this;\n            }\n            if (isBool(options)) {\n                this.options.resize.enabled = options;\n\n                return this;\n            }\n            return this.options.resize;\n        },\n\n        /*\\\n         * Interactable.squareResize\n         [ method ]\n         *\n         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n         *\n         * Gets or sets whether resizing is forced 1:1 aspect\n         *\n         = (boolean) Current setting\n         *\n         * or\n         *\n         - newValue (boolean) #optional\n         = (object) this Interactable\n        \\*/\n        squareResize: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.resize.square = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.resize.square;\n\n                return this;\n            }\n\n            return this.options.resize.square;\n        },\n\n        /*\\\n         * Interactable.gesturable\n         [ method ]\n         *\n         * Gets or sets whether multitouch gestures can be performed on the\n         * Interactable's element\n         *\n         = (boolean) Indicates if this can be the target of gesture events\n         | var isGestureable = interact(element).gesturable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n         = (object) this Interactable\n         | interact(element).gesturable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // limit multiple gestures.\n         |     // See the explanation in @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        gesturable: function (options) {\n            if (isObject(options)) {\n                this.options.gesture.enabled = options.enabled === false? false: true;\n                this.setPerAction('gesture', options);\n                this.setOnEvents('gesture', options);\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.gesture.enabled = options;\n\n                return this;\n            }\n\n            return this.options.gesture;\n        },\n\n        /*\\\n         * Interactable.autoScroll\n         [ method ]\n         **\n         * Deprecated. Add an `autoscroll` property to the options object\n         * passed to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets whether dragging and resizing near the edges of the\n         * window/container trigger autoScroll for this Interactable\n         *\n         = (object) Object with autoScroll properties\n         *\n         * or\n         *\n         - options (object | boolean) #optional\n         * options can be:\n         * - an object with margin, distance and interval properties,\n         * - true or false to enable or disable autoScroll or\n         = (Interactable) this Interactable\n        \\*/\n        autoScroll: function (options) {\n            if (isObject(options)) {\n                options = extend({ actions: ['drag', 'resize']}, options);\n            }\n            else if (isBool(options)) {\n                options = { actions: ['drag', 'resize'], enabled: options };\n            }\n\n            return this.setOptions('autoScroll', options);\n        },\n\n        /*\\\n         * Interactable.snap\n         [ method ]\n         **\n         * Deprecated. Add a `snap` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how action coordinates are snapped. By\n         * default, snapping is relative to the pointer coordinates. You can\n         * change this by setting the\n         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n         **\n         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | interact(document.querySelector('#thing')).snap({\n         |     targets: [\n         |         // snap to this specific point\n         |         {\n         |             x: 100,\n         |             y: 100,\n         |             range: 25\n         |         },\n         |         // give this function the x and y page coords and snap to the object returned\n         |         function (x, y) {\n         |             return {\n         |                 x: x,\n         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n         |                 range: 40\n         |             };\n         |         },\n         |         // create a function that snaps to a grid\n         |         interact.createSnapGrid({\n         |             x: 50,\n         |             y: 50,\n         |             range: 10,              // optional\n         |             offset: { x: 5, y: 10 } // optional\n         |         })\n         |     ],\n         |     // do not snap during normal movement.\n         |     // Instead, trigger only one snapped move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     relativePoints: [\n         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n         |         { x: 1, y: 1 },  // and also to the bottom right\n         |     ],  \n         |\n         |     // offset the snap target coordinates\n         |     // can be an object with x/y or 'startCoords'\n         |     offset: { x: 50, y: 50 }\n         |   }\n         | });\n        \\*/\n        snap: function (options) {\n            var ret = this.setOptions('snap', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        setOptions: function (option, options) {\n            var actions = options && isArray(options.actions)\n                    ? options.actions\n                    : ['drag'];\n\n            var i;\n\n            if (isObject(options) || isBool(options)) {\n                for (i = 0; i < actions.length; i++) {\n                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\n                    if (!isObject(this.options[action])) { continue; }\n\n                    var thisOption = this.options[action][option];\n\n                    if (isObject(options)) {\n                        extend(thisOption, options);\n                        thisOption.enabled = options.enabled === false? false: true;\n\n                        if (option === 'snap') {\n                            if (thisOption.mode === 'grid') {\n                                thisOption.targets = [\n                                    interact.createSnapGrid(extend({\n                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n                                    }, thisOption.grid || {}))\n                                ];\n                            }\n                            else if (thisOption.mode === 'anchor') {\n                                thisOption.targets = thisOption.anchors;\n                            }\n                            else if (thisOption.mode === 'path') {\n                                thisOption.targets = thisOption.paths;\n                            }\n\n                            if ('elementOrigin' in options) {\n                                thisOption.relativePoints = [options.elementOrigin];\n                            }\n                        }\n                    }\n                    else if (isBool(options)) {\n                        thisOption.enabled = options;\n                    }\n                }\n\n                return this;\n            }\n\n            var ret = {},\n                allActions = ['drag', 'resize', 'gesture'];\n\n            for (i = 0; i < allActions.length; i++) {\n                if (option in defaultOptions[allActions[i]]) {\n                    ret[allActions[i]] = this.options[allActions[i]][option];\n                }\n            }\n\n            return ret;\n        },\n\n\n        /*\\\n         * Interactable.inertia\n         [ method ]\n         **\n         * Deprecated. Add an `inertia` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how events continue to run after the pointer is released\n         **\n         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | // enable and use default settings\n         | interact(element).inertia(true);\n         |\n         | // enable and use custom settings\n         | interact(element).inertia({\n         |     // value greater than 0\n         |     // high values slow the object down more quickly\n         |     resistance     : 16,\n         |\n         |     // the minimum launch speed (pixels per second) that results in inertia start\n         |     minSpeed       : 200,\n         |\n         |     // inertia will stop when the object slows down to this speed\n         |     endSpeed       : 20,\n         |\n         |     // boolean; should actions be resumed when the pointer goes down during inertia\n         |     allowResume    : true,\n         |\n         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n         |     zeroResumeDelta: false,\n         |\n         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n         |     // the pointer without triggering inertia will animate from the release\n         |     // point to the snaped/restricted point in the given amount of time (ms)\n         |     smoothEndDuration: 300,\n         |\n         |     // an array of action types that can have inertia (no gesture)\n         |     actions        : ['drag', 'resize']\n         | });\n         |\n         | // reset custom settings and use all defaults\n         | interact(element).inertia(null);\n        \\*/\n        inertia: function (options) {\n            var ret = this.setOptions('inertia', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        getAction: function (pointer, event, interaction, element) {\n            var action = this.defaultActionChecker(pointer, interaction, element);\n\n            if (this.options.actionChecker) {\n                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n            }\n\n            return action;\n        },\n\n        defaultActionChecker: defaultActionChecker,\n\n        /*\\\n         * Interactable.actionChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check action to be performed on\n         * pointerDown\n         *\n         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         | interact('.resize-drag')\n         |   .resizable(true)\n         |   .draggable(true)\n         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n         |\n         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n         |     // force drag with handle target\n         |     action.name = drag;\n         |   }\n         |   else {\n         |     // resize from the top and right edges\n         |     action.name  = 'resize';\n         |     action.edges = { top: true, right: true };\n         |   }\n         |\n         |   return action;\n         | });\n        \\*/\n        actionChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.actionChecker = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.actionChecker;\n\n                return this;\n            }\n\n            return this.options.actionChecker;\n        },\n\n        /*\\\n         * Interactable.getRect\n         [ method ]\n         *\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using @Interactable.rectChecker.\n         *\n         - element (Element) #optional The element to measure.\n         = (object) The object's bounding rectangle.\n         o {\n         o     top   : 0,\n         o     left  : 0,\n         o     bottom: 0,\n         o     right : 0,\n         o     width : 0,\n         o     height: 0\n         o }\n        \\*/\n        getRect: function rectCheck (element) {\n            element = element || this._element;\n\n            if (this.selector && !(isElement(element))) {\n                element = this._context.querySelector(this.selector);\n            }\n\n            return getElementRect(element);\n        },\n\n        /*\\\n         * Interactable.rectChecker\n         [ method ]\n         *\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n         = (function | object) The checker function or this Interactable\n        \\*/\n        rectChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.getRect = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.getRect;\n        },\n\n        /*\\\n         * Interactable.styleCursor\n         [ method ]\n         *\n         * Returns or sets whether the action that would be performed when the\n         * mouse on the element are checked on `mousemove` so that the cursor\n         * may be styled appropriately\n         *\n         - newValue (boolean) #optional\n         = (boolean | Interactable) The current setting or this Interactable\n        \\*/\n        styleCursor: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.styleCursor = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.styleCursor;\n\n                return this;\n            }\n\n            return this.options.styleCursor;\n        },\n\n        /*\\\n         * Interactable.preventDefault\n         [ method ]\n         *\n         * Returns or sets whether to prevent the browser's default behaviour\n         * in response to pointer events. Can be set to:\n         *  - `'always'` to always prevent\n         *  - `'never'` to never prevent\n         *  - `'auto'` to let interact.js try to determine what would be best\n         *\n         - newValue (string) #optional `true`, `false` or `'auto'`\n         = (string | Interactable) The current setting or this Interactable\n        \\*/\n        preventDefault: function (newValue) {\n            if (/^(always|never|auto)$/.test(newValue)) {\n                this.options.preventDefault = newValue;\n                return this;\n            }\n\n            if (isBool(newValue)) {\n                this.options.preventDefault = newValue? 'always' : 'never';\n                return this;\n            }\n\n            return this.options.preventDefault;\n        },\n\n        /*\\\n         * Interactable.origin\n         [ method ]\n         *\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n         * OR\n         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n         **\n         = (object) The current origin or this Interactable\n        \\*/\n        origin: function (newValue) {\n            if (trySelector(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n            else if (isObject(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n\n            return this.options.origin;\n        },\n\n        /*\\\n         * Interactable.deltaSource\n         [ method ]\n         *\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n         = (string | object) The current deltaSource or this Interactable\n        \\*/\n        deltaSource: function (newValue) {\n            if (newValue === 'page' || newValue === 'client') {\n                this.options.deltaSource = newValue;\n\n                return this;\n            }\n\n            return this.options.deltaSource;\n        },\n\n        /*\\\n         * Interactable.restrict\n         [ method ]\n         **\n         * Deprecated. Add a `restrict` property to the options object passed to\n         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n         *\n         * Returns or sets the rectangles within which actions on this\n         * interactable (after snap calculations) are restricted. By default,\n         * restricting is relative to the pointer coordinates. You can change\n         * this by setting the\n         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n         **\n         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n         = (object) The current restrictions object or this Interactable\n         **\n         | interact(element).restrict({\n         |     // the rect will be `interact.getElementRect(element.parentNode)`\n         |     drag: element.parentNode,\n         |\n         |     // x and y are relative to the the interactable's origin\n         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n         | })\n         |\n         | interact('.draggable').restrict({\n         |     // the rect will be the selected element's parent\n         |     drag: 'parent',\n         |\n         |     // do not restrict during normal movement.\n         |     // Instead, trigger only one restricted move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n         | });\n        \\*/\n        restrict: function (options) {\n            if (!isObject(options)) {\n                return this.setOptions('restrict', options);\n            }\n\n            var actions = ['drag', 'resize', 'gesture'],\n                ret;\n\n            for (var i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                if (action in options) {\n                    var perAction = extend({\n                            actions: [action],\n                            restriction: options[action]\n                        }, options);\n\n                    ret = this.setOptions('restrict', perAction);\n                }\n            }\n\n            return ret;\n        },\n\n        /*\\\n         * Interactable.context\n         [ method ]\n         *\n         * Gets the selector context Node of the Interactable. The default is `window.document`.\n         *\n         = (Node) The context Node of this Interactable\n         **\n        \\*/\n        context: function () {\n            return this._context;\n        },\n\n        _context: document,\n\n        /*\\\n         * Interactable.ignoreFrom\n         [ method ]\n         *\n         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n         * event or any of it's parents match the given CSS selector or\n         * Element, no drag/resize/gesture is started.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n         = (string | Element | object) The current ignoreFrom value or this Interactable\n         **\n         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n         | // or\n         | interact(element).ignoreFrom('input, textarea, a');\n        \\*/\n        ignoreFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            return this.options.ignoreFrom;\n        },\n\n        /*\\\n         * Interactable.allowFrom\n         [ method ]\n         *\n         * A drag/resize/gesture is started only If the target of the\n         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n         * parents match the given CSS selector or Element.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n         = (string | Element | object) The current allowFrom value or this Interactable\n         **\n         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n         | // or\n         | interact(element).allowFrom('.handle');\n        \\*/\n        allowFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            return this.options.allowFrom;\n        },\n\n        /*\\\n         * Interactable.element\n         [ method ]\n         *\n         * If this is not a selector Interactable, it returns the element this\n         * interactable represents\n         *\n         = (Element) HTML / SVG Element\n        \\*/\n        element: function () {\n            return this._element;\n        },\n\n        /*\\\n         * Interactable.fire\n         [ method ]\n         *\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n         = (Interactable) this Interactable\n        \\*/\n        fire: function (iEvent) {\n            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n                return this;\n            }\n\n            var listeners,\n                i,\n                len,\n                onEvent = 'on' + iEvent.type,\n                funcName = '';\n\n            // Interactable#on() listeners\n            if (iEvent.type in this._iEvents) {\n                listeners = this._iEvents[iEvent.type];\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            // interactable.onevent listener\n            if (isFunction(this[onEvent])) {\n                funcName = this[onEvent].name;\n                this[onEvent](iEvent);\n            }\n\n            // interact.on() listeners\n            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.on\n         [ method ]\n         *\n         * Binds a listener for an InteractEvent or DOM event.\n         *\n         - eventType  (string | array | object) The types of events to listen for\n         - listener   (function) The function to be called on the given event(s)\n         - useCapture (boolean) #optional useCapture flag for addEventListener\n         = (object) This Interactable\n        \\*/\n        on: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.on(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.on(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (contains(eventTypes, eventType)) {\n                // if this type of event was never bound to this Interactable\n                if (!(eventType in this._iEvents)) {\n                    this._iEvents[eventType] = [listener];\n                }\n                else {\n                    this._iEvents[eventType].push(listener);\n                }\n            }\n            // delegated event for selector\n            else if (this.selector) {\n                if (!delegatedEvents[eventType]) {\n                    delegatedEvents[eventType] = {\n                        selectors: [],\n                        contexts : [],\n                        listeners: []\n                    };\n\n                    // add delegate listener functions\n                    for (i = 0; i < documents.length; i++) {\n                        events.add(documents[i], eventType, delegateListener);\n                        events.add(documents[i], eventType, delegateUseCapture, true);\n                    }\n                }\n\n                var delegated = delegatedEvents[eventType],\n                    index;\n\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n                        break;\n                    }\n                }\n\n                if (index === -1) {\n                    index = delegated.selectors.length;\n\n                    delegated.selectors.push(this.selector);\n                    delegated.contexts .push(this._context);\n                    delegated.listeners.push([]);\n                }\n\n                // keep listener and useCapture flag\n                delegated.listeners[index].push([listener, useCapture]);\n            }\n            else {\n                events.add(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.off\n         [ method ]\n         *\n         * Removes an InteractEvent or DOM event listener\n         *\n         - eventType  (string | array | object) The types of events that were listened for\n         - listener   (function) The listener function to be removed\n         - useCapture (boolean) #optional useCapture flag for removeEventListener\n         = (object) This Interactable\n        \\*/\n        off: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.off(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.off(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            var eventList,\n                index = -1;\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // if it is an action event type\n            if (contains(eventTypes, eventType)) {\n                eventList = this._iEvents[eventType];\n\n                if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n                    this._iEvents[eventType].splice(index, 1);\n                }\n            }\n            // delegated event\n            else if (this.selector) {\n                var delegated = delegatedEvents[eventType],\n                    matchFound = false;\n\n                if (!delegated) { return this; }\n\n                // count from last index of delegated to 0\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    // look for matching selector and context Node\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n\n                        var listeners = delegated.listeners[index];\n\n                        // each item of the listeners array is an array: [function, useCaptureFlag]\n                        for (i = listeners.length - 1; i >= 0; i--) {\n                            var fn = listeners[i][0],\n                                useCap = listeners[i][1];\n\n                            // check if the listener functions and useCapture flags match\n                            if (fn === listener && useCap === useCapture) {\n                                // remove the listener from the array of listeners\n                                listeners.splice(i, 1);\n\n                                // if all listeners for this interactable have been removed\n                                // remove the interactable from the delegated arrays\n                                if (!listeners.length) {\n                                    delegated.selectors.splice(index, 1);\n                                    delegated.contexts .splice(index, 1);\n                                    delegated.listeners.splice(index, 1);\n\n                                    // remove delegate function from context\n                                    events.remove(this._context, eventType, delegateListener);\n                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\n                                    // remove the arrays if they are empty\n                                    if (!delegated.selectors.length) {\n                                        delegatedEvents[eventType] = null;\n                                    }\n                                }\n\n                                // only remove one listener\n                                matchFound = true;\n                                break;\n                            }\n                        }\n\n                        if (matchFound) { break; }\n                    }\n                }\n            }\n            // remove listener from this Interatable's element\n            else {\n                events.remove(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.set\n         [ method ]\n         *\n         * Reset the options of this Interactable\n         - options (object) The new settings to apply\n         = (object) This Interactable\n        \\*/\n        set: function (options) {\n            if (!isObject(options)) {\n                options = {};\n            }\n\n            this.options = extend({}, defaultOptions.base);\n\n            var i,\n                actions = ['drag', 'drop', 'resize', 'gesture'],\n                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\n            for (i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                this.options[action] = extend({}, defaultOptions[action]);\n\n                this.setPerAction(action, perActions);\n\n                this[methods[i]](options[action]);\n            }\n\n            var settings = [\n                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n                    'rectChecker', 'styleCursor'\n                ];\n\n            for (i = 0, len = settings.length; i < len; i++) {\n                var setting = settings[i];\n\n                this.options[setting] = defaultOptions.base[setting];\n\n                if (setting in options) {\n                    this[setting](options[setting]);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.unset\n         [ method ]\n         *\n         * Remove this interactable from the list of interactables and remove\n         * it's drag, drop, resize and gesture capabilities\n         *\n         = (object) @interact\n        \\*/\n        unset: function () {\n            events.remove(this._element, 'all');\n\n            if (!isString(this.selector)) {\n                events.remove(this, 'all');\n                if (this.options.styleCursor) {\n                    this._element.style.cursor = '';\n                }\n            }\n            else {\n                // remove delegated events\n                for (var type in delegatedEvents) {\n                    var delegated = delegatedEvents[type];\n\n                    for (var i = 0; i < delegated.selectors.length; i++) {\n                        if (delegated.selectors[i] === this.selector\n                            && delegated.contexts[i] === this._context) {\n\n                            delegated.selectors.splice(i, 1);\n                            delegated.contexts .splice(i, 1);\n                            delegated.listeners.splice(i, 1);\n\n                            // remove the arrays if they are empty\n                            if (!delegated.selectors.length) {\n                                delegatedEvents[type] = null;\n                            }\n                        }\n\n                        events.remove(this._context, type, delegateListener);\n                        events.remove(this._context, type, delegateUseCapture, true);\n\n                        break;\n                    }\n                }\n            }\n\n            this.dropzone(false);\n\n            interactables.splice(indexOf(interactables, this), 1);\n\n            return interact;\n        }\n    };\n\n    function warnOnce (method, message) {\n        var warned = false;\n\n        return function () {\n            if (!warned) {\n                window.console.warn(message);\n                warned = true;\n            }\n\n            return method.apply(this, arguments);\n        };\n    }\n\n    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\n    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n    Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\n    /*\\\n     * interact.isSet\n     [ method ]\n     *\n     * Check if an element has been set\n     - element (Element) The Element being searched for\n     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n    \\*/\n    interact.isSet = function(element, options) {\n        return interactables.indexOfElement(element, options && options.context) !== -1;\n    };\n\n    /*\\\n     * interact.on\n     [ method ]\n     *\n     * Adds a global listener for an InteractEvent or adds a DOM event to\n     * `document`\n     *\n     - type       (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) interact\n    \\*/\n    interact.on = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.on(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.on(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        // if it is an InteractEvent type, add listener to globalEvents\n        if (contains(eventTypes, type)) {\n            // if this type of event was never bound\n            if (!globalEvents[type]) {\n                globalEvents[type] = [listener];\n            }\n            else {\n                globalEvents[type].push(listener);\n            }\n        }\n        // If non InteractEvent type, addEventListener to document\n        else {\n            events.add(document, type, listener, useCapture);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.off\n     [ method ]\n     *\n     * Removes a global InteractEvent listener or DOM event from `document`\n     *\n     - type       (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) interact\n     \\*/\n    interact.off = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.off(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.off(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        if (!contains(eventTypes, type)) {\n            events.remove(document, type, listener, useCapture);\n        }\n        else {\n            var index;\n\n            if (type in globalEvents\n                && (index = indexOf(globalEvents[type], listener)) !== -1) {\n                globalEvents[type].splice(index, 1);\n            }\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.enableDragging\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether dragging is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableDragging = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.drag = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.drag;\n    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableResizing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether resizing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableResizing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.resize = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.resize;\n    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableGesturing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether gesturing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableGesturing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.gesture = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.gesture;\n    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\n    interact.eventTypes = eventTypes;\n\n    /*\\\n     * interact.debug\n     [ method ]\n     *\n     * Returns debugging data\n     = (object) An object with properties that outline the current state and expose internal functions and variables\n    \\*/\n    interact.debug = function () {\n        var interaction = interactions[0] || new Interaction();\n\n        return {\n            interactions          : interactions,\n            target                : interaction.target,\n            dragging              : interaction.dragging,\n            resizing              : interaction.resizing,\n            gesturing             : interaction.gesturing,\n            prepared              : interaction.prepared,\n            matches               : interaction.matches,\n            matchElements         : interaction.matchElements,\n\n            prevCoords            : interaction.prevCoords,\n            startCoords           : interaction.startCoords,\n\n            pointerIds            : interaction.pointerIds,\n            pointers              : interaction.pointers,\n            addPointer            : listeners.addPointer,\n            removePointer         : listeners.removePointer,\n            recordPointer        : listeners.recordPointer,\n\n            snap                  : interaction.snapStatus,\n            restrict              : interaction.restrictStatus,\n            inertia               : interaction.inertiaStatus,\n\n            downTime              : interaction.downTimes[0],\n            downEvent             : interaction.downEvent,\n            downPointer           : interaction.downPointer,\n            prevEvent             : interaction.prevEvent,\n\n            Interactable          : Interactable,\n            interactables         : interactables,\n            pointerIsDown         : interaction.pointerIsDown,\n            defaultOptions        : defaultOptions,\n            defaultActionChecker  : defaultActionChecker,\n\n            actionCursors         : actionCursors,\n            dragMove              : listeners.dragMove,\n            resizeMove            : listeners.resizeMove,\n            gestureMove           : listeners.gestureMove,\n            pointerUp             : listeners.pointerUp,\n            pointerDown           : listeners.pointerDown,\n            pointerMove           : listeners.pointerMove,\n            pointerHover          : listeners.pointerHover,\n\n            eventTypes            : eventTypes,\n\n            events                : events,\n            globalEvents          : globalEvents,\n            delegatedEvents       : delegatedEvents,\n\n            prefixedPropREs       : prefixedPropREs\n        };\n    };\n\n    // expose the functions used to calculate multi-touch properties\n    interact.getPointerAverage = pointerAverage;\n    interact.getTouchBBox     = touchBBox;\n    interact.getTouchDistance = touchDistance;\n    interact.getTouchAngle    = touchAngle;\n\n    interact.getElementRect         = getElementRect;\n    interact.getElementClientRect   = getElementClientRect;\n    interact.matchesSelector        = matchesSelector;\n    interact.closest                = closest;\n\n    /*\\\n     * interact.margin\n     [ method ]\n     *\n     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n     * Returns or sets the margin for autocheck resizing used in\n     * @Interactable.getAction. That is the distance from the bottom and right\n     * edges of an element clicking in which will start resizing\n     *\n     - newValue (number) #optional\n     = (number | interact) The current margin value or interact\n    \\*/\n    interact.margin = warnOnce(function (newvalue) {\n        if (isNumber(newvalue)) {\n            margin = newvalue;\n\n            return interact;\n        }\n        return margin;\n    },\n    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\n    /*\\\n     * interact.supportsTouch\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports touch input\n    \\*/\n    interact.supportsTouch = function () {\n        return supportsTouch;\n    };\n\n    /*\\\n     * interact.supportsPointerEvent\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports PointerEvents\n    \\*/\n    interact.supportsPointerEvent = function () {\n        return supportsPointerEvent;\n    };\n\n    /*\\\n     * interact.stop\n     [ method ]\n     *\n     * Cancels all interactions (end events are not fired)\n     *\n     - event (Event) An event on which to call preventDefault()\n     = (object) interact\n    \\*/\n    interact.stop = function (event) {\n        for (var i = interactions.length - 1; i >= 0; i--) {\n            interactions[i].stop(event);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.dynamicDrop\n     [ method ]\n     *\n     * Returns or sets whether the dimensions of dropzone elements are\n     * calculated on every dragmove or only on dragstart for the default\n     * dropChecker\n     *\n     - newValue (boolean) #optional True to check on each move. False to check only before start\n     = (boolean | interact) The current setting or interact\n    \\*/\n    interact.dynamicDrop = function (newValue) {\n        if (isBool(newValue)) {\n            //if (dragging && dynamicDrop !== newValue && !newValue) {\n                //calcRects(dropzones);\n            //}\n\n            dynamicDrop = newValue;\n\n            return interact;\n        }\n        return dynamicDrop;\n    };\n\n    /*\\\n     * interact.pointerMoveTolerance\n     [ method ]\n     * Returns or sets the distance the pointer must be moved before an action\n     * sequence occurs. This also affects tolerance for tap events.\n     *\n     - newValue (number) #optional The movement from the start position must be greater than this value\n     = (number | Interactable) The current setting or interact\n    \\*/\n    interact.pointerMoveTolerance = function (newValue) {\n        if (isNumber(newValue)) {\n            pointerMoveTolerance = newValue;\n\n            return this;\n        }\n\n        return pointerMoveTolerance;\n    };\n\n    /*\\\n     * interact.maxInteractions\n     [ method ]\n     **\n     * Returns or sets the maximum number of concurrent interactions allowed.\n     * By default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables\n     * and elements, you need to enable it in the draggable, resizable and\n     * gesturable `'max'` and `'maxPerElement'` options.\n     **\n     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n    \\*/\n    interact.maxInteractions = function (newValue) {\n        if (isNumber(newValue)) {\n            maxInteractions = newValue;\n\n            return this;\n        }\n\n        return maxInteractions;\n    };\n\n    interact.createSnapGrid = function (grid) {\n        return function (x, y) {\n            var offsetX = 0,\n                offsetY = 0;\n\n            if (isObject(grid.offset)) {\n                offsetX = grid.offset.x;\n                offsetY = grid.offset.y;\n            }\n\n            var gridx = Math.round((x - offsetX) / grid.x),\n                gridy = Math.round((y - offsetY) / grid.y),\n\n                newX = gridx * grid.x + offsetX,\n                newY = gridy * grid.y + offsetY;\n\n            return {\n                x: newX,\n                y: newY,\n                range: grid.range\n            };\n        };\n    };\n\n    function endAllInteractions (event) {\n        for (var i = 0; i < interactions.length; i++) {\n            interactions[i].pointerEnd(event, event);\n        }\n    }\n\n    function listenToDocument (doc) {\n        if (contains(documents, doc)) { return; }\n\n        var win = doc.defaultView || doc.parentWindow;\n\n        // add delegate event listener\n        for (var eventType in delegatedEvents) {\n            events.add(doc, eventType, delegateListener);\n            events.add(doc, eventType, delegateUseCapture, true);\n        }\n\n        if (PointerEvent) {\n            if (PointerEvent === win.MSPointerEvent) {\n                pEventTypes = {\n                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n            }\n            else {\n                pEventTypes = {\n                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n            }\n\n            events.add(doc, pEventTypes.down  , listeners.selectorDown );\n            events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n            events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n            events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n            events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n        }\n        else {\n            events.add(doc, 'mousedown', listeners.selectorDown);\n            events.add(doc, 'mousemove', listeners.pointerMove );\n            events.add(doc, 'mouseup'  , listeners.pointerUp   );\n            events.add(doc, 'mouseover', listeners.pointerOver );\n            events.add(doc, 'mouseout' , listeners.pointerOut  );\n\n            events.add(doc, 'touchstart' , listeners.selectorDown );\n            events.add(doc, 'touchmove'  , listeners.pointerMove  );\n            events.add(doc, 'touchend'   , listeners.pointerUp    );\n            events.add(doc, 'touchcancel', listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, 'mousemove', listeners.autoScrollMove);\n            events.add(doc, 'touchmove', listeners.autoScrollMove);\n        }\n\n        events.add(win, 'blur', endAllInteractions);\n\n        try {\n            if (win.frameElement) {\n                var parentDoc = win.frameElement.ownerDocument,\n                    parentWindow = parentDoc.defaultView;\n\n                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n                events.add(parentWindow, 'blur'         , endAllInteractions );\n            }\n        }\n        catch (error) {\n            interact.windowParentError = error;\n        }\n\n        // prevent native HTML5 drag on interact.js target elements\n        events.add(doc, 'dragstart', function (event) {\n            for (var i = 0; i < interactions.length; i++) {\n                var interaction = interactions[i];\n\n                if (interaction.element\n                    && (interaction.element === event.target\n                        || nodeContains(interaction.element, event.target))) {\n\n                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n                    return;\n                }\n            }\n        });\n\n        if (events.useAttachEvent) {\n            // For IE's lack of Event#preventDefault\n            events.add(doc, 'selectstart', function (event) {\n                var interaction = interactions[0];\n\n                if (interaction.currentAction()) {\n                    interaction.checkAndPreventDefault(event);\n                }\n            });\n\n            // For IE's bad dblclick event sequence\n            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n        }\n\n        documents.push(doc);\n    }\n\n    listenToDocument(document);\n\n    function indexOf (array, target) {\n        for (var i = 0, len = array.length; i < len; i++) {\n            if (array[i] === target) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    function contains (array, target) {\n        return indexOf(array, target) !== -1;\n    }\n\n    function matchesSelector (element, selector, nodeList) {\n        if (ie8MatchesSelector) {\n            return ie8MatchesSelector(element, selector, nodeList);\n        }\n\n        // remove /deep/ from selectors if shadowDOM polyfill is used\n        if (window !== realWindow) {\n            selector = selector.replace(/\\/deep\\//g, ' ');\n        }\n\n        return element[prefixedMatchesSelector](selector);\n    }\n\n    function matchesUpTo (element, selector, limit) {\n        while (isElement(element)) {\n            if (matchesSelector(element, selector)) {\n                return true;\n            }\n\n            element = parentElement(element);\n\n            if (element === limit) {\n                return matchesSelector(element, selector);\n            }\n        }\n\n        return false;\n    }\n\n    // For IE8's lack of an Element#matchesSelector\n    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n        ie8MatchesSelector = function (element, selector, elems) {\n            elems = elems || element.parentNode.querySelectorAll(selector);\n\n            for (var i = 0, len = elems.length; i < len; i++) {\n                if (elems[i] === element) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    // requestAnimationFrame polyfill\n    (function() {\n        var lastTime = 0,\n            vendors = ['ms', 'moz', 'webkit', 'o'];\n\n        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n        }\n\n        if (!reqFrame) {\n            reqFrame = function(callback) {\n                var currTime = new Date().getTime(),\n                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n                    id = setTimeout(function() { callback(currTime + timeToCall); },\n                  timeToCall);\n                lastTime = currTime + timeToCall;\n                return id;\n            };\n        }\n\n        if (!cancelFrame) {\n            cancelFrame = function(id) {\n                clearTimeout(id);\n            };\n        }\n    }());\n\n    /* global exports: true, module, define */\n\n    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = interact;\n        }\n        exports.interact = interact;\n    }\n    // AMD\n    else if (typeof define === 'function' && define.amd) {\n        define('interact', function() {\n            return interact;\n        });\n    }\n    else {\n        realWindow.interact = interact;\n    }\n\n} (typeof window === 'undefined'? undefined : window));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/interact.js/interact.js\n ** module id = 30\n ** module chunks = 0 1 2 3 4 5\n **/","module.exports = \" <div class=\\\"w-app card\\\" v-bind:class=\\\"[loading ? 'isLoading': '', isDeleted ? 'animated zoomOutDown': '', isMax ? 'is-fullwidth' : '']\\\" @click=bringToFront @mousedown=bringToFront @animationend=makeMe draggable=true tabindex=0 _v-ca6846e8=\\\"\\\"> <header class=card-header _v-ca6846e8=\\\"\\\"> <p class=card-header-title _v-ca6846e8=\\\"\\\"> {{title}} </p> <a class=card-header-icon _v-ca6846e8=\\\"\\\"> <i class=\\\"fa fa-minus\\\" _v-ca6846e8=\\\"\\\"></i> </a> <a class=card-header-icon @click=maxApp _v-ca6846e8=\\\"\\\"> <i class=fa v-bind:class=\\\"[isMax ? 'fa-compress': 'fa-expand']\\\" _v-ca6846e8=\\\"\\\"></i> </a> <a class=card-header-icon @click=closeApp _v-ca6846e8=\\\"\\\"> <i class=\\\"fa fa-times\\\" _v-ca6846e8=\\\"\\\"></i> </a> </header> <header v-if=hasSubNav class=\\\"card-header card-header--subnav\\\" _v-ca6846e8=\\\"\\\"> <slot name=header _v-ca6846e8=\\\"\\\"></slot> </header> <div class=card-content _v-ca6846e8=\\\"\\\"> <div class=content _v-ca6846e8=\\\"\\\"> <slot _v-ca6846e8=\\\"\\\"></slot> </div> </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/template-rewriter.js?id=_v-ca6846e8!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/wApp.vue\n ** module id = 33\n ** module chunks = 0 1 2 3 4 5\n **/","var __vue_script__, __vue_template__\nrequire(\"!!./../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-ca6846e8&scoped=true!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./wApp.vue\")\nrequire(\"!!./../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=1!./wApp.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/vue-loader/lib/selector.js?type=script&index=0!./wApp.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/vue-loader/lib/template-rewriter.js?id=_v-ca6846e8!./../../node_modules/vue-loader/lib/selector.js?type=template&index=0!./wApp.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/wApp.vue\n ** module id = 34\n ** module chunks = 0 1 2 3 4 5\n **/","<template>\n  <w-app \n    title='Text-Editor' \n    class='app--text-editor animated fadeInDown'\n    :has-sub-nav=true>\n    <nav slot='header'>\n      <p class=\"panel-tabs\">\n        <a @click='getFileSystem' class=\"\" href=\"#\">Open</a>\n        <a @click='saveFile' class=\"\" href=\"#\">Save</a>\n        <a @click=\"openNew('textEditor')\" class=\"\" href=\"#\">New</a>\n      </p>\n    </nav>\n    <p class=\"control\">\n      <textarea class=\"textarea\" v-model='fileData' placeholder=\"Type..\">{{fileData}}</textarea>\n    </p>\n  </w-app>\n</template>\n\n<script>\nimport wApp from '../wApp'\nexport default {\n  data () {\n    return {\n      fileName: '',\n      fileData: ''\n    }\n  },\n  components: {\n    wApp\n  },\n  methods: {\n    saveFile (data) {\n      // localforage.set(data.filename, data.content)\n      console.log('save file:', this.fileData)\n      this.$dispatch('saveFile', {data: this.fileData, name: this.fileName})\n    },\n    getFileSystem (e) {\n      console.log('getFileSystem:', this)\n      this.$dispatch('getFileSystem', this)\n    },\n    openNew (app) {\n      this.$dispatch('openApp', app)\n    }\n  }\n}\n</script>\n\n<style scoped>\n</style>\n\n\n\n/** WEBPACK FOOTER **\n ** textEditor.vue?4c4d5298\n **/","exports = module.exports = require(\"./../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\", {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"textEditor.vue\",\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js?id=_v-082eb0c5&scoped=true!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/apps/textEditor.vue\n ** module id = 369\n ** module chunks = 4\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../node_modules/css-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-082eb0c5&scoped=true!./../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./textEditor.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-082eb0c5&scoped=true!./../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./textEditor.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-082eb0c5&scoped=true!./../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./textEditor.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?sourceMap!./~/vue-loader/lib/style-rewriter.js?id=_v-082eb0c5&scoped=true!./~/vue-loader/lib/selector.js?type=style&index=0!./src/components/apps/textEditor.vue\n ** module id = 380\n ** module chunks = 4\n **/","module.exports = \" <w-app title=Text-Editor class=\\\"app--text-editor animated fadeInDown\\\" :has-sub-nav=true _v-082eb0c5=\\\"\\\"> <nav slot=header _v-082eb0c5=\\\"\\\"> <p class=panel-tabs _v-082eb0c5=\\\"\\\"> <a @click=getFileSystem class=\\\"\\\" href=# _v-082eb0c5=\\\"\\\">Open</a> <a @click=saveFile class=\\\"\\\" href=# _v-082eb0c5=\\\"\\\">Save</a> <a @click=\\\"openNew('textEditor')\\\" class=\\\"\\\" href=# _v-082eb0c5=\\\"\\\">New</a> </p> </nav> <p class=control _v-082eb0c5=\\\"\\\"> <textarea class=textarea v-model=fileData placeholder=Type.. _v-082eb0c5=\\\"\\\">{{fileData}}</textarea> </p> </w-app> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/template-rewriter.js?id=_v-082eb0c5!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/apps/textEditor.vue\n ** module id = 753\n ** module chunks = 4\n **/","var __vue_script__, __vue_template__\nrequire(\"!!./../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-082eb0c5&scoped=true!./../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./textEditor.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../../node_modules/vue-loader/lib/selector.js?type=script&index=0!./textEditor.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../../node_modules/vue-loader/lib/template-rewriter.js?id=_v-082eb0c5!./../../../node_modules/vue-loader/lib/selector.js?type=template&index=0!./textEditor.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/apps/textEditor.vue\n ** module id = 765\n ** module chunks = 4\n **/"],"sourceRoot":""}